// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using MonoGame.Framework.Graphics;

namespace TwoMGFX.TPGParser
{
    #region ParseTree

    [Serializable]
    public class ParseErrors : List<ParseError>
    {
    }

    [Serializable]
    public class ParseError
    {
        public string File { get; private set; }
        public int Code { get; private set; }
        public int Line { get; private set; }
        public int Column { get; private set; }
        public int Position { get; private set; }
        public int Length { get; private set; }
        public string Message { get; private set; }

        /// <summary>
        /// For the sake of serialization.
        /// </summary>
        public ParseError()
        {
        }

        public ParseError(string message, int code, ParseNode node) : this(message, code, node.Token)
        {
        }

        public ParseError(string message, int code, Token token) : this(
            message, code, token.File, token.Line, token.Column, token.StartPos, token.Length)
        {
        }

        public ParseError(string message, int code) : this(message, code, string.Empty, 0, 0, 0, 0)
        {
        }

        public ParseError(string message, int code, string file, int line, int col, int pos, int length)
        {
            File = file;
            Message = message;
            Code = code;
            Line = line;
            Column = col;
            Position = pos;
            Length = length;
        }
    }

    /// <summary>
    /// Rootlevel of the node tree.
    /// </summary>
    [Serializable]
    public partial class ParseTree : ParseNode
    {
        public ParseErrors Errors;

        public List<Token> Skipped;

        public ParseTree() : base(new Token(), "ParseTree")
        {
            Token.Type = TokenType.Start;
            Token.Text = "Root";
            Errors = new ParseErrors();
        }

        public string PrintTree()
        {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode(sb, this, indent);
            return sb.ToString();
        }

        private void PrintNode(StringBuilder sb, ParseNode node, int indent)
        {

            string space = "".PadLeft(indent, ' ');

            sb.Append(space);
            sb.AppendLine(node.Text);

            foreach (ParseNode n in node.Nodes)
                PrintNode(sb, n, indent + 2);
        }

        /// <summary>
        /// This is the entry point for executing and evaluating the parse tree.
        /// </summary>
        /// <param name="paramlist">Additional optional input parameters.</param>
        /// <returns>The output of the evaluation function.</returns>
        public object Eval(params object[] paramlist)
        {
            return Nodes[0].Eval(this, paramlist);
        }
    }

    [Serializable]
    [XmlInclude(typeof(ParseTree))]
    public partial class ParseNode
    {
        public List<ParseNode> Nodes { get; protected set; }

        [XmlIgnore] // avoid circular references when serializing
        public ParseNode Parent;
        public Token Token; // the token/rule

        [XmlIgnore] // skip redundant text (is part of Token)
        public string Text
        { // text to display in parse tree 
            get;
            protected set;
        }

        public virtual ParseNode CreateNode(Token token, string text)
        {
            ParseNode node = new ParseNode(token, text)
            {
                Parent = this
            };
            return node;
        }

        protected ParseNode(Token token, string text)
        {
            Token = token;
            Text = text;
            Nodes = new List<ParseNode>();
        }

        protected object GetValue(ParseTree tree, TokenType type, int index)
        {
            return GetValueByRef(tree, type, ref index);
        }

        protected object GetValueByRef(ParseTree tree, TokenType type, ref int index)
        {
            if (index < 0)
                return null;

            // left to right
            foreach (ParseNode node in Nodes)
            {
                if (node.Token.Type == type)
                {
                    index--;
                    if (index < 0)
                    {
                        return node.Eval(tree);
                    }
                }
            }
            return null;
        }

        /// <summary>
        /// This implements the evaluation functionality, cannot be used directly.
        /// </summary>
        /// <param name="tree">The parsetree itself.</param>
        /// <param name="paramlist">Optional input parameters.</param>
        /// <returns>A partial result of the evaluation.</returns>
        internal object Eval(ParseTree tree, params object[] paramlist)
        {
            switch (Token.Type)
            {
                case TokenType.Start:
                    return EvalStart(tree, paramlist);

                case TokenType.Technique_Declaration:
                    return EvalTechnique_Declaration(tree, paramlist);

                case TokenType.FillMode_Solid:
                    return EvalFillMode_Solid(tree, paramlist);

                case TokenType.FillMode_WireFrame:
                    return EvalFillMode_WireFrame(tree, paramlist);

                case TokenType.FillModes:
                    return EvalFillModes(tree, paramlist);

                case TokenType.CullMode_None:
                    return EvalCullMode_None(tree, paramlist);

                case TokenType.CullMode_Cw:
                    return EvalCullMode_Cw(tree, paramlist);

                case TokenType.CullMode_Ccw:
                    return EvalCullMode_Ccw(tree, paramlist);

                case TokenType.CullModes:
                    return EvalCullModes(tree, paramlist);

                case TokenType.Colors_None:
                    return EvalColors_None(tree, paramlist);

                case TokenType.Colors_Red:
                    return EvalColors_Red(tree, paramlist);

                case TokenType.Colors_Green:
                    return EvalColors_Green(tree, paramlist);

                case TokenType.Colors_Blue:
                    return EvalColors_Blue(tree, paramlist);

                case TokenType.Colors_Alpha:
                    return EvalColors_Alpha(tree, paramlist);

                case TokenType.Colors_All:
                    return EvalColors_All(tree, paramlist);

                case TokenType.Colors_Boolean:
                    return EvalColors_Boolean(tree, paramlist);

                case TokenType.Colors:
                    return EvalColors(tree, paramlist);

                case TokenType.ColorsMasks:
                    return EvalColorsMasks(tree, paramlist);

                case TokenType.Blend_Zero:
                    return EvalBlend_Zero(tree, paramlist);

                case TokenType.Blend_One:
                    return EvalBlend_One(tree, paramlist);

                case TokenType.Blend_SrcColor:
                    return EvalBlend_SrcColor(tree, paramlist);

                case TokenType.Blend_InvSrcColor:
                    return EvalBlend_InvSrcColor(tree, paramlist);

                case TokenType.Blend_SrcAlpha:
                    return EvalBlend_SrcAlpha(tree, paramlist);

                case TokenType.Blend_InvSrcAlpha:
                    return EvalBlend_InvSrcAlpha(tree, paramlist);

                case TokenType.Blend_DestAlpha:
                    return EvalBlend_DestAlpha(tree, paramlist);

                case TokenType.Blend_InvDestAlpha:
                    return EvalBlend_InvDestAlpha(tree, paramlist);

                case TokenType.Blend_DestColor:
                    return EvalBlend_DestColor(tree, paramlist);

                case TokenType.Blend_InvDestColor:
                    return EvalBlend_InvDestColor(tree, paramlist);

                case TokenType.Blend_SrcAlphaSat:
                    return EvalBlend_SrcAlphaSat(tree, paramlist);

                case TokenType.Blend_BlendFactor:
                    return EvalBlend_BlendFactor(tree, paramlist);

                case TokenType.Blend_InvBlendFactor:
                    return EvalBlend_InvBlendFactor(tree, paramlist);

                case TokenType.Blends:
                    return EvalBlends(tree, paramlist);

                case TokenType.BlendOp_Add:
                    return EvalBlendOp_Add(tree, paramlist);

                case TokenType.BlendOp_Subtract:
                    return EvalBlendOp_Subtract(tree, paramlist);

                case TokenType.BlendOp_RevSubtract:
                    return EvalBlendOp_RevSubtract(tree, paramlist);

                case TokenType.BlendOp_Min:
                    return EvalBlendOp_Min(tree, paramlist);

                case TokenType.BlendOp_Max:
                    return EvalBlendOp_Max(tree, paramlist);

                case TokenType.BlendOps:
                    return EvalBlendOps(tree, paramlist);

                case TokenType.CmpFunc_Never:
                    return EvalCmpFunc_Never(tree, paramlist);

                case TokenType.CmpFunc_Less:
                    return EvalCmpFunc_Less(tree, paramlist);

                case TokenType.CmpFunc_Equal:
                    return EvalCmpFunc_Equal(tree, paramlist);

                case TokenType.CmpFunc_LessEqual:
                    return EvalCmpFunc_LessEqual(tree, paramlist);

                case TokenType.CmpFunc_Greater:
                    return EvalCmpFunc_Greater(tree, paramlist);

                case TokenType.CmpFunc_NotEqual:
                    return EvalCmpFunc_NotEqual(tree, paramlist);

                case TokenType.CmpFunc_GreaterEqual:
                    return EvalCmpFunc_GreaterEqual(tree, paramlist);

                case TokenType.CmpFunc_Always:
                    return EvalCmpFunc_Always(tree, paramlist);

                case TokenType.CmpFunc:
                    return EvalCmpFunc(tree, paramlist);

                case TokenType.StencilOp_Keep:
                    return EvalStencilOp_Keep(tree, paramlist);

                case TokenType.StencilOp_Zero:
                    return EvalStencilOp_Zero(tree, paramlist);

                case TokenType.StencilOp_Replace:
                    return EvalStencilOp_Replace(tree, paramlist);

                case TokenType.StencilOp_IncrSat:
                    return EvalStencilOp_IncrSat(tree, paramlist);

                case TokenType.StencilOp_DecrSat:
                    return EvalStencilOp_DecrSat(tree, paramlist);

                case TokenType.StencilOp_Invert:
                    return EvalStencilOp_Invert(tree, paramlist);

                case TokenType.StencilOp_Incr:
                    return EvalStencilOp_Incr(tree, paramlist);

                case TokenType.StencilOp_Decr:
                    return EvalStencilOp_Decr(tree, paramlist);

                case TokenType.StencilOp:
                    return EvalStencilOp(tree, paramlist);

                case TokenType.Render_State_CullMode:
                    return EvalRender_State_CullMode(tree, paramlist);

                case TokenType.Render_State_FillMode:
                    return EvalRender_State_FillMode(tree, paramlist);

                case TokenType.Render_State_AlphaBlendEnable:
                    return EvalRender_State_AlphaBlendEnable(tree, paramlist);

                case TokenType.Render_State_SrcBlend:
                    return EvalRender_State_SrcBlend(tree, paramlist);

                case TokenType.Render_State_DestBlend:
                    return EvalRender_State_DestBlend(tree, paramlist);

                case TokenType.Render_State_BlendOp:
                    return EvalRender_State_BlendOp(tree, paramlist);

                case TokenType.Render_State_ColorWriteEnable:
                    return EvalRender_State_ColorWriteEnable(tree, paramlist);

                case TokenType.Render_State_DepthBias:
                    return EvalRender_State_DepthBias(tree, paramlist);

                case TokenType.Render_State_SlopeScaleDepthBias:
                    return EvalRender_State_SlopeScaleDepthBias(tree, paramlist);

                case TokenType.Render_State_ZEnable:
                    return EvalRender_State_ZEnable(tree, paramlist);

                case TokenType.Render_State_ZWriteEnable:
                    return EvalRender_State_ZWriteEnable(tree, paramlist);

                case TokenType.Render_State_ZFunc:
                    return EvalRender_State_ZFunc(tree, paramlist);

                case TokenType.Render_State_MultiSampleAntiAlias:
                    return EvalRender_State_MultiSampleAntiAlias(tree, paramlist);

                case TokenType.Render_State_ScissorTestEnable:
                    return EvalRender_State_ScissorTestEnable(tree, paramlist);

                case TokenType.Render_State_StencilEnable:
                    return EvalRender_State_StencilEnable(tree, paramlist);

                case TokenType.Render_State_StencilFail:
                    return EvalRender_State_StencilFail(tree, paramlist);

                case TokenType.Render_State_StencilFunc:
                    return EvalRender_State_StencilFunc(tree, paramlist);

                case TokenType.Render_State_StencilMask:
                    return EvalRender_State_StencilMask(tree, paramlist);

                case TokenType.Render_State_StencilPass:
                    return EvalRender_State_StencilPass(tree, paramlist);

                case TokenType.Render_State_StencilRef:
                    return EvalRender_State_StencilRef(tree, paramlist);

                case TokenType.Render_State_StencilWriteMask:
                    return EvalRender_State_StencilWriteMask(tree, paramlist);

                case TokenType.Render_State_StencilZFail:
                    return EvalRender_State_StencilZFail(tree, paramlist);

                case TokenType.Render_State_Expression:
                    return EvalRender_State_Expression(tree, paramlist);

                case TokenType.Pass_Declaration:
                    return EvalPass_Declaration(tree, paramlist);

                case TokenType.VertexShader_Pass_Expression:
                    return EvalVertexShader_Pass_Expression(tree, paramlist);

                case TokenType.PixelShader_Pass_Expression:
                    return EvalPixelShader_Pass_Expression(tree, paramlist);

                case TokenType.AddressMode_Clamp:
                    return EvalAddressMode_Clamp(tree, paramlist);

                case TokenType.AddressMode_Wrap:
                    return EvalAddressMode_Wrap(tree, paramlist);

                case TokenType.AddressMode_Mirror:
                    return EvalAddressMode_Mirror(tree, paramlist);

                case TokenType.AddressMode_Border:
                    return EvalAddressMode_Border(tree, paramlist);

                case TokenType.AddressMode:
                    return EvalAddressMode(tree, paramlist);

                case TokenType.TextureFilter_None:
                    return EvalTextureFilter_None(tree, paramlist);

                case TokenType.TextureFilter_Linear:
                    return EvalTextureFilter_Linear(tree, paramlist);

                case TokenType.TextureFilter_Point:
                    return EvalTextureFilter_Point(tree, paramlist);

                case TokenType.TextureFilter_Anisotropic:
                    return EvalTextureFilter_Anisotropic(tree, paramlist);

                case TokenType.TextureFilter:
                    return EvalTextureFilter(tree, paramlist);

                case TokenType.Sampler_State_Texture:
                    return EvalSampler_State_Texture(tree, paramlist);

                case TokenType.Sampler_State_MinFilter:
                    return EvalSampler_State_MinFilter(tree, paramlist);

                case TokenType.Sampler_State_MagFilter:
                    return EvalSampler_State_MagFilter(tree, paramlist);

                case TokenType.Sampler_State_MipFilter:
                    return EvalSampler_State_MipFilter(tree, paramlist);

                case TokenType.Sampler_State_Filter:
                    return EvalSampler_State_Filter(tree, paramlist);

                case TokenType.Sampler_State_AddressU:
                    return EvalSampler_State_AddressU(tree, paramlist);

                case TokenType.Sampler_State_AddressV:
                    return EvalSampler_State_AddressV(tree, paramlist);

                case TokenType.Sampler_State_AddressW:
                    return EvalSampler_State_AddressW(tree, paramlist);

                case TokenType.Sampler_State_BorderColor:
                    return EvalSampler_State_BorderColor(tree, paramlist);

                case TokenType.Sampler_State_MaxMipLevel:
                    return EvalSampler_State_MaxMipLevel(tree, paramlist);

                case TokenType.Sampler_State_MaxAnisotropy:
                    return EvalSampler_State_MaxAnisotropy(tree, paramlist);

                case TokenType.Sampler_State_MipLodBias:
                    return EvalSampler_State_MipLodBias(tree, paramlist);

                case TokenType.Sampler_State_Expression:
                    return EvalSampler_State_Expression(tree, paramlist);

                case TokenType.Sampler_Register_Expression:
                    return EvalSampler_Register_Expression(tree, paramlist);

                case TokenType.Sampler_Declaration_States:
                    return EvalSampler_Declaration_States(tree, paramlist);

                case TokenType.Sampler_Declaration:
                    return EvalSampler_Declaration(tree, paramlist);

                default:
                    return Token.Text;
            }
        }

        protected virtual object EvalStart(ParseTree tree, params object[] paramlist)
        {
            var shader = new ShaderInfo();

            foreach (var node in Nodes)
                node.Eval(tree, shader);

            return shader;
        }

        protected virtual object EvalTechnique_Declaration(ParseTree tree, params object[] paramlist)
        {
            var technique = new TechniqueInfo
            {
                name = GetValue(tree, TokenType.Identifier, 0) as string ?? string.Empty,
                startPos = Token.StartPos,
                length = Token.Length
            };

            foreach (var node in Nodes)
                node.Eval(tree, technique);

            // Make sure we have at least one pass.
            if (technique.Passes.Count > 0)
            {
                var shaderInfo = paramlist[0] as ShaderInfo;
                shaderInfo.Techniques.Add(technique);
            }

            return null;
        }

        protected virtual object EvalFillMode_Solid(ParseTree tree, params object[] paramlist)
        {
            return FillMode.Solid;
        }

        protected virtual object EvalFillMode_WireFrame(ParseTree tree, params object[] paramlist)
        {
            return FillMode.WireFrame;
        }

        protected virtual object EvalFillModes(ParseTree tree, params object[] paramlist)
        {
            return GetValue(tree, TokenType.FillMode_Solid, 0)
                ?? GetValue(tree, TokenType.FillMode_WireFrame, 0);
        }

        protected virtual object EvalCullMode_None(ParseTree tree, params object[] paramlist)
        {
            return CullMode.None;
        }

        protected virtual object EvalCullMode_Cw(ParseTree tree, params object[] paramlist)
        {
            return CullMode.CullClockwiseFace;
        }

        protected virtual object EvalCullMode_Ccw(ParseTree tree, params object[] paramlist)
        {
            return CullMode.CullCounterClockwiseFace;
        }

        protected virtual object EvalCullModes(ParseTree tree, params object[] paramlist)
        {
            return GetValue(tree, TokenType.CullMode_None, 0)
                ?? GetValue(tree, TokenType.CullMode_Cw, 0)
                ?? GetValue(tree, TokenType.CullMode_Ccw, 0);
        }

        protected virtual object EvalColors_None(ParseTree tree, params object[] paramlist)
        {
            return ColorWriteChannels.None;
        }

        protected virtual object EvalColors_Red(ParseTree tree, params object[] paramlist)
        {
            return ColorWriteChannels.Red;
        }

        protected virtual object EvalColors_Green(ParseTree tree, params object[] paramlist)
        {
            return ColorWriteChannels.Green;
        }

        protected virtual object EvalColors_Blue(ParseTree tree, params object[] paramlist)
        {
            return ColorWriteChannels.Blue;
        }

        protected virtual object EvalColors_Alpha(ParseTree tree, params object[] paramlist)
        {
            return ColorWriteChannels.Alpha;
        }

        protected virtual object EvalColors_All(ParseTree tree, params object[] paramlist)
        {
            return ColorWriteChannels.All;
        }

        protected virtual object EvalColors_Boolean(ParseTree tree, params object[] paramlist)
        {
            return ParseTreeTools.ParseBool((string)GetValue(tree, TokenType.Boolean, 0))
                ? ColorWriteChannels.All
                : ColorWriteChannels.None;
        }

        protected virtual object EvalColors(ParseTree tree, params object[] paramlist)
        {
            return GetValue(tree, TokenType.Colors_Red, 0)
                ?? GetValue(tree, TokenType.Colors_Green, 0)
                ?? GetValue(tree, TokenType.Colors_Blue, 0)
                ?? GetValue(tree, TokenType.Colors_Alpha, 0)
                ?? GetValue(tree, TokenType.Colors_None, 0)
                ?? GetValue(tree, TokenType.Colors_All, 0)
                ?? GetValue(tree, TokenType.Colors_Boolean, 0);
        }

        protected virtual object EvalColorsMasks(ParseTree tree, params object[] paramlist)
        {
            return (ColorWriteChannels)(GetValue(tree, TokenType.Colors, 0) ?? 0)
                | (ColorWriteChannels)(GetValue(tree, TokenType.Colors, 1) ?? 0)
                | (ColorWriteChannels)(GetValue(tree, TokenType.Colors, 2) ?? 0)
                | (ColorWriteChannels)(GetValue(tree, TokenType.Colors, 3) ?? 0);
        }

        protected virtual object EvalBlend_Zero(ParseTree tree, params object[] paramlist)
        {
            return Blend.Zero;
        }

        protected virtual object EvalBlend_One(ParseTree tree, params object[] paramlist)
        {
            return Blend.One;
        }

        protected virtual object EvalBlend_SrcColor(ParseTree tree, params object[] paramlist)
        {
            return Blend.SourceColor;
        }

        protected virtual object EvalBlend_InvSrcColor(ParseTree tree, params object[] paramlist)
        {
            return Blend.InverseSourceColor;
        }

        protected virtual object EvalBlend_SrcAlpha(ParseTree tree, params object[] paramlist)
        {
            return Blend.SourceAlpha;
        }

        protected virtual object EvalBlend_InvSrcAlpha(ParseTree tree, params object[] paramlist)
        {
            return Blend.InverseSourceAlpha;
        }

        protected virtual object EvalBlend_DestAlpha(ParseTree tree, params object[] paramlist)
        {
            return Blend.DestinationAlpha;
        }

        protected virtual object EvalBlend_InvDestAlpha(ParseTree tree, params object[] paramlist)
        {
            return Blend.InverseDestinationAlpha;
        }

        protected virtual object EvalBlend_DestColor(ParseTree tree, params object[] paramlist)
        {
            return Blend.DestinationColor;
        }

        protected virtual object EvalBlend_InvDestColor(ParseTree tree, params object[] paramlist)
        {
            return Blend.InverseDestinationColor;
        }

        protected virtual object EvalBlend_SrcAlphaSat(ParseTree tree, params object[] paramlist)
        {
            return Blend.SourceAlphaSaturation;
        }

        protected virtual object EvalBlend_BlendFactor(ParseTree tree, params object[] paramlist)
        {
            return Blend.BlendFactor;
        }

        protected virtual object EvalBlend_InvBlendFactor(ParseTree tree, params object[] paramlist)
        {
            return Blend.InverseBlendFactor;
        }

        protected virtual object EvalBlends(ParseTree tree, params object[] paramlist)
        {
            return GetValue(tree, TokenType.Blend_Zero, 0)
                ?? GetValue(tree, TokenType.Blend_One, 0)
                ?? GetValue(tree, TokenType.Blend_SrcColor, 0)
                ?? GetValue(tree, TokenType.Blend_InvSrcColor, 0)
                ?? GetValue(tree, TokenType.Blend_SrcAlpha, 0)
                ?? GetValue(tree, TokenType.Blend_InvSrcAlpha, 0)
                ?? GetValue(tree, TokenType.Blend_DestAlpha, 0)
                ?? GetValue(tree, TokenType.Blend_InvDestAlpha, 0)
                ?? GetValue(tree, TokenType.Blend_DestColor, 0)
                ?? GetValue(tree, TokenType.Blend_InvDestColor, 0)
                ?? GetValue(tree, TokenType.Blend_SrcAlphaSat, 0)
                ?? GetValue(tree, TokenType.Blend_BlendFactor, 0)
                ?? GetValue(tree, TokenType.Blend_InvBlendFactor, 0);
        }

        protected virtual object EvalBlendOp_Add(ParseTree tree, params object[] paramlist)
        {
            return BlendFunction.Add;
        }

        protected virtual object EvalBlendOp_Subtract(ParseTree tree, params object[] paramlist)
        {
            return BlendFunction.Subtract;
        }

        protected virtual object EvalBlendOp_RevSubtract(ParseTree tree, params object[] paramlist)
        {
            return BlendFunction.ReverseSubtract;
        }

        protected virtual object EvalBlendOp_Min(ParseTree tree, params object[] paramlist)
        {
            return BlendFunction.Min;
        }

        protected virtual object EvalBlendOp_Max(ParseTree tree, params object[] paramlist)
        {
            return BlendFunction.Max;
        }

        protected virtual object EvalBlendOps(ParseTree tree, params object[] paramlist)
        {
            return GetValue(tree, TokenType.BlendOp_Add, 0)
                ?? GetValue(tree, TokenType.BlendOp_Subtract, 0)
                ?? GetValue(tree, TokenType.BlendOp_RevSubtract, 0)
                ?? GetValue(tree, TokenType.BlendOp_Min, 0)
                ?? GetValue(tree, TokenType.BlendOp_Max, 0);
        }

        protected virtual object EvalCmpFunc_Never(ParseTree tree, params object[] paramlist)
        {
            return CompareFunction.Never;
        }

        protected virtual object EvalCmpFunc_Less(ParseTree tree, params object[] paramlist)
        {
            return CompareFunction.Less;
        }

        protected virtual object EvalCmpFunc_Equal(ParseTree tree, params object[] paramlist)
        {
            return CompareFunction.Equal;
        }

        protected virtual object EvalCmpFunc_LessEqual(ParseTree tree, params object[] paramlist)
        {
            return CompareFunction.LessEqual;
        }

        protected virtual object EvalCmpFunc_Greater(ParseTree tree, params object[] paramlist)
        {
            return CompareFunction.Greater;
        }

        protected virtual object EvalCmpFunc_NotEqual(ParseTree tree, params object[] paramlist)
        {
            return CompareFunction.NotEqual;
        }

        protected virtual object EvalCmpFunc_GreaterEqual(ParseTree tree, params object[] paramlist)
        {
            return CompareFunction.GreaterEqual;
        }

        protected virtual object EvalCmpFunc_Always(ParseTree tree, params object[] paramlist)
        {
            return CompareFunction.Always;
        }

        protected virtual object EvalCmpFunc(ParseTree tree, params object[] paramlist)
        {
            return GetValue(tree, TokenType.CmpFunc_Never, 0)
                ?? GetValue(tree, TokenType.CmpFunc_Less, 0)
                ?? GetValue(tree, TokenType.CmpFunc_Equal, 0)
                ?? GetValue(tree, TokenType.CmpFunc_LessEqual, 0)
                ?? GetValue(tree, TokenType.CmpFunc_Greater, 0)
                ?? GetValue(tree, TokenType.CmpFunc_NotEqual, 0)
                ?? GetValue(tree, TokenType.CmpFunc_GreaterEqual, 0)
                ?? GetValue(tree, TokenType.CmpFunc_Always, 0);
        }

        protected virtual object EvalStencilOp_Keep(ParseTree tree, params object[] paramlist)
        {
            return StencilOperation.Keep;
        }

        protected virtual object EvalStencilOp_Zero(ParseTree tree, params object[] paramlist)
        {
            return StencilOperation.Zero;
        }

        protected virtual object EvalStencilOp_Replace(ParseTree tree, params object[] paramlist)
        {
            return StencilOperation.Replace;
        }

        protected virtual object EvalStencilOp_IncrSat(ParseTree tree, params object[] paramlist)
        {
            return StencilOperation.IncrementSaturation;
        }

        protected virtual object EvalStencilOp_DecrSat(ParseTree tree, params object[] paramlist)
        {
            return StencilOperation.DecrementSaturation;
        }

        protected virtual object EvalStencilOp_Invert(ParseTree tree, params object[] paramlist)
        {
            return StencilOperation.Invert;
        }

        protected virtual object EvalStencilOp_Incr(ParseTree tree, params object[] paramlist)
        {
            return StencilOperation.Increment;
        }

        protected virtual object EvalStencilOp_Decr(ParseTree tree, params object[] paramlist)
        {
            return StencilOperation.Decrement;
        }

        protected virtual object EvalStencilOp(ParseTree tree, params object[] paramlist)
        {
            return GetValue(tree, TokenType.StencilOp_Keep, 0)
                ?? GetValue(tree, TokenType.StencilOp_Zero, 0)
                ?? GetValue(tree, TokenType.StencilOp_Replace, 0)
                ?? GetValue(tree, TokenType.StencilOp_IncrSat, 0)
                ?? GetValue(tree, TokenType.StencilOp_DecrSat, 0)
                ?? GetValue(tree, TokenType.StencilOp_Invert, 0)
                ?? GetValue(tree, TokenType.StencilOp_Incr, 0)
                ?? GetValue(tree, TokenType.StencilOp_Decr, 0);
        }

        protected virtual object EvalRender_State_CullMode(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).CullMode = (CullMode)GetValue(tree, TokenType.CullModes, 0);
            return null;
        }

        protected virtual object EvalRender_State_FillMode(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).FillMode = (FillMode)GetValue(tree, TokenType.FillModes, 0);
            return null;
        }

        protected virtual object EvalRender_State_AlphaBlendEnable(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).AlphaBlendEnable = ParseTreeTools.ParseBool(
                (string)GetValue(tree, TokenType.Boolean, 0));
            return null;
        }

        protected virtual object EvalRender_State_SrcBlend(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).SrcBlend = (Blend)GetValue(tree, TokenType.Blends, 0);
            return null;
        }

        protected virtual object EvalRender_State_DestBlend(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).DestBlend = (Blend)GetValue(tree, TokenType.Blends, 0);
            return null;
        }

        protected virtual object EvalRender_State_BlendOp(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).BlendOp = (BlendFunction)GetValue(tree, TokenType.BlendOps, 0);
            return null;
        }

        protected virtual object EvalRender_State_ColorWriteEnable(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).ColorWriteEnable = (ColorWriteChannels)GetValue(tree, TokenType.ColorsMasks, 0);
            return null;
        }

        protected virtual object EvalRender_State_DepthBias(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).DepthBias = ParseTreeTools.ParseFloat(
                (string)GetValue(tree, TokenType.Number, 0));
            return null;
        }

        protected virtual object EvalRender_State_SlopeScaleDepthBias(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).SlopeScaleDepthBias = ParseTreeTools.ParseFloat(
                (string)GetValue(tree, TokenType.Number, 0));
            return null;
        }

        protected virtual object EvalRender_State_ZEnable(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).ZEnable = ParseTreeTools.ParseBool(
                (string)GetValue(tree, TokenType.Boolean, 0));
            return null;
        }

        protected virtual object EvalRender_State_ZWriteEnable(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).ZWriteEnable = ParseTreeTools.ParseBool(
                (string)GetValue(tree, TokenType.Boolean, 0));
            return null;
        }

        protected virtual object EvalRender_State_ZFunc(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).DepthBufferFunction = (CompareFunction)GetValue(tree, TokenType.CmpFunc, 0);
            return null;
        }

        protected virtual object EvalRender_State_MultiSampleAntiAlias(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).MultiSampleAntiAlias = ParseTreeTools.ParseBool(
                (string)GetValue(tree, TokenType.Boolean, 0));
            return null;
        }

        protected virtual object EvalRender_State_ScissorTestEnable(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).ScissorTestEnable = ParseTreeTools.ParseBool(
                (string)GetValue(tree, TokenType.Boolean, 0));
            return null;
        }

        protected virtual object EvalRender_State_StencilEnable(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).StencilEnable = ParseTreeTools.ParseBool(
                (string)GetValue(tree, TokenType.Boolean, 0));
            return null;
        }

        protected virtual object EvalRender_State_StencilFail(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).StencilFail = (StencilOperation)GetValue(tree, TokenType.StencilOp, 0);
            return null;
        }

        protected virtual object EvalRender_State_StencilFunc(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).StencilFunc = (CompareFunction)GetValue(tree, TokenType.CmpFunc, 0);
            return null;
        }

        protected virtual object EvalRender_State_StencilMask(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).StencilMask = ParseTreeTools.ParseInt(
                (string)GetValue(tree, TokenType.Number, 0));
            return null;
        }

        protected virtual object EvalRender_State_StencilPass(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).StencilPass = (StencilOperation)GetValue(tree, TokenType.StencilOp, 0);
            return null;
        }

        protected virtual object EvalRender_State_StencilRef(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).StencilRef = ParseTreeTools.ParseInt(
                (string)GetValue(tree, TokenType.Number, 0));
            return null;
        }

        protected virtual object EvalRender_State_StencilWriteMask(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).StencilWriteMask = ParseTreeTools.ParseInt(
                (string)GetValue(tree, TokenType.Number, 0));
            return null;
        }

        protected virtual object EvalRender_State_StencilZFail(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as PassInfo).StencilZFail = (StencilOperation)GetValue(tree, TokenType.StencilOp, 0);
            return null;
        }

        protected virtual object EvalRender_State_Expression(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalPass_Declaration(ParseTree tree, params object[] paramlist)
        {
            var pass = new PassInfo
            {
                name = GetValue(tree, TokenType.Identifier, 0) as string ?? string.Empty
            };

            foreach (var node in Nodes)
                node.Eval(tree, pass);

            // We need to have a pixel or vertex shader to keep this pass.
            if (!string.IsNullOrEmpty(pass.psFunction) || !string.IsNullOrEmpty(pass.vsFunction))
            {
                var technique = paramlist[0] as TechniqueInfo;
                technique.Passes.Add(pass);
            }

            return null;
        }

        protected virtual object EvalVertexShader_Pass_Expression(ParseTree tree, params object[] paramlist)
        {
            var pass = paramlist[0] as PassInfo;
            pass.vsModel = GetValue(tree, TokenType.ShaderModel, 0) as string;
            pass.vsFunction = GetValue(tree, TokenType.Identifier, 0) as string;
            return null;
        }

        protected virtual object EvalPixelShader_Pass_Expression(ParseTree tree, params object[] paramlist)
        {
            var pass = paramlist[0] as PassInfo;
            pass.psModel = GetValue(tree, TokenType.ShaderModel, 0) as string;
            pass.psFunction = GetValue(tree, TokenType.Identifier, 0) as string;
            return null;
        }

        protected virtual object EvalAddressMode_Clamp(ParseTree tree, params object[] paramlist)
        {
            return TextureAddressMode.Clamp;
        }

        protected virtual object EvalAddressMode_Wrap(ParseTree tree, params object[] paramlist)
        {
            return TextureAddressMode.Wrap;
        }

        protected virtual object EvalAddressMode_Mirror(ParseTree tree, params object[] paramlist)
        {
            return TextureAddressMode.Mirror;
        }

        protected virtual object EvalAddressMode_Border(ParseTree tree, params object[] paramlist)
        {
            return TextureAddressMode.Border;
        }

        protected virtual object EvalAddressMode(ParseTree tree, params object[] paramlist)
        {
            return GetValue(tree, TokenType.AddressMode_Clamp, 0)
                ?? GetValue(tree, TokenType.AddressMode_Wrap, 0)
                ?? GetValue(tree, TokenType.AddressMode_Mirror, 0)
                ?? GetValue(tree, TokenType.AddressMode_Border, 0);
        }

        protected virtual object EvalTextureFilter_None(ParseTree tree, params object[] paramlist)
        {
            return TextureFilterType.None;
        }

        protected virtual object EvalTextureFilter_Linear(ParseTree tree, params object[] paramlist)
        {
            return TextureFilterType.Linear;
        }

        protected virtual object EvalTextureFilter_Point(ParseTree tree, params object[] paramlist)
        {
            return TextureFilterType.Point;
        }

        protected virtual object EvalTextureFilter_Anisotropic(ParseTree tree, params object[] paramlist)
        {
            return TextureFilterType.Anisotropic;
        }

        protected virtual object EvalTextureFilter(ParseTree tree, params object[] paramlist)
        {
            return GetValue(tree, TokenType.TextureFilter_None, 0)
                ?? GetValue(tree, TokenType.TextureFilter_Linear, 0)
                ?? GetValue(tree, TokenType.TextureFilter_Point, 0)
                ?? GetValue(tree, TokenType.TextureFilter_Anisotropic, 0);
        }

        protected virtual object EvalSampler_State_Texture(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).TextureName = (string)GetValue(tree, TokenType.Identifier, 0);
            return null;
        }

        protected virtual object EvalSampler_State_MinFilter(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).MinFilter = (TextureFilterType)GetValue(tree, TokenType.TextureFilter, 0);
            return null;
        }

        protected virtual object EvalSampler_State_MagFilter(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).MagFilter = (TextureFilterType)GetValue(tree, TokenType.TextureFilter, 0);
            return null;
        }

        protected virtual object EvalSampler_State_MipFilter(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).MipFilter = (TextureFilterType)GetValue(tree, TokenType.TextureFilter, 0);
            return null;
        }

        protected virtual object EvalSampler_State_Filter(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).Filter = (TextureFilterType)GetValue(tree, TokenType.TextureFilter, 0);
            return null;
        }

        protected virtual object EvalSampler_State_AddressU(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).AddressU = (TextureAddressMode)GetValue(tree, TokenType.AddressMode, 0);
            return null;
        }

        protected virtual object EvalSampler_State_AddressV(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).AddressV = (TextureAddressMode)GetValue(tree, TokenType.AddressMode, 0);
            return null;
        }

        protected virtual object EvalSampler_State_AddressW(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).AddressW = (TextureAddressMode)GetValue(tree, TokenType.AddressMode, 0);
            return null;
        }

        protected virtual object EvalSampler_State_BorderColor(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).BorderColor = ParseTreeTools.ParseColor(
                (string)GetValue(tree, TokenType.HexColor, 0));
            return null;
        }

        protected virtual object EvalSampler_State_MaxMipLevel(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).MaxMipLevel = ParseTreeTools.ParseInt(
                (string)GetValue(tree, TokenType.Number, 0));
            return null;
        }

        protected virtual object EvalSampler_State_MaxAnisotropy(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).MaxAnisotropy = ParseTreeTools.ParseInt(
                (string)GetValue(tree, TokenType.Number, 0));
            return null;
        }

        protected virtual object EvalSampler_State_MipLodBias(ParseTree tree, params object[] paramlist)
        {
            (paramlist[0] as SamplerStateInfo).MipMapLevelOfDetailBias = ParseTreeTools.ParseFloat(
                (string)GetValue(tree, TokenType.Number, 0));
            return null;
        }

        protected virtual object EvalSampler_State_Expression(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalSampler_Register_Expression(ParseTree tree, params object[] paramlist)
        {
            return null;
        }

        protected virtual object EvalSampler_Declaration_States(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalSampler_Declaration(ParseTree tree, params object[] paramlist)
        {
            // If there's a comma or closing paren at the end this is a sampler as a parameter of a function
            if (GetValue(tree, TokenType.Semicolon, 0) == null) 
                return null;

            var sampler = new SamplerStateInfo
            {
                Name = GetValue(tree, TokenType.Identifier, 0) as string
            };

            foreach (ParseNode node in Nodes)
                node.Eval(tree, sampler);

            var shaderInfo = paramlist[0] as ShaderInfo;
            shaderInfo.SamplerStates.Add(sampler.Name, sampler);

            return null;
        }
    }

    #endregion ParseTree
}
