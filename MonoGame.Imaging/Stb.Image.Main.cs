// Generated by Sichem at 1/6/2018 7:16:35 PM

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MonoGame.Imaging
{
    public enum ImagePixelFormat
    {
        Unknown = 0,
        Grey = 1,
        GreyWithAlpha = 2,
        Rgb = 3,
        RgbWithAlpha = 4
    }

    internal unsafe partial class Imaging
    {
        [StructLayout(LayoutKind.Sequential)]
        public struct ResultInfo
        {
            public int bits_per_channel;
            public int num_channels;
            public int channel_order;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PngChunk
        {
            public uint length;
            public uint type;
        }

        public class PngImage
        {
            public readonly ReadContext _readCtx;
            public byte* idata;
            public byte* expanded;
            public byte* _out_;
            public int depth;

            public PngImage(ReadContext context)
            {
                this._readCtx = context;
            }
        }

        public const int STBI_default = 0;
        public const int STBI_grey = (int)ImagePixelFormat.Grey;
        public const int STBI_grey_alpha = (int)ImagePixelFormat.GreyWithAlpha;
        public const int STBI_rgb = (int)ImagePixelFormat.Rgb;
        public const int STBI_rgb_alpha = (int)ImagePixelFormat.RgbWithAlpha;

        public const int STBI_ORDER_RGB = 0;
        public const int STBI_ORDER_BGR = 1;
        public const int STBI__SCAN_load = 0;
        public const int STBI__SCAN_type = 1;
        public const int STBI__SCAN_header = 2;
        public const int FNone = 0;
        public const int FSub = 1;
        public const int STBI__F_up = 2;
        public const int STBI__F_avg = 3;
        public const int STBI__F_paeth = 4;
        public const int FAvgFirst = 5;
        public const int FPaethFirst = 6;
        public static float stbi__h2l_gamma_i = 1.0f / 2.2f;
        public static float stbi__h2l_scale_i = 1.0f;

        public static uint[] BMask =
        {
            0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535
        };

        public static int[] JBias =
        {
            0, -1, -3, -7, -15, -31, -63, -127, -255, -511, -1023, -2047, -4095, -8191, -16383,
            -32767
        };

        public static byte[] JpgDezigzag =
        {
            0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40,
            48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58,
            59, 52,
            45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
            63
        };

        public static int[] LengthBaseZ =
        {
            3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67,
            83, 99, 115, 131, 163, 195, 227, 258, 0, 0
        };

        public static int[] LengthExtraZ =
        {
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
            5, 5, 5, 0, 0, 0
        };

        public static int[] DistBaseZ =
        {
            1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769,
            1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0
        };

        public static int[] DistExtraZ =
        {
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
            11, 12, 12, 13, 13
        };

        public static byte[] LengthDezigzag = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

        public static byte[] stbi__zdefault_length =
        {
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
            8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
            8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
            8, 8, 8,
            8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
            9, 9, 9,
            9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
            9, 9, 9,
            9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
            9, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8
        };

        public static byte[] DefaultDistanceZ =
        {
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5
        };

        public static byte[] PngSig = { 137, 80, 78, 71, 13, 10, 26, 10 };

        public static byte[] FirstRowFilter =
        {
            FNone, FSub, FNone, FAvgFirst, FPaethFirst
        };

        public static byte[] DepthScaleTable = { 0, 0xff, 0x55, 0, 0x11, 0, 0, 0, 0x01 };
        public static int UnpremultiplyOnLoad = 0;
        public static int DeIPhoneFlag = 0;

        public static ReadContext GetMemoryReadContext(
            MemoryManager manager, ErrorContext errorCtx, byte* buffer, int len)
        {
            ReadContext s = new ReadContext { Manager = manager, ReadFromCallbacks = 0 };
            s.Callbacks.Read = null;
            s.ErrorCtx = errorCtx;
            s.ImgBuffer = s.ImgBufferOrigin = buffer;
            s.ImgBufferEnd = s.ImgBufferEndOrigin = buffer + len;

            return s;
        }

        public static ReadContext GetReadContext(
            MemoryManager manager, ErrorContext errorCtx, in ReadCallbacks c, void* user)
        {
            var s = new ReadContext
            {
                Manager = manager,
                Callbacks = c,
                IOUserData = user,
                ErrorCtx = errorCtx
            };
            s.BufLength = s.BufferStart.Size;
            s.ReadFromCallbacks = 1;
            s.ImgBufferOrigin = s.BufferStart;
            RefillBuffer(s);
            s.ImgBufferEndOrigin = s.ImgBufferEnd;

            return s;
        }

        public static void Rewind(ReadContext s)
        {
            s.ImgBuffer = s.ImgBufferOrigin;
            s.ImgBufferEnd = s.ImgBufferEndOrigin;
        }

        public static int ValidAddSizes(int a, int b)
        {
            if ((b) < 0) return 0;
            return (a <= 2147483647 - b) ? 1 : 0;
        }

        public static int ValidMul_2sizes(int a, int b)
        {
            if (((a) < 0) || ((b) < 0)) return 0;
            if ((b) == 0) return 1;
            return (a <= 2147483647 / b) ? 1 : 0;
        }

        public static int ValidSizes_mad2(int a, int b, int add)
        {
            return

                    ((ValidMul_2sizes(a, b)) != 0) &&
                     ((ValidAddSizes(a * b, add)) != 0)
                        ? 1
                        : 0;
        }

        public static int ValidSizes_mad3(int a, int b, int c, int add)
        {
            return

                    (((ValidMul_2sizes(a, b)) != 0) &&
                      ((ValidMul_2sizes(a * b, c)) != 0)) &&
                     ((ValidAddSizes(a * b * c, add)) != 0)
                        ? 1
                        : 0;
        }

        public static int ValidSizes_mad4(int a, int b, int c, int d, int add)
        {
            return

                    ((((ValidMul_2sizes(a, b)) != 0) &&
                       ((ValidMul_2sizes(a * b, c)) != 0)) &&
                      ((ValidMul_2sizes(a * b * c, d)) != 0)) &&
                     ((ValidAddSizes(a * b * c * d, add)) != 0)
                        ? 1
                        : 0;
        }

        public static void* MAlloc_mad2(MemoryManager manager, int a, int b, int add)
        {
            if (ValidSizes_mad2(a, b, add) == 0)
                return null;

            return manager.MAlloc(a * b + add);
        }

        public static void* MAlloc_mad3(MemoryManager manager, int a, int b, int c, int add)
        {
            if (ValidSizes_mad3(a, b, c, add) == 0)
                return null;

            return manager.MAlloc(a * b * c + add);
        }

        /*
        public static void* MAlloc_mad4(int a, int b, int c, int d, int add)
        {
            if (ValidSizes_mad4(a, b, c, d, add) == 0) return null;
            return MAlloc((ulong)(a * b * c * d + add));
        }
        */

        public static void SetFlipVerticallyOnLoad(int flag_true_if_should_flip)
        {
            _verticallyFlipOnLoad = flag_true_if_should_flip;
        }

        public static void* LoadMain(
            ReadContext s, int* x, int* y, int* comp, int req_comp, ResultInfo* ri, int bpc)
        {
            ri->bits_per_channel = 8;
            ri->channel_order = STBI_ORDER_RGB;
            ri->num_channels = 0;

            if ((TestForPng(s)) != 0) return LoadPng(s, x, y, comp, req_comp, ri);
            if ((TestForJpg(s)) != 0) return LoadJpg(s, x, y, comp, req_comp, ri);
            if ((TestForBmp(s)) != 0) return LoadBmp(s, x, y, comp, req_comp, ri);
            if ((TestForTga(s)) != 0) return LoadTga(s, x, y, comp, req_comp, ri);
            if ((TestForGif(s)) != 0) return LoadGif(s, x, y, comp, req_comp, ri);
            return (s.Error("unknown image type")) != 0 ? (byte*)null : null;
        }

        public static ImageInfo GetImageInfo(ReadContext s)
        {
            int width;
            int height;
            int comp;
            var imageFormat = GetImageFormat(s, &width, &height, &comp);
            int pixelFormat = (comp >= 1 && comp <= 4) ? comp : 0;
            
            return new ImageInfo(width, height, (ImagePixelFormat)pixelFormat, imageFormat);
        }

        public static ImageFormat GetImageFormat(
            ReadContext s, int* width, int* height, int* comp)
        {
            if ((TestForPng(s)) != 0)
                if (GetPngInfo(s, width, height, comp) == 1)
                    return ImageFormat.Png;

            if ((TestForJpg(s)) != 0)
                if (GetJpgInfo(s, width, height, comp) == 1)
                    return ImageFormat.Jpg;

            if ((TestForBmp(s)) != 0)
                if (GetBmpInfo(s, width, height, comp) == 1)
                    return ImageFormat.Bmp;

            if ((TestForTga(s)) != 0)
                if (GetTgaInfo(s, width, height, comp) == 1)
                    return ImageFormat.Tga;

            if ((TestForGif(s)) != 0)
                if (GetGifInfo(s, width, height, comp) == 1)
                    return ImageFormat.Gif;

            return ImageFormat.Unknown;
        }

        public static byte* Convert16To8(
            MemoryManager mm, ErrorContext ec, ushort* orig, int w, int h, int channels)
        {
            int i;
            int img_len = w * h * channels;
            byte* reduced;
            reduced = (byte*)(mm.MAlloc(img_len));
            if ((reduced) == null)
                return (ec.Error("outofmem")) != 0 ? (byte*)null : null;
            for (i = 0; (i) < (img_len); ++i)
            {
                reduced[i] = ((byte)((orig[i] >> 8) & 0xFF));
            }
            mm.Free(orig);
            return reduced;
        }

        public static ushort* Convert8To16(
            MemoryManager mm, ErrorContext ec, byte* orig, int w, int h, int channels)
        {
            int i;
            int img_len = w * h * channels;
            ushort* enlarged;
            enlarged = (ushort*)(mm.MAlloc(img_len * 2));
            if ((enlarged) == null)
                return (ushort*)((ec.Error("outofmem")) != 0 ? (byte*)null : null);
            for (i = 0; (i) < (img_len); ++i)
            {
                enlarged[i] = ((ushort)((orig[i] << 8) + orig[i]));
            }
            mm.Free(orig);
            return enlarged;
        }

        public static void VerticalFlip(MemoryManager manager, void* image, int w, int h, int bytes_per_pixel)
        {
            int row;
            long bytes_per_row = w * bytes_per_pixel;
            byte* temp = stackalloc byte[2048];
            byte* bytes = (byte*)(image);
            for (row = 0; (row) < (h >> 1); row++)
            {
                byte* row0 = bytes + row * bytes_per_row;
                byte* row1 = bytes + (h - row - 1) * bytes_per_row;
                long bytes_left = bytes_per_row;
                while ((bytes_left) != 0)
                {
                    long bytes_copy = ((bytes_left) < (2048)) ? bytes_left : 2048;
                    MemCopy(temp, row0, bytes_copy);
                    MemCopy(row0, row1, bytes_copy);
                    MemCopy(row1, temp, bytes_copy);
                    row0 += bytes_copy;
                    row1 += bytes_copy;
                    bytes_left -= bytes_copy;
                }
            }
        }

        public static byte* LoadAndPostprocess8(ReadContext s, int* x, int* y, int* comp, int req_comp)
        {
            ResultInfo ri = new ResultInfo();
            void* result = LoadMain(s, x, y, comp, req_comp, &ri, 8);
            if (result == null)
                return null;

            if (ri.bits_per_channel != 8)
            {
                result = Convert16To8(s.Manager, s.ErrorCtx, (ushort*)(result), *x, *y,
                    (req_comp) == 0 ? *comp : req_comp);
                ri.bits_per_channel = 8;
            }

            if ((_verticallyFlipOnLoad) != 0)
            {
                int channels = (req_comp) != 0 ? req_comp : *comp;
                VerticalFlip(s.Manager, result, *x, *y, channels);
            }

            return (byte*)(result);
        }

        public static ushort* LoadAndPostprocess16(ReadContext s, int* x, int* y, int* comp, int req_comp)
        {
            ResultInfo ri = new ResultInfo();
            void* result = LoadMain(s, x, y, comp, req_comp, &ri, 16);

            if ((result) == null) return null;
            if (ri.bits_per_channel != 16)
            {
                result = Convert8To16(s.Manager, s.ErrorCtx, (byte*)(result), *x, *y,
                    (req_comp) == 0 ? *comp : req_comp);
                ri.bits_per_channel = 16;
            }

            if ((_verticallyFlipOnLoad) != 0)
            {
                int channels = (req_comp) != 0 ? req_comp : *comp;
                VerticalFlip(s.Manager, result, *x, *y, channels * 2);
            }

            return (ushort*)result;
        }

        public static ushort* Load16FromMemory(MemoryManager manager, ErrorContext errorContext,
            byte* buffer, int len, int* x, int* y, int* channels, int desiredChannels)
        {
            ReadContext s = GetMemoryReadContext(manager, errorContext, buffer, len);
            return LoadAndPostprocess16(s, x, y, channels, desiredChannels);
        }

        public static ushort* Load16FromCallbacks(MemoryManager manager, ErrorContext errorContext,
            in ReadCallbacks clbk, void* user, int* x, int* y, int* channelsInFile, int desiredChannels)
        {
            ReadContext s = GetReadContext(manager, errorContext, clbk, user);
            return LoadAndPostprocess16(s, x, y, channelsInFile, desiredChannels);
        }

        public static byte* LoadFromMemory(MemoryManager manager, ErrorContext errorContext,
            byte* buffer, int len, int* x, int* y, int* channels, int desiredChannels)
        {
            ReadContext s = GetMemoryReadContext(manager, errorContext, buffer, len);
            return LoadAndPostprocess8(s, x, y, channels, desiredChannels);
        }

        public static byte* Load8FromCallbacks(MemoryManager manager, ErrorContext errorContext,
            in ReadCallbacks clbk,  void* user, int* x, int* y, int* channelsInFile, int desiredChannels)
        {
            ReadContext s = GetReadContext(manager, errorContext, clbk, user);
            return LoadAndPostprocess8(s, x, y, channelsInFile, desiredChannels);
        }

        public static void HdrToLdrGamma(float gamma)
        {
            stbi__h2l_gamma_i = 1f / gamma;
        }

        public static void HdrToLdrScale(float scale)
        {
            stbi__h2l_scale_i = 1f / scale;
        }

        public static void RefillBuffer(ReadContext s)
        {
            int n = s.Callbacks.Read(s.IOUserData, s.BufferStart, s.BufLength);
            if ((n) == 0)
            {
                s.ReadFromCallbacks = 0;
                s.ImgBuffer = s.BufferStart;
                s.ImgBufferEnd = s.BufferStart;
                s.ImgBufferEnd++;
                *s.ImgBuffer = 0;
            }
            else
            {
                s.ImgBuffer = s.BufferStart;
                s.ImgBufferEnd = s.BufferStart;
                s.ImgBufferEnd += n;
            }

        }

        public static byte GetByte(ReadContext s)
        {
            if ((s.ImgBuffer) < (s.ImgBufferEnd))
                return *s.ImgBuffer++;

            if ((s.ReadFromCallbacks) != 0)
            {
                RefillBuffer(s);
                return *s.ImgBuffer++;
            }

            return 0;
        }

        public static int AtEoF(ReadContext s)
        {
            if ((s.Callbacks.Read) != null)
            {
                if (s.Callbacks.EoF(s.IOUserData) == 0)
                    return 0;
                if ((s.ReadFromCallbacks) == 0)
                    return 1;
            }

            return (s.ImgBuffer) >= (s.ImgBufferEnd) ? 1 : 0;
        }

        public static void Skip(ReadContext s, int n)
        {
            if ((n) < 0)
            {
                s.ImgBuffer = s.ImgBufferEnd;
                return;
            }

            if ((s.Callbacks.Read) != null)
            {
                int blen = (int)(s.ImgBufferEnd - s.ImgBuffer);
                if ((blen) < (n))
                {
                    s.ImgBuffer = s.ImgBufferEnd;

                    int skipCount = n - blen;
                    byte* skipBuffer = (byte*)s.Manager.MAlloc(skipCount);
                    s.Callbacks.Read(s.IOUserData, skipBuffer, skipCount);
                    s.Manager.Free(skipBuffer);
                    return;
                }
            }

            s.ImgBuffer += n;
        }

        public static int GetN(ReadContext s, byte* buffer, int n)
        {
            if ((s.Callbacks.Read) != null)
            {
                int blen = (int)(s.ImgBufferEnd - s.ImgBuffer);
                if ((blen) < (n))
                {
                    int res;
                    int count;
                    MemCopy(buffer, s.ImgBuffer, blen);
                    count = s.Callbacks.Read(s.IOUserData, buffer + blen, n - blen);
                    res = (count) == (n - blen) ? 1 : 0;
                    s.ImgBuffer = s.ImgBufferEnd;
                    return res;
                }
            }

            if (s.ImgBuffer + n <= s.ImgBufferEnd)
            {
                MemCopy(buffer, s.ImgBuffer, n);
                s.ImgBuffer += n;
                return 1;
            }
            else return 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Get16be(ReadContext s)
        {
            int z = GetByte(s);
            return (z << 8) + GetByte(s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Get32be(ReadContext s)
        {
            uint z = (uint)(Get16be(s));
            return (uint)((z << 16) + Get16be(s));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Get16le(ReadContext s)
        {
            int z = GetByte(s);
            return z + (GetByte(s) << 8);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Get32le(ReadContext s)
        {
            uint z = (uint)(Get16le(s));
            return (uint)(z + (Get16le(s) << 16));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte ComputeY(int r, int g, int b)
        {
            return (byte)(((r * 77) + (g * 150) + (29 * b)) >> 8);
        }

        public static byte* ConvertToFormat8(
            MemoryManager mm, ErrorContext ec, byte* data, int img_n, int req_comp, uint x, uint y)
        {
            int i;
            int j;
            byte* good;
            if ((req_comp) == (img_n)) return data;
            good = (byte*)(MAlloc_mad3(mm, req_comp, (int)(x), (int)(y), 0));
            if ((good) == null)
            {
                mm.Free(data);
                return (ec.Error("outofmem")) != 0 ? (byte*)null : null;
            }

            for (j = 0; (j) < ((int)(y)); ++j)
            {
                byte* src = data + j * x * img_n;
                byte* dest = good + j * x * req_comp;
                switch (((img_n) * 8 + (req_comp)))
                {
                    case (1 * 8 + 2):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 1, dest += 2)
                        {
                            dest[0] = src[0];
                            dest[1] = 255;
                        }
                        break;
                    case (1 * 8 + 3):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 1, dest += 3)
                        {
                            dest[0] = dest[1] = dest[2] = src[0];
                        }
                        break;
                    case (1 * 8 + 4):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 1, dest += 4)
                        {
                            dest[0] = dest[1] = dest[2] = src[0];
                            dest[3] = 255;
                        }
                        break;
                    case (2 * 8 + 1):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 2, dest += 1)
                        {
                            dest[0] = src[0];
                        }
                        break;
                    case (2 * 8 + 3):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 2, dest += 3)
                        {
                            dest[0] = dest[1] = dest[2] = src[0];
                        }
                        break;
                    case (2 * 8 + 4):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 2, dest += 4)
                        {
                            dest[0] = dest[1] = dest[2] = src[0];
                            dest[3] = src[1];
                        }
                        break;
                    case (3 * 8 + 4):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 3, dest += 4)
                        {
                            dest[0] = src[0];
                            dest[1] = src[1];
                            dest[2] = src[2];
                            dest[3] = 255;
                        }
                        break;
                    case (3 * 8 + 1):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 3, dest += 1)
                        {
                            dest[0] = ComputeY(src[0], src[1], src[2]);
                        }
                        break;
                    case (3 * 8 + 2):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 3, dest += 2)
                        {
                            dest[0] = ComputeY(src[0], src[1], src[2]);
                            dest[1] = 255;
                        }
                        break;
                    case (4 * 8 + 1):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 4, dest += 1)
                        {
                            dest[0] = ComputeY(src[0], src[1], src[2]);
                        }
                        break;
                    case (4 * 8 + 2):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 4, dest += 2)
                        {
                            dest[0] = ComputeY(src[0], src[1], src[2]);
                            dest[1] = src[3];
                        }
                        break;
                    case (4 * 8 + 3):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 4, dest += 3)
                        {
                            dest[0] = src[0];
                            dest[1] = src[1];
                            dest[2] = src[2];
                        }
                        break;
                    default:
                        return (ec.Error("0")) != 0 ? (byte*)null : null;
                }
            }
            mm.Free(data);
            return good;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort ComputeY16(int r, int g, int b)
        {
            return (ushort)(((r * 77) + (g * 150) + (29 * b)) >> 8);
        }

        public static ushort* ConvertToFormat16(
            MemoryManager mm, ErrorContext ec, ushort* data, int img_n, int req_comp, uint x, uint y)
        {
            int i;
            int j;
            ushort* good;
            if ((req_comp) == (img_n)) return data;
            good = (ushort*)(mm.MAlloc(req_comp * x * y * 2));
            if ((good) == null)
            {
                mm.Free(data);
                return (ushort*)((ec.Error("outofmem")) != 0 ? (byte*)null : null);
            }

            for (j = 0; (j) < ((int)(y)); ++j)
            {
                ushort* src = data + j * x * img_n;
                ushort* dest = good + j * x * req_comp;
                switch (((img_n) * 8 + (req_comp)))
                {
                    case (1 * 8 + 2):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 1, dest += 2)
                        {
                            dest[0] = src[0];
                            dest[1] = 0xffff;
                        }
                        break;
                    case (1 * 8 + 3):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 1, dest += 3)
                        {
                            dest[0] = dest[1] = dest[2] = src[0];
                        }
                        break;
                    case (1 * 8 + 4):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 1, dest += 4)
                        {
                            dest[0] = dest[1] = dest[2] = src[0];
                            dest[3] = 0xffff;
                        }
                        break;
                    case (2 * 8 + 1):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 2, dest += 1)
                        {
                            dest[0] = src[0];
                        }
                        break;
                    case (2 * 8 + 3):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 2, dest += 3)
                        {
                            dest[0] = dest[1] = dest[2] = src[0];
                        }
                        break;
                    case (2 * 8 + 4):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 2, dest += 4)
                        {
                            dest[0] = dest[1] = dest[2] = src[0];
                            dest[3] = src[1];
                        }
                        break;
                    case (3 * 8 + 4):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 3, dest += 4)
                        {
                            dest[0] = src[0];
                            dest[1] = src[1];
                            dest[2] = src[2];
                            dest[3] = 0xffff;
                        }
                        break;
                    case (3 * 8 + 1):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 3, dest += 1)
                        {
                            dest[0] = ComputeY16(src[0], src[1], src[2]);
                        }
                        break;
                    case (3 * 8 + 2):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 3, dest += 2)
                        {
                            dest[0] = ComputeY16(src[0], src[1], src[2]);
                            dest[1] = 0xffff;
                        }
                        break;
                    case (4 * 8 + 1):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 4, dest += 1)
                        {
                            dest[0] = ComputeY16(src[0], src[1], src[2]);
                        }
                        break;
                    case (4 * 8 + 2):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 4, dest += 2)
                        {
                            dest[0] = ComputeY16(src[0], src[1], src[2]);
                            dest[1] = src[3];
                        }
                        break;
                    case (4 * 8 + 3):
                        for (i = (int)(x - 1); (i) >= 0; --i, src += 4, dest += 3)
                        {
                            dest[0] = src[0];
                            dest[1] = src[1];
                            dest[2] = src[2];
                        }
                        break;
                    default:
                        return (ushort*)((ec.Error("0")) != 0 ? (byte*)null : null);
                }
            }
            mm.Free(data);
            return good;
        }

        public static int BuildHuffman(ErrorContext ec, Huffman* h, int* count)
        {
            int i;
            int j;
            int k = 0;
            int code;
            for (i = 0; (i) < (16); ++i)
            {
                for (j = 0; (j) < (count[i]); ++j)
                {
                    h->size[k++] = ((byte)(i + 1));
                }
            }
            h->size[k] = 0;
            code = 0;
            k = 0;
            for (j = 1; j <= 16; ++j)
            {
                h->delta[j] = k - code;
                if ((h->size[k]) == (j))
                {
                    while ((h->size[k]) == (j))
                    {
                        h->code[k++] = ((ushort)(code++));
                    }
                    if ((code - 1) >= (1 << j)) return ec.Error("bad code lengths");
                }
                h->maxcode[j] = (uint)(code << (16 - j));
                code <<= 1;
            }
            h->maxcode[j] = 0xffffffff;
            MemSet(h->fast, 255, 1 << 9);
            for (i = 0; (i) < (k); ++i)
            {
                int s = h->size[i];
                if (s <= 9)
                {
                    int c = h->code[i] << (9 - s);
                    int m = 1 << (9 - s);
                    for (j = 0; (j) < (m); ++j)
                    {
                        h->fast[c + j] = ((byte)(i));
                    }
                }
            }
            return 1;
        }

        public static void BuildFastAc(short* fast_ac, Huffman* h)
        {
            int i;
            for (i = 0; (i) < (1 << 9); ++i)
            {
                byte fast = h->fast[i];
                fast_ac[i] = 0;
                if ((fast) < (255))
                {
                    int rs = h->values[fast];
                    int run = (rs >> 4) & 15;
                    int magbits = rs & 15;
                    int len = h->size[fast];
                    if (((magbits) != 0) && (len + magbits <= 9))
                    {
                        int k = ((i << len) & ((1 << 9) - 1)) >> (9 - magbits);
                        int m = 1 << (magbits - 1);
                        if ((k) < (m)) k += (int)((~0U << magbits) + 1);
                        if (((k) >= (-128)) && (k <= 127))
                            fast_ac[i] = ((short)((k << 8) + (run << 4) + (len + magbits)));
                    }
                }
            }
        }

        public static void GrowBufferUnsafe(JpgImage j)
        {
            do
            {
                int b = (j._noMore) != 0 ? 0 : GetByte(j._readCtx);
                if ((b) == (0xff))
                {
                    int c = GetByte(j._readCtx);
                    while ((c) == (0xff))
                    {
                        c = GetByte(j._readCtx);
                    }
                    if (c != 0)
                    {
                        j._marker = ((byte)(c));
                        j._noMore = 1;
                        return;
                    }
                }
                j._codeBuffer |= (uint)(b << (24 - j._codeBits));
                j._codeBits += 8;
            } while (j._codeBits <= 24);
        }

        public static int HuffDecodeJpg(JpgImage j, Huffman* h)
        {
            uint temp;
            int c;
            int k;
            if ((j._codeBits) < (16)) GrowBufferUnsafe(j);
            c = (int)((j._codeBuffer >> (32 - 9)) & ((1 << 9) - 1));
            k = h->fast[c];
            if ((k) < (255))
            {
                int s = h->size[k];
                if ((s) > (j._codeBits)) return -1;
                j._codeBuffer <<= s;
                j._codeBits -= s;
                return h->values[k];
            }

            temp = j._codeBuffer >> 16;
            for (k = 9 + 1; ; ++k)
            {
                if ((temp) < (h->maxcode[k])) break;
            }
            if ((k) == (17))
            {
                j._codeBits -= 16;
                return -1;
            }

            if ((k) > (j._codeBits)) return -1;
            c = (int)(((j._codeBuffer >> (32 - k)) & BMask[k]) + h->delta[k]);
            j._codeBits -= k;
            j._codeBuffer <<= k;
            return h->values[c];
        }

        public static int ExtendReceive(JpgImage j, int n)
        {
            uint k;
            int sgn;
            if ((j._codeBits) < (n))
                GrowBufferUnsafe(j);

            sgn = (int)j._codeBuffer >> 31;
            k = Rot32(j._codeBuffer, n);
            j._codeBuffer = k & ~BMask[n];
            k &= BMask[n];
            j._codeBits -= n;

            return (int)(k + (JBias[n] & ~sgn));
        }

        public static int GetJpgBits(JpgImage j, int n)
        {
            uint k;
            if ((j._codeBits) < (n)) GrowBufferUnsafe(j);
            k = Rot32(j._codeBuffer, n);
            j._codeBuffer = k & ~BMask[n];
            k &= BMask[n];
            j._codeBits -= n;
            return (int)(k);
        }

        public static int GetJpgBit(JpgImage j)
        {
            uint k;
            if ((j._codeBits) < 1) GrowBufferUnsafe(j);
            k = j._codeBuffer;
            j._codeBuffer <<= 1;
            --j._codeBits;
            return (int)(k & 0x80000000);
        }

        public static int DecodeJpgBlock(JpgImage j, short* data,
            Huffman* hdc, Huffman* hac, short* fac, int b, ushort* dequant)
        {
            int diff;
            int dc;
            int k;
            int t;
            if ((j._codeBits) < (16)) GrowBufferUnsafe(j);
            t = HuffDecodeJpg(j, hdc);
            if ((t) < 0)
                return j._readCtx.Error("bad huffman code");
            MemSet(data, 0, 64 * sizeof(short));
            diff = (t) != 0 ? ExtendReceive(j, t) : 0;
            dc = j.JpgImgComp[b].dc_pred + diff;
            j.JpgImgComp[b].dc_pred = dc;
            data[0] = ((short)(dc * dequant[0]));
            k = 1;
            do
            {
                uint zig;
                int c;
                int r;
                int s;
                if ((j._codeBits) < (16)) GrowBufferUnsafe(j);
                c = (int)((j._codeBuffer >> (32 - 9)) & ((1 << 9) - 1));
                r = fac[c];
                if ((r) != 0)
                {
                    k += (r >> 4) & 15;
                    s = r & 15;
                    j._codeBuffer <<= s;
                    j._codeBits -= s;
                    zig = JpgDezigzag[k++];
                    data[zig] = ((short)((r >> 8) * dequant[zig]));
                }
                else
                {
                    int rs = HuffDecodeJpg(j, hac);
                    if ((rs) < 0)
                        return j._readCtx.Error("bad huffman code");
                    s = rs & 15;
                    r = rs >> 4;
                    if ((s) == 0)
                    {
                        if (rs != 0xf0) break;
                        k += 16;
                    }
                    else
                    {
                        k += r;
                        zig = JpgDezigzag[k++];
                        data[zig] = ((short)(ExtendReceive(j, s) * dequant[zig]));
                    }
                }
            } while ((k) < (64));
            return 1;
        }

        public static int DecodeJpgBlock_ProgDc(JpgImage j, short* data, Huffman* hdc, int b)
        {
            int diff;
            int dc;
            int t;
            if (j.spec_end != 0)
                return j._readCtx.Error("can't merge dc and ac");
            if ((j._codeBits) < (16)) GrowBufferUnsafe(j);
            if ((j.succ_high) == 0)
            {
                MemSet(data, 0, 64 * sizeof(short));
                t = HuffDecodeJpg(j, hdc);
                diff = (t) != 0 ? ExtendReceive(j, t) : 0;
                dc = j.JpgImgComp[b].dc_pred + diff;
                j.JpgImgComp[b].dc_pred = dc;
                data[0] = ((short)(dc << j.succ_low));
            }
            else
            {
                if ((GetJpgBit(j)) != 0) data[0] += ((short)(1 << j.succ_low));
            }

            return 1;
        }

        public static int DecodeJpgBlock_ProgAc(JpgImage j, short* data, Huffman* hac, short* fac)
        {
            int k;
            if ((j.spec_start) == 0)
                return j._readCtx.Error("can't merge dc and ac");

            if ((j.succ_high) == 0)
            {
                int shift = j.succ_low;
                if ((j.eob_run) != 0)
                {
                    --j.eob_run;
                    return 1;
                }
                k = j.spec_start;
                do
                {
                    uint zig;
                    int c;
                    int r;
                    int s;
                    if ((j._codeBits) < (16)) GrowBufferUnsafe(j);
                    c = (int)((j._codeBuffer >> (32 - 9)) & ((1 << 9) - 1));
                    r = fac[c];
                    if ((r) != 0)
                    {
                        k += (r >> 4) & 15;
                        s = r & 15;
                        j._codeBuffer <<= s;
                        j._codeBits -= s;
                        zig = JpgDezigzag[k++];
                        data[zig] = ((short)((r >> 8) << shift));
                    }
                    else
                    {
                        int rs = HuffDecodeJpg(j, hac);
                        if ((rs) < 0)
                            return j._readCtx.Error("bad huffman code");
                        s = rs & 15;
                        r = rs >> 4;
                        if ((s) == 0)
                        {
                            if ((r) < (15))
                            {
                                j.eob_run = 1 << r;
                                if ((r) != 0) j.eob_run += GetJpgBits(j, r);
                                --j.eob_run;
                                break;
                            }
                            k += 16;
                        }
                        else
                        {
                            k += r;
                            zig = JpgDezigzag[k++];
                            data[zig] = ((short)(ExtendReceive(j, s) << shift));
                        }
                    }
                } while (k <= j.spec_end);
            }
            else
            {
                short bit = (short)(1 << j.succ_low);
                if ((j.eob_run) != 0)
                {
                    --j.eob_run;
                    for (k = j.spec_start; k <= j.spec_end; ++k)
                    {
                        short* p = &data[JpgDezigzag[k]];
                        if (*p != 0)
                            if ((GetJpgBit(j)) != 0)
                                if ((*p & bit) == 0)
                                {
                                    if ((*p) > 0) *p += bit;
                                    else *p -= bit;
                                }
                    }
                }
                else
                {
                    k = j.spec_start;
                    do
                    {
                        int r;
                        int s;
                        int rs = HuffDecodeJpg(j, hac);
                        if ((rs) < 0)
                            return j._readCtx.Error("bad huffman code");
                        s = rs & 15;
                        r = rs >> 4;
                        if ((s) == 0)
                        {
                            if ((r) < (15))
                            {
                                j.eob_run = (1 << r) - 1;
                                if ((r) != 0) j.eob_run += GetJpgBits(j, r);
                                r = 64;
                            }
                            else
                            {
                            }
                        }
                        else
                        {
                            if (s != 1)
                                return j._readCtx.Error("bad huffman code");
                            if ((GetJpgBit(j)) != 0) s = bit;
                            else s = -bit;
                        }
                        while (k <= j.spec_end)
                        {
                            short* p = &data[JpgDezigzag[k++]];
                            if (*p != 0)
                            {
                                if ((GetJpgBit(j)) != 0)
                                    if ((*p & bit) == 0)
                                    {
                                        if ((*p) > 0) *p += bit;
                                        else *p -= bit;
                                    }
                            }
                            else
                            {
                                if ((r) == 0)
                                {
                                    *p = ((short)(s));
                                    break;
                                }
                                --r;
                            }
                        }
                    } while (k <= j.spec_end);
                }
            }

            return 1;
        }

        public static byte Clamp(int x)
        {
            if (((uint)(x)) > (255))
            {
                if ((x) < 0) return 0;
                if ((x) > (255)) return 255;
            }

            return (byte)(x);
        }

        public static void IdctBlock(byte* _out_, int out_stride, short* data)
        {
            int i;
            int* val = stackalloc int[64];
            int* v = val;
            byte* o;
            short* d = data;
            for (i = 0; (i) < 8; ++i, ++d, ++v)
            {
                if ((((((((d[8]) == 0) && ((d[16]) == 0)) && ((d[24]) == 0)) && ((d[32]) == 0)) &&
                      ((d[40]) == 0)) &&
                     ((d[48]) == 0)) && ((d[56]) == 0))
                {
                    int dcterm = d[0] << 2;
                    v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
                }
                else
                {
                    int t0;
                    int t1;
                    int t2;
                    int t3;
                    int p1;
                    int p2;
                    int p3;
                    int p4;
                    int p5;
                    int x0;
                    int x1;
                    int x2;
                    int x3;
                    p2 = d[16];
                    p3 = d[48];
                    p1 = (p2 + p3) * ((int)((0.5411961f) * 4096 + 0.5));
                    t2 = p1 + p3 * ((int)((-1.847759065f) * 4096 + 0.5));
                    t3 = p1 + p2 * ((int)((0.765366865f) * 4096 + 0.5));
                    p2 = d[0];
                    p3 = d[32];
                    t0 = (p2 + p3) << 12;
                    t1 = (p2 - p3) << 12;
                    x0 = t0 + t3;
                    x3 = t0 - t3;
                    x1 = t1 + t2;
                    x2 = t1 - t2;
                    t0 = d[56];
                    t1 = d[40];
                    t2 = d[24];
                    t3 = d[8];
                    p3 = t0 + t2;
                    p4 = t1 + t3;
                    p1 = t0 + t3;
                    p2 = t1 + t2;
                    p5 = (p3 + p4) * ((int)((1.175875602f) * 4096 + 0.5));
                    t0 = t0 * ((int)((0.298631336f) * 4096 + 0.5));
                    t1 = t1 * ((int)((2.053119869f) * 4096 + 0.5));
                    t2 = t2 * ((int)((3.072711026f) * 4096 + 0.5));
                    t3 = t3 * ((int)((1.501321110f) * 4096 + 0.5));
                    p1 = p5 + p1 * ((int)((-0.899976223f) * 4096 + 0.5));
                    p2 = p5 + p2 * ((int)((-2.562915447f) * 4096 + 0.5));
                    p3 = p3 * ((int)((-1.961570560f) * 4096 + 0.5));
                    p4 = p4 * ((int)((-0.390180644f) * 4096 + 0.5));
                    t3 += p1 + p4;
                    t2 += p2 + p3;
                    t1 += p2 + p4;
                    t0 += p1 + p3;
                    x0 += 512;
                    x1 += 512;
                    x2 += 512;
                    x3 += 512;
                    v[0] = (x0 + t3) >> 10;
                    v[56] = (x0 - t3) >> 10;
                    v[8] = (x1 + t2) >> 10;
                    v[48] = (x1 - t2) >> 10;
                    v[16] = (x2 + t1) >> 10;
                    v[40] = (x2 - t1) >> 10;
                    v[24] = (x3 + t0) >> 10;
                    v[32] = (x3 - t0) >> 10;
                }
            }
            for (i = 0, v = val, o = _out_; (i) < 8; ++i, v += 8, o += out_stride)
            {
                int t0;
                int t1;
                int t2;
                int t3;
                int p1;
                int p2;
                int p3;
                int p4;
                int p5;
                int x0;
                int x1;
                int x2;
                int x3;
                p2 = v[2];
                p3 = v[6];
                p1 = (p2 + p3) * ((int)((0.5411961f) * 4096 + 0.5));
                t2 = p1 + p3 * ((int)((-1.847759065f) * 4096 + 0.5));
                t3 = p1 + p2 * ((int)((0.765366865f) * 4096 + 0.5));
                p2 = v[0];
                p3 = v[4];
                t0 = (p2 + p3) << 12;
                t1 = (p2 - p3) << 12;
                x0 = t0 + t3;
                x3 = t0 - t3;
                x1 = t1 + t2;
                x2 = t1 - t2;
                t0 = v[7];
                t1 = v[5];
                t2 = v[3];
                t3 = v[1];
                p3 = t0 + t2;
                p4 = t1 + t3;
                p1 = t0 + t3;
                p2 = t1 + t2;
                p5 = (p3 + p4) * ((int)((1.175875602f) * 4096 + 0.5));
                t0 = t0 * ((int)((0.298631336f) * 4096 + 0.5));
                t1 = t1 * ((int)((2.053119869f) * 4096 + 0.5));
                t2 = t2 * ((int)((3.072711026f) * 4096 + 0.5));
                t3 = t3 * ((int)((1.501321110f) * 4096 + 0.5));
                p1 = p5 + p1 * ((int)((-0.899976223f) * 4096 + 0.5));
                p2 = p5 + p2 * ((int)((-2.562915447f) * 4096 + 0.5));
                p3 = p3 * ((int)((-1.961570560f) * 4096 + 0.5));
                p4 = p4 * ((int)((-0.390180644f) * 4096 + 0.5));
                t3 += p1 + p4;
                t2 += p2 + p3;
                t1 += p2 + p4;
                t0 += p1 + p3;
                x0 += 65536 + (128 << 17);
                x1 += 65536 + (128 << 17);
                x2 += 65536 + (128 << 17);
                x3 += 65536 + (128 << 17);
                o[0] = Clamp((x0 + t3) >> 17);
                o[7] = Clamp((x0 - t3) >> 17);
                o[1] = Clamp((x1 + t2) >> 17);
                o[6] = Clamp((x1 - t2) >> 17);
                o[2] = Clamp((x2 + t1) >> 17);
                o[5] = Clamp((x2 - t1) >> 17);
                o[3] = Clamp((x3 + t0) >> 17);
                o[4] = Clamp((x3 - t0) >> 17);
            }
        }

        public static byte GetMarker(JpgImage j)
        {
            byte x;
            if (j._marker != 0xff)
            {
                x = j._marker;
                j._marker = 0xff;
                return x;
            }

            x = GetByte(j._readCtx);
            if (x != 0xff) return 0xff;
            while ((x) == (0xff))
            {
                x = GetByte(j._readCtx);
            }
            return x;
        }

        public static void ResetJpg(JpgImage j)
        {
            j._codeBits = 0;
            j._codeBuffer = 0;
            j._noMore = 0;
            j.JpgImgComp[0].dc_pred =

                    j.JpgImgComp[1].dc_pred = j.JpgImgComp[2].dc_pred = j.JpgImgComp[3].dc_pred = 0;
            j._marker = 0xff;
            j.ToDo = (j.RestartInterval) != 0 ? j.RestartInterval : 0x7fffffff;
            j.eob_run = 0;
        }

        public static int ParseEntropyCodedData(JpgImage z)
        {
            ResetJpg(z);
            int* zOrderP = z._order;

            if (z.progressive == 0)
            {
                if ((z.scan_n) == 1)
                {
                    int i;
                    int j;
                    short* data = stackalloc short[64];
                    int n = zOrderP[0];
                    int w = (z.JpgImgComp[n].x + 7) >> 3;
                    int h = (z.JpgImgComp[n].y + 7) >> 3;
                    for (j = 0; (j) < (h); ++j)
                    {
                        for (i = 0; (i) < (w); ++i)
                        {
                            int ha = z.JpgImgComp[n].ha;
                            if (DecodeJpgBlock(z, data, (Huffman*)z._huff_dc + z.JpgImgComp[n].hd,
                                (Huffman*)z._huff_ac + ha, z._fastAc[ha], n, z._dequant[z.JpgImgComp[n].tq]) == 0)
                                return 0;

                            z._IDCT_BlockKernel(
                                z.JpgImgComp[n].data + z.JpgImgComp[n].w2 * j * 8 + i * 8, z.JpgImgComp[n].w2, data);

                            if (--z.ToDo <= 0)
                            {
                                if ((z._codeBits) < (24))
                                    GrowBufferUnsafe(z);

                                if (!(((z._marker) >= (0xd0)) && ((z._marker) <= 0xd7)))
                                    return 1;

                                ResetJpg(z);
                            }
                        }
                    }
                    return 1;
                }
                else
                {
                    int i;
                    int j;
                    int k;
                    int x;
                    int y;
                    short* data = stackalloc short[64];
                    for (j = 0; (j) < (z.img_mcu_y); ++j)
                    {
                        for (i = 0; (i) < (z.img_mcu_x); ++i)
                        {
                            for (k = 0; (k) < (z.scan_n); ++k)
                            {
                                int n = zOrderP[k];
                                for (y = 0; (y) < (z.JpgImgComp[n].v); ++y)
                                {
                                    for (x = 0; (x) < (z.JpgImgComp[n].h); ++x)
                                    {
                                        int x2 = (i * z.JpgImgComp[n].h + x) * 8;
                                        int y2 = (j * z.JpgImgComp[n].v + y) * 8;
                                        int ha = z.JpgImgComp[n].ha;
                                        if (
                                            DecodeJpgBlock(z, data,
                                                (Huffman*)z._huff_dc + z.JpgImgComp[n].hd,
                                                (Huffman*)z._huff_ac + ha, z._fastAc[ha], n,
                                                z._dequant[z.JpgImgComp[n].tq]) == 0)
                                            return 0;
                                        z._IDCT_BlockKernel(z.JpgImgComp[n].data + z.JpgImgComp[n].w2 * y2 + x2,
                                            z.JpgImgComp[n].w2, data);
                                    }
                                }
                            }
                            if (--z.ToDo <= 0)
                            {
                                if ((z._codeBits) < (24)) GrowBufferUnsafe(z);
                                if (!(((z._marker) >= (0xd0)) && ((z._marker) <= 0xd7))) return 1;
                                ResetJpg(z);
                            }
                        }
                    }
                    return 1;
                }
            }
            else
            {
                if ((z.scan_n) == 1)
                {
                    int i;
                    int j;
                    int n = zOrderP[0];
                    int w = (z.JpgImgComp[n].x + 7) >> 3;
                    int h = (z.JpgImgComp[n].y + 7) >> 3;
                    for (j = 0; (j) < (h); ++j)
                    {
                        for (i = 0; (i) < (w); ++i)
                        {
                            short* data = z.JpgImgComp[n].coeff + 64 * (i + j * z.JpgImgComp[n].coeff_w);
                            if ((z.spec_start) == 0)
                            {
                                if (
                                    DecodeJpgBlock_ProgDc(z, data,
                                        (Huffman*)z._huff_dc + z.JpgImgComp[n].hd, n) == 0)
                                    return 0;
                            }
                            else
                            {
                                int ha = z.JpgImgComp[n].ha;
                                if (
                                    DecodeJpgBlock_ProgAc(z, data, (Huffman*)z._huff_ac + ha,
                                        z._fastAc[ha]) == 0)
                                    return 0;
                            }
                            if (--z.ToDo <= 0)
                            {
                                if ((z._codeBits) < (24)) GrowBufferUnsafe(z);
                                if (!(((z._marker) >= (0xd0)) && ((z._marker) <= 0xd7))) return 1;
                                ResetJpg(z);
                            }
                        }
                    }
                    return 1;
                }
                else
                {
                    int i;
                    int j;
                    int k;
                    int x;
                    int y;
                    for (j = 0; (j) < (z.img_mcu_y); ++j)
                    {
                        for (i = 0; (i) < (z.img_mcu_x); ++i)
                        {
                            for (k = 0; (k) < (z.scan_n); ++k)
                            {
                                int n = zOrderP[k];
                                for (y = 0; (y) < (z.JpgImgComp[n].v); ++y)
                                {
                                    for (x = 0; (x) < (z.JpgImgComp[n].h); ++x)
                                    {
                                        int x2 = i * z.JpgImgComp[n].h + x;
                                        int y2 = j * z.JpgImgComp[n].v + y;
                                        short* data = z.JpgImgComp[n].coeff + 64 * (x2 + y2 * z.JpgImgComp[n].coeff_w);
                                        if (
                                            DecodeJpgBlock_ProgDc(z, data,
                                                (Huffman*)z._huff_dc + z.JpgImgComp[n].hd, n) == 0)
                                            return 0;
                                    }
                                }
                            }
                            if (--z.ToDo <= 0)
                            {
                                if ((z._codeBits) < (24)) GrowBufferUnsafe(z);
                                if (!(((z._marker) >= (0xd0)) && ((z._marker) <= 0xd7))) return 1;
                                ResetJpg(z);
                            }
                        }
                    }
                    return 1;
                }
            }

        }

        public static void JpgDequantize(short* data, ushort* dequant)
        {
            int i;
            for (i = 0; (i) < (64); ++i)
            {
                data[i] *= (short)(dequant[i]);
            }
        }

        public static void FinishJpg(JpgImage z)
        {
            if ((z.progressive) != 0)
            {
                int i;
                int j;
                int n;
                for (n = 0; (n) < (z._readCtx.SourceChannels); ++n)
                {
                    int w = (z.JpgImgComp[n].x + 7) >> 3;
                    int h = (z.JpgImgComp[n].y + 7) >> 3;
                    for (j = 0; (j) < (h); ++j)
                    {
                        for (i = 0; (i) < (w); ++i)
                        {
                            short* data = z.JpgImgComp[n].coeff + 64 * (i + j * z.JpgImgComp[n].coeff_w);
                            JpgDequantize(data, z._dequant[z.JpgImgComp[n].tq]);
                            z._IDCT_BlockKernel(z.JpgImgComp[n].data + z.JpgImgComp[n].w2 * j * 8 + i * 8,
                                z.JpgImgComp[n].w2, data);
                        }
                    }
                }
            }

        }

        public static int ProcessMarker(JpgImage z, int m)
        {
            int L;
            switch (m)
            {
                case 0xff:
                    return z._readCtx.Error("expected marker");
                case 0xDD:
                    if (Get16be(z._readCtx) != 4)
                        return z._readCtx.Error("bad DRI len");
                    z.RestartInterval = Get16be(z._readCtx);
                    return 1;
                case 0xDB:
                    L = Get16be(z._readCtx) - 2;
                    while ((L) > 0)
                    {
                        int q = GetByte(z._readCtx);
                        int p = q >> 4;
                        int sixteen = (p != 0) ? 1 : 0;
                        int t = q & 15;
                        int i;
                        if ((p != 0) && (p != 1))
                            return z._readCtx.Error("bad DQT type");
                        if ((t) > 3)
                            return z._readCtx.Error("bad DQT table");
                        ushort* dequantP = z._dequant[t];
                        for (i = 0; (i) < (64); ++i)
                        {
                            dequantP[JpgDezigzag[i]] =
                                ((ushort)((sixteen) != 0 ? Get16be(z._readCtx) : GetByte(z._readCtx)));
                        }
                        L -= (sixteen) != 0 ? 129 : 65;
                    }
                    return (L) == 0 ? 1 : 0;
                case 0xC4:
                    L = Get16be(z._readCtx) - 2;
                    while ((L) > 0)
                    {
                        byte* v;
                        int* sizes = stackalloc int[16];
                        int i;
                        int n = 0;
                        int q = GetByte(z._readCtx);
                        int tc = q >> 4;
                        int th = q & 15;
                        if (((tc) > 1) || ((th) > 3))
                            return z._readCtx.Error("bad DHT header");
                        for (i = 0; (i) < (16); ++i)
                        {
                            sizes[i] = GetByte(z._readCtx);
                            n += sizes[i];
                        }
                        L -= 17;
                        if ((tc) == 0)
                        {
                            if (BuildHuffman(z._readCtx.ErrorCtx, (Huffman*)z._huff_dc + th, sizes) == 0)
                                return 0;
                            Huffman* h = (Huffman*)z._huff_dc + th;
                            v = h->values;
                        }
                        else
                        {
                            if (BuildHuffman(z._readCtx.ErrorCtx, (Huffman*)z._huff_ac + th, sizes) == 0)
                                return 0;
                            Huffman* h = (Huffman*)z._huff_ac + th;
                            v = h->values;
                        }
                        for (i = 0; (i) < (n); ++i)
                        {
                            v[i] = GetByte(z._readCtx);
                        }
                        if (tc != 0) BuildFastAc(z._fastAc[th], (Huffman*)z._huff_ac + th);
                        L -= n;
                    }
                    return (L) == 0 ? 1 : 0;
            }

            if ((((m) >= (0xE0)) && (m <= 0xEF)) || ((m) == (0xFE)))
            {
                L = Get16be(z._readCtx);
                if ((L) < 2)
                {
                    if ((m) == (0xFE))
                        return z._readCtx.Error("bad COM len");
                    else
                        return z._readCtx.Error("bad APP len");
                }
                L -= 2;
                if (((m) == (0xE0)) && ((L) >= 5))
                {
                    byte* tag = stackalloc byte[5];
                    tag[0] = (byte)('J');
                    tag[1] = (byte)('F');
                    tag[2] = (byte)('I');
                    tag[3] = (byte)('F');
                    tag[4] = (byte)('\0');
                    int ok = 1;
                    int i;
                    for (i = 0; (i) < 5; ++i)
                    {
                        if (GetByte(z._readCtx) != tag[i]) ok = 0;
                    }
                    L -= 5;
                    if ((ok) != 0) z.jfif = 1;
                }
                else if (((m) == (0xEE)) && ((L) >= 12))
                {
                    byte* tag = stackalloc byte[6];
                    tag[0] = (byte)('A');
                    tag[1] = (byte)('d');
                    tag[2] = (byte)('o');
                    tag[3] = (byte)('b');
                    tag[4] = (byte)('e');
                    tag[5] = (byte)('\0');
                    int ok = 1;
                    int i;
                    for (i = 0; (i) < 6; ++i)
                    {
                        if (GetByte(z._readCtx) != tag[i]) ok = 0;
                    }
                    L -= 6;
                    if ((ok) != 0)
                    {
                        GetByte(z._readCtx);
                        Get16be(z._readCtx);
                        Get16be(z._readCtx);
                        z.app14_color_transform = GetByte(z._readCtx);
                        L -= 6;
                    }
                }
                Skip(z._readCtx, L);
                return 1;
            }

            return z._readCtx.Error("unknown marker");
        }

        public static int ProcessScanHeader(JpgImage z)
        {
            int i;
            int Ls = Get16be(z._readCtx);
            z.scan_n = GetByte(z._readCtx);
            if ((((z.scan_n) < 1) || ((z.scan_n) > 4)) || ((z.scan_n) > (z._readCtx.SourceChannels)))
                return z._readCtx.Error("bad SOS component count");
            if (Ls != 6 + 2 * z.scan_n)
                return z._readCtx.Error("bad SOS len");

            int* zOrderP = z._order;
            for (i = 0; (i) < (z.scan_n); ++i)
            {
                int id = GetByte(z._readCtx);
                int which;
                int q = GetByte(z._readCtx);
                for (which = 0; (which) < (z._readCtx.SourceChannels); ++which)
                {
                    if ((z.JpgImgComp[which].id) == (id)) break;
                }
                if ((which) == (z._readCtx.SourceChannels)) return 0;
                z.JpgImgComp[which].hd = q >> 4;
                if ((z.JpgImgComp[which].hd) > 3)
                    return z._readCtx.Error("bad DC huff");
                z.JpgImgComp[which].ha = q & 15;
                if ((z.JpgImgComp[which].ha) > 3)
                    return z._readCtx.Error("bad AC huff");
                zOrderP[i] = which;
            }

            int aa;
            z.spec_start = GetByte(z._readCtx);
            z.spec_end = GetByte(z._readCtx);
            aa = GetByte(z._readCtx);
            z.succ_high = aa >> 4;
            z.succ_low = aa & 15;
            if ((z.progressive) != 0)
            {
                if ((((((z.spec_start) > (63)) || ((z.spec_end) > (63))) || ((z.spec_start) > (z.spec_end))) ||
                     ((z.succ_high) > (13))) || ((z.succ_low) > (13)))
                    return z._readCtx.Error("bad SOS");
            }
            else
            {
                if (z.spec_start != 0)
                    return z._readCtx.Error("bad SOS");
                if ((z.succ_high != 0) || (z.succ_low != 0))
                    return z._readCtx.Error("bad SOS");
                z.spec_end = 63;
            }

            return 1;
        }

        public static int FreeJpgComponents(JpgImage z, int ncomp, int why)
        {
            MemoryManager mm = z._readCtx.Manager;
            int i;
            for (i = 0; (i) < (ncomp); ++i)
            {
                if ((z.JpgImgComp[i].raw_data) != null)
                {
                    mm.Free(z.JpgImgComp[i].raw_data);
                    z.JpgImgComp[i].raw_data = null;
                    z.JpgImgComp[i].data = null;
                }
                if ((z.JpgImgComp[i].raw_coeff) != null)
                {
                    mm.Free(z.JpgImgComp[i].raw_coeff);
                    z.JpgImgComp[i].raw_coeff = null;
                    z.JpgImgComp[i].coeff = null;
                }
                if ((z.JpgImgComp[i].linebuf) != null)
                {
                    mm.Free(z.JpgImgComp[i].linebuf);
                    z.JpgImgComp[i].linebuf = null;
                }
            }
            return why;
        }

        public static int ProcessFrameHeader(JpgImage z, int scan)
        {
            ReadContext s = z._readCtx;
            int Lf;
            int p;
            int i;
            int q;
            int h_max = 1;
            int v_max = 1;
            int c;
            Lf = Get16be(s);
            if ((Lf) < 11) return z._readCtx.Error("bad SOF len");
            p = GetByte(s);
            if (p != 8) return z._readCtx.Error("only 8-bit");
            s.Height = (uint)(Get16be(s));
            if ((s.Height) == 0) return z._readCtx.Error("no header height");
            s.Width = (uint)(Get16be(s));
            if ((s.Width) == 0) return z._readCtx.Error("0 width");
            c = GetByte(s);
            if (((c != 3) && (c != 1)) && (c != 4)) return z._readCtx.Error("bad component count");
            s.SourceChannels = c;
            for (i = 0; (i) < (c); ++i)
            {
                z.JpgImgComp[i].data = null;
                z.JpgImgComp[i].linebuf = null;
            }
            if (Lf != 8 + 3 * s.SourceChannels)
                return z._readCtx.Error("bad SOF len");
            z.rgb = 0;
            for (i = 0; (i) < (s.SourceChannels); ++i)
            {
                byte* rgb = stackalloc byte[3];
                rgb[0] = (byte)('R');
                rgb[1] = (byte)('G');
                rgb[2] = (byte)('B');
                z.JpgImgComp[i].id = GetByte(s);
                if (((s.SourceChannels) == 3) && ((z.JpgImgComp[i].id) == (rgb[i]))) ++z.rgb;
                q = GetByte(s);
                z.JpgImgComp[i].h = q >> 4;
                if ((z.JpgImgComp[i].h == 0) || ((z.JpgImgComp[i].h) > 4))
                    return z._readCtx.Error("bad H");
                z.JpgImgComp[i].v = q & 15;
                if ((z.JpgImgComp[i].v == 0) || ((z.JpgImgComp[i].v) > 4))
                    return z._readCtx.Error("bad V");
                z.JpgImgComp[i].tq = GetByte(s);
                if ((z.JpgImgComp[i].tq) > 3)
                    return z._readCtx.Error("bad TQ");
            }
            if (scan != STBI__SCAN_load) return 1;
            if (ValidSizes_mad3((int)(s.Width), (int)(s.Height), s.SourceChannels, 0) == 0)
                return z._readCtx.Error("too large");
            for (i = 0; (i) < (s.SourceChannels); ++i)
            {
                if ((z.JpgImgComp[i].h) > (h_max)) h_max = z.JpgImgComp[i].h;
                if ((z.JpgImgComp[i].v) > (v_max)) v_max = z.JpgImgComp[i].v;
            }
            z.img_h_max = h_max;
            z.img_v_max = v_max;
            z.img_mcu_w = h_max * 8;
            z.img_mcu_h = v_max * 8;
            z.img_mcu_x = (int)((s.Width + z.img_mcu_w - 1) / z.img_mcu_w);
            z.img_mcu_y = (int)((s.Height + z.img_mcu_h - 1) / z.img_mcu_h);
            for (i = 0; (i) < (s.SourceChannels); ++i)
            {
                z.JpgImgComp[i].x = (int)((s.Width * z.JpgImgComp[i].h + h_max - 1) / h_max);
                z.JpgImgComp[i].y = (int)((s.Height * z.JpgImgComp[i].v + v_max - 1) / v_max);
                z.JpgImgComp[i].w2 = z.img_mcu_x * z.JpgImgComp[i].h * 8;
                z.JpgImgComp[i].h2 = z.img_mcu_y * z.JpgImgComp[i].v * 8;
                z.JpgImgComp[i].coeff = null;
                z.JpgImgComp[i].raw_coeff = null;
                z.JpgImgComp[i].linebuf = null;
                z.JpgImgComp[i].raw_data = MAlloc_mad2(s.Manager, z.JpgImgComp[i].w2, z.JpgImgComp[i].h2,
                    15);
                if ((z.JpgImgComp[i].raw_data) == null)
                    return FreeJpgComponents(z, i + 1, z._readCtx.Error("outofmem"));
                z.JpgImgComp[i].data = (byte*)((((long)z.JpgImgComp[i].raw_data + 15) & ~15));
                if ((z.progressive) != 0)
                {
                    z.JpgImgComp[i].coeff_w = z.JpgImgComp[i].w2 / 8;
                    z.JpgImgComp[i].coeff_h = z.JpgImgComp[i].h2 / 8;
                    z.JpgImgComp[i].raw_coeff = MAlloc_mad3(s.Manager, z.JpgImgComp[i].w2, z.JpgImgComp[i].h2,
                        2,
                        15);
                    if ((z.JpgImgComp[i].raw_coeff) == null)
                        return FreeJpgComponents(z, i + 1, z._readCtx.Error("outofmem"));
                    z.JpgImgComp[i].coeff = (short*)((((long)z.JpgImgComp[i].raw_coeff + 15) & ~15));
                }
            }
            return 1;
        }

        public static int DecodeJpgHeader(JpgImage z, int scan)
        {
            int m;
            z.jfif = 0;
            z.app14_color_transform = -1;
            z._marker = 0xff;
            m = GetMarker(z);
            if (!((m) == (0xd8)))
                return z._readCtx.Error("no SOI");
            if ((scan) == (STBI__SCAN_type)) return 1;
            m = GetMarker(z);
            while (!((((m) == (0xc0)) || ((m) == (0xc1))) || ((m) == (0xc2))))
            {
                if (ProcessMarker(z, m) == 0) return 0;
                m = GetMarker(z);
                while ((m) == (0xff))
                {
                    if ((AtEoF(z._readCtx)) != 0)
                        return z._readCtx.Error("no SOF");
                    m = GetMarker(z);
                }
            }
            z.progressive = (m) == (0xc2) ? 1 : 0;
            if (ProcessFrameHeader(z, scan) == 0) return 0;
            return 1;
        }

        public static int DecodeJpgImage(JpgImage j)
        {
            int m;
            for (m = 0; (m) < 4; m++)
            {
                j.JpgImgComp[m].raw_data = null;
                j.JpgImgComp[m].raw_coeff = null;
            }
            j.RestartInterval = 0;
            if (DecodeJpgHeader(j, STBI__SCAN_load) == 0) return 0;
            m = GetMarker(j);
            while (!((m) == (0xd9)))
            {
                if (((m) == (0xda)))
                {
                    if (ProcessScanHeader(j) == 0) return 0;
                    if (ParseEntropyCodedData(j) == 0) return 0;
                    if ((j._marker) == (0xff))
                    {
                        while (AtEoF(j._readCtx) == 0)
                        {
                            int x = GetByte(j._readCtx);
                            if ((x) == (255))
                            {
                                j._marker = GetByte(j._readCtx);
                                break;
                            }
                        }
                    }
                }
                else if (((m) == (0xdc)))
                {
                    int Ld = Get16be(j._readCtx);
                    uint NL = (uint)(Get16be(j._readCtx));
                    if (Ld != 4)
                        j._readCtx.Error("bad DNL len");
                    if (NL != j._readCtx.Height)
                        j._readCtx.Error("bad DNL height");
                }
                else
                {
                    if (ProcessMarker(j, m) == 0)
                        return 0;
                }
                m = GetMarker(j);
            }
            if ((j.progressive) != 0)
                FinishJpg(j);
            return 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ResampleRow1(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            return in_near;
        }

        public static byte* ResampleRow_v2(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            for (i = 0; (i) < (w); ++i)
            {
                _out_[i] = ((byte)((3 * in_near[i] + in_far[i] + 2) >> 2));
            }
            return _out_;
        }

        public static byte* ResampleRow_h2(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            byte* input = in_near;
            if ((w) == 1)
            {
                _out_[0] = _out_[1] = input[0];
                return _out_;
            }

            _out_[0] = input[0];
            _out_[1] = ((byte)((input[0] * 3 + input[1] + 2) >> 2));
            for (i = 1; (i) < (w - 1); ++i)
            {
                int n = 3 * input[i] + 2;
                _out_[i * 2 + 0] = ((byte)((n + input[i - 1]) >> 2));
                _out_[i * 2 + 1] = ((byte)((n + input[i + 1]) >> 2));
            }
            _out_[i * 2 + 0] = ((byte)((input[w - 2] * 3 + input[w - 1] + 2) >> 2));
            _out_[i * 2 + 1] = input[w - 1];
            return _out_;
        }

        public static byte* ResampleRow_hv2(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            int t0;
            int t1;
            if ((w) == 1)
            {
                _out_[0] = _out_[1] = ((byte)((3 * in_near[0] + in_far[0] + 2) >> 2));
                return _out_;
            }

            t1 = 3 * in_near[0] + in_far[0];
            _out_[0] = ((byte)((t1 + 2) >> 2));
            for (i = 1; (i) < (w); ++i)
            {
                t0 = t1;
                t1 = 3 * in_near[i] + in_far[i];
                _out_[i * 2 - 1] = ((byte)((3 * t0 + t1 + 8) >> 4));
                _out_[i * 2] = ((byte)((3 * t1 + t0 + 8) >> 4));
            }
            _out_[w * 2 - 1] = ((byte)((t1 + 2) >> 2));
            return _out_;
        }

        public static byte* GenericResampleRow(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            int j;
            for (i = 0; (i) < (w); ++i)
            {
                for (j = 0; (j) < (hs); ++j)
                {
                    _out_[i * hs + j] = in_near[i];
                }
            }
            return _out_;
        }

        public static void YCbCrToRGBRow(byte* _out_, byte* y, byte* pcb, byte* pcr, int count, int step)
        {
            int i;
            for (i = 0; (i) < (count); ++i)
            {
                int y_fixed = (y[i] << 20) + (1 << 19);
                int r;
                int g;
                int b;
                int cr = pcr[i] - 128;
                int cb = pcb[i] - 128;
                r = y_fixed + cr * (((int)((1.40200f) * 4096.0f + 0.5f)) << 8);
                g =
                    (int)
                        (y_fixed + (cr * -(((int)((0.71414f) * 4096.0f + 0.5f)) << 8)) +
                         ((cb * -(((int)((0.34414f) * 4096.0f + 0.5f)) << 8)) & 0xffff0000));
                b = y_fixed + cb * (((int)((1.77200f) * 4096.0f + 0.5f)) << 8);
                r >>= 20;
                g >>= 20;
                b >>= 20;
                if (((uint)(r)) > (255))
                {
                    if ((r) < 0) r = 0;
                    else r = 255;
                }
                if (((uint)(g)) > (255))
                {
                    if ((g) < 0) g = 0;
                    else g = 255;
                }
                if (((uint)(b)) > (255))
                {
                    if ((b) < 0) b = 0;
                    else b = 255;
                }
                _out_[0] = ((byte)(r));
                _out_[1] = ((byte)(g));
                _out_[2] = ((byte)(b));
                _out_[3] = 255;
                _out_ += step;
            }
        }

        public static void SetupJpg(JpgImage j)
        {
            j._IDCT_BlockKernel = IdctBlock;
            j._YCbCrToRGBkernel = YCbCrToRGBRow;
            j._resampleRow_HV2_kernel = ResampleRow_hv2;
        }

        public static void CleanupJpg(JpgImage j)
        {
            FreeJpgComponents(j, j._readCtx.SourceChannels, 0);
        }

        public static byte Blinn_8x8(byte x, byte y)
        {
            uint t = (uint)(x * y + 128);
            return (byte)((t + (t >> 8)) >> 8);
        }

        public static byte* LoadJpgImage(JpgImage z, int* out_x, int* out_y, int* comp, int req_comp)
        {
            ReadContext s = z._readCtx;

            int n;
            int decode_n;
            int is_rgb;
            s.SourceChannels = 0;
            if (((req_comp) < 0) || ((req_comp) > 4))
                return (s.Error("bad req_comp")) != 0 ? (byte*)null : null;
            if (DecodeJpgImage(z) == 0)
            {
                CleanupJpg(z);
                return null;
            }

            n = (req_comp) != 0 ? req_comp : (s.SourceChannels) >= 3 ? 3 : 1;
            is_rgb = (s.SourceChannels == 3) && (z.rgb == 3 || (z.app14_color_transform == 0 && z.jfif == 0)) ? 1 : 0;

            if (s.SourceChannels == 3 && n < 3 && is_rgb == 0)
                decode_n = 1;
            else
                decode_n = s.SourceChannels;

            int k;
            uint i;
            uint j;
            byte* output;
            byte** coutput = stackalloc byte*[4];
            var res_comp = new Resample[4];
            for (var kkk = 0; kkk < res_comp.Length; ++kkk) res_comp[kkk] = new Resample();
            for (k = 0; (k) < (decode_n); ++k)
            {
                Resample r = res_comp[k];
                z.JpgImgComp[k].linebuf = (byte*)(s.Manager.MAlloc(s.Width + 3));
                if (z.JpgImgComp[k].linebuf == null)
                {
                    CleanupJpg(z);
                    return (s.Error("outofmem")) != 0 ? (byte*)null : null;
                }
                r.hs = z.img_h_max / z.JpgImgComp[k].h;
                r.vs = z.img_v_max / z.JpgImgComp[k].v;
                r.ystep = r.vs >> 1;
                r.w_lores = (int)((s.Width + r.hs - 1) / r.hs);
                r.ypos = 0;
                r.line0 = r.line1 = z.JpgImgComp[k].data;
                if (((r.hs) == 1) && ((r.vs) == 1))
                    r.resampleDelegate = ResampleRow1;
                else if (((r.hs) == 1) && ((r.vs) == 2)) r.resampleDelegate = ResampleRow_v2;
                else if (((r.hs) == 2) && ((r.vs) == 1)) r.resampleDelegate = ResampleRow_h2;
                else if (((r.hs) == 2) && ((r.vs) == 2)) r.resampleDelegate = z._resampleRow_HV2_kernel;
                else r.resampleDelegate = GenericResampleRow;
            }

            output = (byte*)(MAlloc_mad3(s.Manager, n, (int)(s.Width), (int)(s.Height), 1));
            if (output == null)
            {
                CleanupJpg(z);
                return (s.Error("outofmem")) != 0 ? (byte*)null : null;
            }

            for (j = 0; (j) < (s.Height); ++j)
            {
                byte* _out_ = output + n * s.Width * j;
                for (k = 0; (k) < (decode_n); ++k)
                {
                    Resample r = res_comp[k];
                    int y_bot = (r.ystep) >= (r.vs >> 1) ? 1 : 0;

                    coutput[k] = r.resampleDelegate(
                        z.JpgImgComp[k].linebuf, (y_bot) != 0 ? r.line1 : r.line0,
                        (y_bot) != 0 ? r.line0 : r.line1,
                        r.w_lores, r.hs);

                    if ((++r.ystep) >= (r.vs))
                    {
                        r.ystep = 0;
                        r.line0 = r.line1;
                        if ((++r.ypos) < (z.JpgImgComp[k].y)) r.line1 += z.JpgImgComp[k].w2;
                    }
                }
                if ((n) >= 3)
                {
                    byte* y = coutput[0];
                    if ((s.SourceChannels) == 3)
                    {
                        if ((is_rgb) != 0)
                        {
                            for (i = 0; (i) < (s.Width); ++i)
                            {
                                _out_[0] = y[i];
                                _out_[1] = coutput[1][i];
                                _out_[2] = coutput[2][i];
                                _out_[3] = 255;
                                _out_ += n;
                            }
                        }
                        else
                        {
                            z._YCbCrToRGBkernel(_out_, y, coutput[1], coutput[2], (int)(s.Width), n);
                        }
                    }
                    else if ((s.SourceChannels) == 4)
                    {
                        if ((z.app14_color_transform) == 0)
                        {
                            for (i = 0; (i) < (s.Width); ++i)
                            {
                                byte m = coutput[3][i];
                                _out_[0] = Blinn_8x8(coutput[0][i], m);
                                _out_[1] = Blinn_8x8(coutput[1][i], m);
                                _out_[2] = Blinn_8x8(coutput[2][i], m);
                                _out_[3] = 255;
                                _out_ += n;
                            }
                        }
                        else if ((z.app14_color_transform) == 2)
                        {
                            z._YCbCrToRGBkernel(_out_, y, coutput[1], coutput[2], (int)(s.Width), n);
                            for (i = 0; (i) < (s.Width); ++i)
                            {
                                byte m = coutput[3][i];
                                _out_[0] = Blinn_8x8((byte)(255 - _out_[0]), m);
                                _out_[1] = Blinn_8x8((byte)(255 - _out_[1]), m);
                                _out_[2] = Blinn_8x8((byte)(255 - _out_[2]), m);
                                _out_ += n;
                            }
                        }
                        else
                        {
                            z._YCbCrToRGBkernel(_out_, y, coutput[1], coutput[2], (int)(s.Width), n);
                        }
                    }
                    else
                        for (i = 0; (i) < (s.Width); ++i)
                        {
                            _out_[0] = _out_[1] = _out_[2] = y[i];
                            _out_[3] = 255;
                            _out_ += n;
                        }
                }
                else
                {
                    if ((is_rgb) != 0)
                    {
                        if ((n) == 1)
                            for (i = 0; (i) < (s.Width); ++i)
                            {
                                *_out_++ =

                                        ComputeY(coutput[0][i], coutput[1][i],
                                            coutput[2][i]);
                            }
                        else
                        {
                            for (i = 0; (i) < (s.Width); ++i, _out_ += 2)
                            {
                                _out_[0] =

                                        ComputeY(coutput[0][i], coutput[1][i],
                                            coutput[2][i]);
                                _out_[1] = 255;
                            }
                        }
                    }
                    else if (((s.SourceChannels) == 4) && ((z.app14_color_transform) == 0))
                    {
                        for (i = 0; (i) < (s.Width); ++i)
                        {
                            byte m = coutput[3][i];
                            byte r = Blinn_8x8(coutput[0][i], m);
                            byte g = Blinn_8x8(coutput[1][i], m);
                            byte b = Blinn_8x8(coutput[2][i], m);
                            _out_[0] = ComputeY(r, g, b);
                            _out_[1] = 255;
                            _out_ += n;
                        }
                    }
                    else if (((s.SourceChannels) == 4) && ((z.app14_color_transform) == 2))
                    {
                        for (i = 0; (i) < (s.Width); ++i)
                        {
                            _out_[0] =
                                Blinn_8x8((byte)(255 - coutput[0][i]), coutput[3][i]);
                            _out_[1] = 255;
                            _out_ += n;
                        }
                    }
                    else
                    {
                        byte* y = coutput[0];
                        if ((n) == 1)
                            for (i = 0; (i) < (s.Width); ++i)
                            {
                                _out_[i] = y[i];
                            }
                        else
                            for (i = 0; (i) < (s.Width); ++i)
                            {
                                *_out_++ = y[i];
                                *_out_++ = 255;
                            }
                    }
                }
            }

            CleanupJpg(z);
            *out_x = (int)(s.Width);
            *out_y = (int)(s.Height);
            if ((comp) != null)
                *comp = (s.SourceChannels) >= 3 ? 3 : 1;

            return output;
        }

        public static void* LoadJpg(ReadContext s, int* x, int* y, int* comp, int req_comp,
            ResultInfo* ri)
        {
            byte* result;
            JpgImage j = new JpgImage(s);
            SetupJpg(j);
            result = LoadJpgImage(j, x, y, comp, req_comp);

            return result;
        }

        public static int TestForJpg(ReadContext s)
        {
            JpgImage j = new JpgImage(s);
            SetupJpg(j);
            int r = DecodeJpgHeader(j, STBI__SCAN_type);
            Rewind(s);

            return r;
        }

        public static int GetRawJpgInfo(JpgImage j, int* x, int* y, int* comp)
        {
            if (DecodeJpgHeader(j, STBI__SCAN_header) == 0)
            {
                Rewind(j._readCtx);
                return 0;
            }

            if ((x) != null) *x = (int)(j._readCtx.Width);
            if ((y) != null) *y = (int)(j._readCtx.Height);
            if ((comp) != null) *comp = (j._readCtx.SourceChannels) >= 3 ? 3 : 1;
            return 1;
        }

        public static int GetJpgInfo(ReadContext s, int* x, int* y, int* comp)
        {
            JpgImage j = new JpgImage(s);
            return GetRawJpgInfo(j, x, y, comp);
        }

        public static int BitReverse16(int n)
        {
            n = ((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1);
            n = ((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2);
            n = ((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4);
            n = ((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8);
            return n;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int BitReverse(int v, int bits)
        {
            return BitReverse16(v) >> (16 - bits);
        }

        public static int BuildHuffmanZ(ErrorContext ec, ZHuffman* z, byte* sizelist, int num)
        {
            int i;
            int k = 0;
            int code;
            int* next_code = stackalloc int[16];
            int* sizes = stackalloc int[17];
            MemSet(sizes, 0, sizeof(int));
            MemSet(z->fast, 0, (1 << 9) * sizeof(ushort));
            for (i = 0; (i) < (num); ++i)
            {
                ++sizes[sizelist[i]];
            }
            sizes[0] = 0;
            for (i = 1; (i) < (16); ++i)
            {
                if ((sizes[i]) > (1 << i))
                    return ec.Error("bad sizes");
            }
            code = 0;
            for (i = 1; (i) < (16); ++i)
            {
                next_code[i] = code;
                z->firstcode[i] = ((ushort)(code));
                z->firstsymbol[i] = ((ushort)(k));
                code = code + sizes[i];
                if ((sizes[i]) != 0) if ((code - 1) >= (1 << i))
                        return ec.Error("bad codelengths");
                z->maxcode[i] = code << (16 - i);
                code <<= 1;
                k += sizes[i];
            }
            z->maxcode[16] = 0x10000;
            for (i = 0; (i) < (num); ++i)
            {
                int s = sizelist[i];
                if ((s) != 0)
                {
                    int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
                    ushort fastv = (ushort)((s << 9) | i);
                    z->size[c] = ((byte)(s));
                    z->value[c] = ((ushort)(i));
                    if (s <= 9)
                    {
                        int j = BitReverse(next_code[s], s);
                        while ((j) < (1 << 9))
                        {
                            z->fast[j] = fastv;
                            j += 1 << s;
                        }
                    }
                    ++next_code[s];
                }
            }
            return 1;
        }

        public static byte GetZ8(ZBuffer* z)
        {
            if ((z->zbuffer) >= (z->zbuffer_end)) return 0;
            return *z->zbuffer++;
        }

        public static void FillZBits(ZBuffer* z)
        {
            do
            {
                z->code_buffer |= (uint)(GetZ8(z)) << z->num_bits;
                z->num_bits += 8;
            } while (z->num_bits <= 24);
        }

        public static uint ReceiveZ(ZBuffer* z, int n)
        {
            uint k;
            if ((z->num_bits) < (n)) FillZBits(z);
            k = (uint)(z->code_buffer & ((1 << n) - 1));
            z->code_buffer >>= n;
            z->num_bits -= n;
            return k;
        }

        public static int HuffmanDecodeSlowpathZ(ZBuffer* a, ZHuffman* z)
        {
            int b;
            int s;
            int k;
            k = BitReverse((int)(a->code_buffer), 16);
            for (s = 9 + 1; ; ++s)
            {
                if ((k) < (z->maxcode[s])) break;
            }
            if ((s) == (16)) return -1;
            b = (k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s];
            a->code_buffer >>= s;
            a->num_bits -= s;
            return z->value[b];
        }

        public static int HuffmanDecodeZ(ZBuffer* a, ZHuffman* z)
        {
            int b;
            int s;
            if ((a->num_bits) < (16)) FillZBits(a);
            b = z->fast[a->code_buffer & ((1 << 9) - 1)];
            if ((b) != 0)
            {
                s = b >> 9;
                a->code_buffer >>= s;
                a->num_bits -= s;
                return b & 511;
            }

            return HuffmanDecodeSlowpathZ(a, z);
        }

        public static int ExpandZ(MemoryManager mm, ErrorContext ec, ZBuffer* z, sbyte* zout, int n)
        {
            sbyte* q;
            int cur;
            int limit;
            int old_limit;
            z->zout = zout;
            if (z->z_expandable == 0)
                return ec.Error("output buffer limit");

            cur = ((int)(z->zout - z->zout_start));
            limit = old_limit = ((int)(z->zout_end - z->zout_start));
            while ((cur + n) > (limit))
            {
                limit *= 2;
            }
            q = (sbyte*)(mm.ReAlloc(z->zout_start, limit));
            if ((q) == null)
                return ec.Error("outofmem");
            z->zout_start = q;
            z->zout = q + cur;
            z->zout_end = q + limit;
            return 1;
        }

        public static int ParseHuffmanBlockZ(MemoryManager mm, ErrorContext ec, ZBuffer* a)
        {
            sbyte* zout = a->zout;
            for (; ; )
            {
                int z = HuffmanDecodeZ(a, &a->z_length);
                if ((z) < (256))
                {
                    if ((z) < 0)
                        return ec.Error("bad huffman code");
                    if ((zout) >= (a->zout_end))
                    {
                        if (ExpandZ(mm, ec, a, zout, 1) == 0)
                            return 0;
                        zout = a->zout;
                    }
                    *zout++ = ((sbyte)(z));
                }
                else
                {
                    byte* p;
                    int len;
                    int dist;
                    if ((z) == (256))
                    {
                        a->zout = zout;
                        return 1;
                    }
                    z -= 257;
                    len = LengthBaseZ[z];
                    if ((LengthExtraZ[z]) != 0) len += (int)(ReceiveZ(a, LengthExtraZ[z]));
                    z = HuffmanDecodeZ(a, &a->z_distance);
                    if ((z) < 0)
                        return ec.Error("bad huffman code");
                    dist = DistBaseZ[z];
                    if ((DistExtraZ[z]) != 0) dist += (int)(ReceiveZ(a, DistExtraZ[z]));
                    if ((zout - a->zout_start) < (dist))
                        return ec.Error("bad dist");
                    if ((zout + len) > (a->zout_end))
                    {
                        if (ExpandZ(mm, ec, a, zout, len) == 0)
                            return 0;
                        zout = a->zout;
                    }
                    p = (byte*)(zout - dist);
                    if ((dist) == 1)
                    {
                        byte v = *p;
                        if ((len) != 0)
                        {
                            do *zout++ = (sbyte)(v); while ((--len) != 0);
                        }
                    }
                    else
                    {
                        if ((len) != 0)
                        {
                            do *zout++ = (sbyte)(*p++); while ((--len) != 0);
                        }
                    }
                }
            }
        }

        public static int ComputeHuffmanCodes(ErrorContext ec, ZBuffer* a)
        {
            ZHuffman z_codelength = new ZHuffman();
            byte* lencodes = stackalloc byte[286 + 32 + 137];
            byte* codelength_sizes = stackalloc byte[19];
            int i;
            int n;
            int hlit = (int)(ReceiveZ(a, 5) + 257);
            int hdist = (int)(ReceiveZ(a, 5) + 1);
            int hclen = (int)(ReceiveZ(a, 4) + 4);
            int ntot = hlit + hdist;
            MemSet(codelength_sizes, 0, 19 * sizeof(byte));
            for (i = 0; (i) < (hclen); ++i)
            {
                int s = (int)(ReceiveZ(a, 3));
                codelength_sizes[LengthDezigzag[i]] = ((byte)(s));
            }
            if (BuildHuffmanZ(ec, &z_codelength, codelength_sizes, 19) == 0) return 0;
            n = 0;
            while ((n) < (ntot))
            {
                int c = HuffmanDecodeZ(a, &z_codelength);
                if (((c) < 0) || ((c) >= (19)))
                    return ec.Error("bad codelengths");

                if ((c) < (16))
                    lencodes[n++] = ((byte)(c));
                else
                {
                    byte fill = 0;
                    if ((c) == (16))
                    {
                        c = (int)(ReceiveZ(a, 2) + 3);
                        if ((n) == 0)
                            return ec.Error("bad codelengths");
                        fill = lencodes[n - 1];
                    }
                    else if ((c) == (17))
                        c = (int)(ReceiveZ(a, 3) + 3);
                    else
                    {
                        c = (int)(ReceiveZ(a, 7) + 11);
                    }
                    if ((ntot - n) < (c))
                        return ec.Error("bad codelengths");
                    MemSet(lencodes + n, fill, (ulong)(c));
                    n += c;
                }
            }

            if (n != ntot)
                return ec.Error("bad codelengths");

            if (BuildHuffmanZ(ec, &a->z_length, lencodes, hlit) == 0)
                return 0;

            if (BuildHuffmanZ(ec, &a->z_distance, lencodes + hlit, hdist) == 0)
                return 0;

            return 1;
        }

        public static int ParseUncompressedBlockZ(MemoryManager mm, ErrorContext ec, ZBuffer* a)
        {
            byte* header = stackalloc byte[4];
            int len;
            int nlen;
            int k;
            if ((a->num_bits & 7) != 0) ReceiveZ(a, a->num_bits & 7);
            k = 0;
            while ((a->num_bits) > 0)
            {
                header[k++] = ((byte)(a->code_buffer & 255));
                a->code_buffer >>= 8;
                a->num_bits -= 8;
            }
            while ((k) < 4)
            {
                header[k++] = GetZ8(a);
            }
            len = header[1] * 256 + header[0];
            nlen = header[3] * 256 + header[2];

            if (nlen != (len ^ 0xffff))
                return ec.Error("zlib corrupt");

            if ((a->zbuffer + len) > (a->zbuffer_end))
                return ec.Error("read past buffer");

            if ((a->zout + len) > (a->zout_end))
                if (ExpandZ(mm, ec, a, a->zout, len) == 0)
                    return 0;

            MemCopy(a->zout, a->zbuffer, len);
            a->zbuffer += len;
            a->zout += len;
            return 1;
        }

        public static int ParseZlibHeader(ErrorContext ec, ZBuffer* a)
        {
            int cmf = GetZ8(a);
            int cm = cmf & 15;
            int flg = GetZ8(a);
            if ((cmf * 256 + flg) % 31 != 0)
                return ec.Error("bad zlib header");
            if ((flg & 32) != 0)
                return ec.Error("no preset dict");
            if (cm != 8)
                return ec.Error("bad compression");
            return 1;
        }

        public static int ParseZlib(MemoryManager mm, ErrorContext ec, ZBuffer* a, int parse_header)
        {
            int final;
            int type;
            if ((parse_header) != 0) if (ParseZlibHeader(ec, a) == 0) return 0;
            a->num_bits = 0;
            a->code_buffer = 0;
            do
            {
                final = (int)(ReceiveZ(a, 1));
                type = (int)(ReceiveZ(a, 2));
                if ((type) == 0)
                {
                    if (ParseUncompressedBlockZ(mm, ec, a) == 0)
                        return 0;
                }
                else if ((type) == 3)
                {
                    return 0;
                }
                else
                {
                    if ((type) == 1)
                    {
                        fixed (byte* b = stbi__zdefault_length)
                        {
                            if (BuildHuffmanZ(ec, &a->z_length, b, 288) == 0)
                                return 0;
                        }
                        fixed (byte* b = DefaultDistanceZ)
                        {
                            if (BuildHuffmanZ(ec, &a->z_distance, b, 32) == 0)
                                return 0;
                        }
                    }
                    else
                    {
                        if (ComputeHuffmanCodes(ec, a) == 0)
                            return 0;
                    }
                    if (ParseHuffmanBlockZ(mm, ec, a) == 0)
                        return 0;
                }
            } while (final == 0);

            return 1;
        }

        public static int DoZlib(MemoryManager mm, ErrorContext ec,
            ZBuffer* a, sbyte* obuf, int olen, int exp, int parse_header)
        {
            a->zout_start = obuf;
            a->zout = obuf;
            a->zout_end = obuf + olen;
            a->z_expandable = exp;
            return ParseZlib(mm, ec, a, parse_header);
        }

        /*
        public static sbyte* ZlibDecode_MAllocGuessSize(MemoryManager manager,
            sbyte* buffer, int len, int initial_size, int* outlen)
        {
            ZBuffer a = new ZBuffer();
            sbyte* p = (sbyte*)(manager.MAlloc(initial_size));
            if ((p) == null) return null;
            a.zbuffer = (byte*)(buffer);
            a.zbuffer_end = (byte*)(buffer) + len;
            if ((DoZlib(&a, p, initial_size, 1, 1)) != 0)
            {
                if ((outlen) != null) *outlen = ((int)(a.zout - a.zout_start));
                return a.zout_start;
            }
            else
            {
                manager.Free(a.zout_start);
                return null;
            }

        }

        public static sbyte* ZlibDecode_MAlloc(MemoryManager manager, sbyte* buffer, int len, int* outlen)
        {
            return ZlibDecode_MAllocGuessSize(manager, buffer, len, 16384, outlen);
        }
        */

        public static sbyte* ZlibDecodeMAlloc_GuessSizeHeaderFlag(MemoryManager mm, ErrorContext ec,
            sbyte* buffer, int len, int initial_size, int* outlen, int parse_header)
        {
            ZBuffer a = new ZBuffer();
            sbyte* p = (sbyte*)(mm.MAlloc(initial_size));
            if ((p) == null) return null;
            a.zbuffer = (byte*)(buffer);
            a.zbuffer_end = (byte*)(buffer) + len;
            if ((DoZlib(mm, ec, &a, p, initial_size, 1, parse_header)) != 0)
            {
                if ((outlen) != null) *outlen = ((int)(a.zout - a.zout_start));
                return a.zout_start;
            }
            else
            {
                mm.Free(a.zout_start);
                return null;
            }

        }

        public static int ZlibDecodeBuffer(MemoryManager mm, ErrorContext ec,
            sbyte* obuffer, int olen, sbyte* ibuffer, int ilen)
        {
            ZBuffer a = new ZBuffer
            {
                zbuffer = (byte*)(ibuffer),
                zbuffer_end = (byte*)(ibuffer) + ilen
            };
            if ((DoZlib(mm, ec, &a, obuffer, olen, 0, 1)) != 0)
                return (int)(a.zout - a.zout_start);
            else return -1;
        }

        public static sbyte* ZlibDecode_NoHeaderMAlloc(MemoryManager mm, ErrorContext ec,
            sbyte* buffer, int len, int* outlen)
        {
            ZBuffer a = new ZBuffer();
            sbyte* p = (sbyte*)(mm.MAlloc(16384));
            if ((p) == null) return null;
            a.zbuffer = (byte*)(buffer);
            a.zbuffer_end = (byte*)(buffer) + len;
            if ((DoZlib(mm, ec, &a, p, 16384, 1, 0)) != 0)
            {
                if ((outlen) != null) *outlen = ((int)(a.zout - a.zout_start));
                return a.zout_start;
            }
            else
            {
                mm.Free(a.zout_start);
                return null;
            }

        }

        public static int ZlibDecode_NoHeaderBuffer(MemoryManager mm, ErrorContext ec,
            sbyte* obuffer, int olen, sbyte* ibuffer, int ilen)
        {
            ZBuffer a = new ZBuffer
            {
                zbuffer = (byte*)(ibuffer),
                zbuffer_end = (byte*)(ibuffer) + ilen
            };
            if ((DoZlib(mm, ec, &a, obuffer, olen, 0, 0)) != 0)
                return (int)(a.zout - a.zout_start);
            else return -1;
        }

        public static PngChunk GetChunkHeader(ReadContext s)
        {
            PngChunk c = new PngChunk
            {
                length = Get32be(s),
                type = Get32be(s)
            };
            return c;
        }

        public static int CheckPngHeader(ReadContext s)
        {
            int i;
            for (i = 0; (i) < 8; ++i)
            {
                if (GetByte(s) != PngSig[i])
                    return s.Error("bad png sig");
            }
            return 1;
        }

        public static int PaethFilter(int a, int b, int c)
        {
            int p = a + b - c;
            int pa = Abs(p - a);
            int pb = Abs(p - b);
            int pc = Abs(p - c);

            if ((pa <= pb) && (pa <= pc))
                return a;

            if (pb <= pc)
                return b;

            return c;
        }

        public static int CreateRawPngImage(PngImage a, byte* raw, uint raw_len,
            int out_n, uint x, uint y, int depth, int color)
        {
            int bytes = depth == (16) ? 2 : 1;
            ReadContext s = a._readCtx;
            uint i;
            uint j;
            uint stride = (uint)(x * out_n * bytes);
            uint img_len;
            uint img_width_bytes;
            int k;
            int img_n = s.SourceChannels;
            int output_bytes = out_n * bytes;
            int filter_bytes = img_n * bytes;
            int width = (int)(x);
            a._out_ = (byte*)(MAlloc_mad3(s.Manager, (int)(x), (int)(y), output_bytes, 0));
            if (a._out_ == null) return s.Error("outofmem");
            img_width_bytes = (uint)(((img_n * x * depth) + 7) >> 3);
            img_len = (img_width_bytes + 1) * y;
            if ((raw_len) < (img_len)) return s.Error("not enough pixels");
            for (j = 0; (j) < (y); ++j)
            {
                byte* cur = a._out_ + stride * j;
                byte* prior;
                int filter = *raw++;
                if ((filter) > 4) return s.Error("invalid filter");
                if (depth < 8)
                {
                    cur += x * out_n - img_width_bytes;
                    filter_bytes = 1;
                    width = (int)(img_width_bytes);
                }
                prior = cur - stride;
                if ((j) == 0) filter = FirstRowFilter[filter];
                for (k = 0; (k) < (filter_bytes); ++k)
                {
                    switch (filter)
                    {
                        case FNone:
                            cur[k] = raw[k];
                            break;
                        case FSub:
                            cur[k] = raw[k];
                            break;
                        case STBI__F_up:
                            cur[k] = ((byte)((raw[k] + prior[k]) & 255));
                            break;
                        case STBI__F_avg:
                            cur[k] = ((byte)((raw[k] + (prior[k] >> 1)) & 255));
                            break;
                        case STBI__F_paeth:
                            cur[k] = ((byte)((raw[k] + PaethFilter(0, prior[k], 0)) & 255));
                            break;
                        case FAvgFirst:
                            cur[k] = raw[k];
                            break;
                        case FPaethFirst:
                            cur[k] = raw[k];
                            break;
                    }
                }
                if (depth == 8)
                {
                    if (img_n != out_n) cur[img_n] = 255;
                    raw += img_n;
                    cur += out_n;
                    prior += out_n;
                }
                else if (depth == (16))
                {
                    if (img_n != out_n)
                    {
                        cur[filter_bytes] = 255;
                        cur[filter_bytes + 1] = 255;
                    }
                    raw += filter_bytes;
                    cur += output_bytes;
                    prior += output_bytes;
                }
                else
                {
                    raw += 1;
                    cur += 1;
                    prior += 1;
                }
                if ((depth < 8) || ((img_n) == (out_n)))
                {
                    int nk = (width - 1) * filter_bytes;
                    switch (filter)
                    {
                        case FNone:
                            MemCopy(cur, raw, nk);
                            break;
                        case FSub:
                            for (k = 0; (k) < (nk); ++k)
                            {
                                cur[k] = ((byte)((raw[k] + cur[k - filter_bytes]) & 255));
                            }
                            break;
                        case STBI__F_up:
                            for (k = 0; (k) < (nk); ++k)
                            {
                                cur[k] = ((byte)((raw[k] + prior[k]) & 255));
                            }
                            break;
                        case STBI__F_avg:
                            for (k = 0; (k) < (nk); ++k)
                            {
                                cur[k] = ((byte)((raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)) & 255));
                            }
                            break;
                        case STBI__F_paeth:
                            for (k = 0; (k) < (nk); ++k)
                            {
                                cur[k] =
                                    ((byte)
                                        ((raw[k] +
                                          PaethFilter(cur[k - filter_bytes], prior[k],
                                              prior[k - filter_bytes])) &
                                         255));
                            }
                            break;
                        case FAvgFirst:
                            for (k = 0; (k) < (nk); ++k)
                            {
                                cur[k] = ((byte)((raw[k] + (cur[k - filter_bytes] >> 1)) & 255));
                            }
                            break;
                        case FPaethFirst:
                            for (k = 0; (k) < (nk); ++k)
                            {
                                cur[k] =
                                    ((byte)
                                        ((raw[k] + PaethFilter(cur[k - filter_bytes], 0, 0)) &
                                         255));
                            }
                            break;
                    }
                    raw += nk;
                }
                else
                {
                    switch (filter)
                    {
                        case FNone:
                            for (i = x - 1;
                                (i) >= 1;
                                --i, cur[filter_bytes] = 255, raw += filter_bytes, cur += output_bytes,
                                    prior += output_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                {
                                    cur[k] = raw[k];
                                }
                            }
                            break;
                        case FSub:
                            for (i = x - 1;
                                (i) >= 1;
                                --i, cur[filter_bytes] = 255, raw += filter_bytes, cur += output_bytes,
                                    prior += output_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                {
                                    cur[k] = ((byte)((raw[k] + cur[k - output_bytes]) & 255));
                                }
                            }
                            break;
                        case STBI__F_up:
                            for (i = x - 1;
                                (i) >= 1;
                                --i, cur[filter_bytes] = 255, raw += filter_bytes, cur += output_bytes,
                                    prior += output_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                {
                                    cur[k] = ((byte)((raw[k] + prior[k]) & 255));
                                }
                            }
                            break;
                        case STBI__F_avg:
                            for (i = x - 1;
                                (i) >= 1;
                                --i, cur[filter_bytes] = 255, raw += filter_bytes, cur += output_bytes,
                                    prior += output_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                {
                                    cur[k] = ((byte)((raw[k] + ((prior[k] + cur[k - output_bytes]) >> 1)) & 255));
                                }
                            }
                            break;
                        case STBI__F_paeth:
                            for (i = x - 1;
                                (i) >= 1;
                                --i, cur[filter_bytes] = 255, raw += filter_bytes, cur += output_bytes,
                                    prior += output_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                {
                                    cur[k] =
                                        ((byte)
                                            ((raw[k] +
                                              PaethFilter(cur[k - output_bytes], prior[k],
                                                  prior[k - output_bytes])) &
                                             255));
                                }
                            }
                            break;
                        case FAvgFirst:
                            for (i = x - 1;
                                (i) >= 1;
                                --i, cur[filter_bytes] = 255, raw += filter_bytes, cur += output_bytes,
                                    prior += output_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                {
                                    cur[k] = ((byte)((raw[k] + (cur[k - output_bytes] >> 1)) & 255));
                                }
                            }
                            break;
                        case FPaethFirst:
                            for (i = x - 1;
                                (i) >= 1;
                                --i, cur[filter_bytes] = 255, raw += filter_bytes, cur += output_bytes,
                                    prior += output_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                {
                                    cur[k] =
                                        ((byte)
                                            ((raw[k] + PaethFilter(cur[k - output_bytes], 0, 0)) &
                                             255));
                                }
                            }
                            break;
                    }
                    if (depth == (16))
                    {
                        cur = a._out_ + stride * j;
                        for (i = 0; (i) < (x); ++i, cur += output_bytes)
                        {
                            cur[filter_bytes + 1] = 255;
                        }
                    }
                }
            }
            if (depth < 8)
            {
                for (j = 0; (j) < (y); ++j)
                {
                    byte* cur = a._out_ + stride * j;
                    byte* _in_ = a._out_ + stride * j + x * out_n - img_width_bytes;
                    byte scale = (byte)((color == 0) ? DepthScaleTable[depth] : 1);
                    if (depth == 4)
                    {
                        for (k = (int)(x * img_n); (k) >= 2; k -= 2, ++_in_)
                        {
                            *cur++ = (byte)(scale * (*_in_ >> 4));
                            *cur++ = (byte)(scale * ((*_in_) & 0x0f));
                        }
                        if ((k) > 0) *cur++ = (byte)(scale * (*_in_ >> 4));
                    }
                    else if (depth == 2)
                    {
                        for (k = (int)(x * img_n); (k) >= 4; k -= 4, ++_in_)
                        {
                            *cur++ = (byte)(scale * (*_in_ >> 6));
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x03));
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x03));
                            *cur++ = (byte)(scale * ((*_in_) & 0x03));
                        }
                        if ((k) > 0) *cur++ = (byte)(scale * (*_in_ >> 6));
                        if ((k) > 1) *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x03));
                        if ((k) > 2) *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x03));
                    }
                    else if (depth == 1)
                    {
                        for (k = (int)(x * img_n); (k) >= 8; k -= 8, ++_in_)
                        {
                            *cur++ = (byte)(scale * (*_in_ >> 7));
                            *cur++ = (byte)(scale * ((*_in_ >> 6) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 5) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 3) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 1) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_) & 0x01));
                        }
                        if ((k) > 0) *cur++ = (byte)(scale * (*_in_ >> 7));
                        if ((k) > 1) *cur++ = (byte)(scale * ((*_in_ >> 6) & 0x01));
                        if ((k) > 2) *cur++ = (byte)(scale * ((*_in_ >> 5) & 0x01));
                        if ((k) > 3) *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x01));
                        if ((k) > 4) *cur++ = (byte)(scale * ((*_in_ >> 3) & 0x01));
                        if ((k) > 5) *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x01));
                        if ((k) > 6) *cur++ = (byte)(scale * ((*_in_ >> 1) & 0x01));
                    }
                    if (img_n != out_n)
                    {
                        int q;
                        cur = a._out_ + stride * j;
                        if ((img_n) == 1)
                        {
                            for (q = (int)(x - 1); (q) >= 0; --q)
                            {
                                cur[q * 2 + 1] = 255;
                                cur[q * 2 + 0] = cur[q];
                            }
                        }
                        else
                        {
                            for (q = (int)(x - 1); (q) >= 0; --q)
                            {
                                cur[q * 4 + 3] = 255;
                                cur[q * 4 + 2] = cur[q * 3 + 2];
                                cur[q * 4 + 1] = cur[q * 3 + 1];
                                cur[q * 4 + 0] = cur[q * 3 + 0];
                            }
                        }
                    }
                }
            }
            else if (depth == (16))
            {
                byte* cur = a._out_;
                ushort* cur16 = (ushort*)(cur);
                for (i = 0; (i) < (x * y * out_n); ++i, cur16++, cur += 2)
                {
                    *cur16 = (ushort)((cur[0] << 8) | cur[1]);
                }
            }

            return 1;
        }

        public static int CreatePngImage(PngImage a, byte* image_data, uint image_data_len, int out_n,
            int depth, int color, int interlaced)
        {
            int bytes = depth == (16) ? 2 : 1;
            int out_bytes = out_n * bytes;
            byte* final;
            int p;
            if (interlaced == 0)
                return

                        CreateRawPngImage(a, image_data, image_data_len, out_n,
                            a._readCtx.Width,
                            a._readCtx.Height, depth, color);
            final = (byte*)(MAlloc_mad3(a._readCtx.Manager, (int)(a._readCtx.Width), (int)(a._readCtx.Height), out_bytes, 0));
            for (p = 0; (p) < 7; ++p)
            {
                int* xorig = stackalloc int[7];
                xorig[0] = 0;
                xorig[1] = 4;
                xorig[2] = 0;
                xorig[3] = 2;
                xorig[4] = 0;
                xorig[5] = 1;
                xorig[6] = 0;
                int* yorig = stackalloc int[7];
                yorig[0] = 0;
                yorig[1] = 0;
                yorig[2] = 4;
                yorig[3] = 0;
                yorig[4] = 2;
                yorig[5] = 0;
                yorig[6] = 1;
                int* xspc = stackalloc int[7];
                xspc[0] = 8;
                xspc[1] = 8;
                xspc[2] = 4;
                xspc[3] = 4;
                xspc[4] = 2;
                xspc[5] = 2;
                xspc[6] = 1;
                int* yspc = stackalloc int[7];
                yspc[0] = 8;
                yspc[1] = 8;
                yspc[2] = 8;
                yspc[3] = 4;
                yspc[4] = 4;
                yspc[5] = 2;
                yspc[6] = 2;
                int i;
                int j;
                int x;
                int y;
                x = (int)((a._readCtx.Width - xorig[p] + xspc[p] - 1) / xspc[p]);
                y = (int)((a._readCtx.Height - yorig[p] + yspc[p] - 1) / yspc[p]);
                if (((x) != 0) && ((y) != 0))
                {
                    uint img_len = (uint)(((((a._readCtx.SourceChannels * x * depth) + 7) >> 3) + 1) * y);
                    if (
                        CreateRawPngImage(a, image_data, image_data_len, out_n, (uint)(x),
                            (uint)(y),
                            depth, color) == 0)
                    {
                        a._readCtx.Manager.Free(final);
                        return 0;
                    }
                    for (j = 0; (j) < (y); ++j)
                    {
                        for (i = 0; (i) < (x); ++i)
                        {
                            int out_y = j * yspc[p] + yorig[p];
                            int out_x = i * xspc[p] + xorig[p];
                            MemCopy(
                                final + out_y * a._readCtx.Width * out_bytes + out_x * out_bytes,
                                a._out_ + (j * x + i) * out_bytes,
                                out_bytes);
                        }
                    }
                    a._readCtx.Manager.Free(a._out_);
                    image_data += img_len;
                    image_data_len -= img_len;
                }
            }
            a._out_ = final;
            return 1;
        }

        public static int ComputeTransparency(PngImage z, byte* tc, int out_n)
        {
            ReadContext s = z._readCtx;
            uint i;
            uint pixel_count = s.Width * s.Height;
            byte* p = z._out_;
            if ((out_n) == 2)
            {
                for (i = 0; (i) < (pixel_count); ++i)
                {
                    p[1] = (byte)((p[0]) == (tc[0]) ? 0 : 255);
                    p += 2;
                }
            }
            else
            {
                for (i = 0; (i) < (pixel_count); ++i)
                {
                    if ((((p[0]) == (tc[0])) && ((p[1]) == (tc[1]))) && ((p[2]) == (tc[2]))) p[3] = 0;
                    p += 4;
                }
            }

            return 1;
        }

        public static int ComputeTransparency16(PngImage z, ushort* tc, int out_n)
        {
            ReadContext s = z._readCtx;
            uint i;
            uint pixel_count = s.Width * s.Height;
            ushort* p = (ushort*)(z._out_);
            if ((out_n) == 2)
            {
                for (i = 0; (i) < (pixel_count); ++i)
                {
                    p[1] = (ushort)((p[0]) == (tc[0]) ? 0 : 65535);
                    p += 2;
                }
            }
            else
            {
                for (i = 0; (i) < (pixel_count); ++i)
                {
                    if ((((p[0]) == (tc[0])) && ((p[1]) == (tc[1]))) && ((p[2]) == (tc[2]))) p[3] = 0;
                    p += 4;
                }
            }

            return 1;
        }

        public static int ExpandPngPalette(PngImage a, byte* palette, int len, int pal_img_n)
        {
            uint i;
            uint pixel_count = a._readCtx.Width * a._readCtx.Height;
            byte* p;
            byte* temp_out;
            byte* orig = a._out_;
            p = (byte*)(MAlloc_mad2(a._readCtx.Manager, (int)pixel_count, pal_img_n, 0));
            if ((p) == null)
                return a._readCtx.Error("outofmem");
            temp_out = p;
            if ((pal_img_n) == 3)
            {
                for (i = 0; (i) < (pixel_count); ++i)
                {
                    int n = orig[i] * 4;
                    p[0] = palette[n];
                    p[1] = palette[n + 1];
                    p[2] = palette[n + 2];
                    p += 3;
                }
            }
            else
            {
                for (i = 0; (i) < (pixel_count); ++i)
                {
                    int n = orig[i] * 4;
                    p[0] = palette[n];
                    p[1] = palette[n + 1];
                    p[2] = palette[n + 2];
                    p[3] = palette[n + 3];
                    p += 4;
                }
            }

            a._readCtx.Manager.Free(a._out_);
            a._out_ = temp_out;
            return 1;
        }

        public static void SetUnpremultiplyOnLoad(int flag_true_if_should_unpremultiply)
        {
            UnpremultiplyOnLoad = flag_true_if_should_unpremultiply;
        }

        public static void ConvertIPhonePngToRgb(int flag_true_if_should_convert)
        {
            DeIPhoneFlag = flag_true_if_should_convert;
        }

        public static void DeIPhone(PngImage z)
        {
            ReadContext s = z._readCtx;
            uint i;
            uint pixel_count = s.Width * s.Height;
            byte* p = z._out_;
            if ((s.OutChannels) == 3)
            {
                for (i = 0; (i) < (pixel_count); ++i)
                {
                    byte t = p[0];
                    p[0] = p[2];
                    p[2] = t;
                    p += 3;
                }
            }
            else
            {
                if ((UnpremultiplyOnLoad) != 0)
                {
                    for (i = 0; (i) < (pixel_count); ++i)
                    {
                        byte a = p[3];
                        byte t = p[0];
                        if ((a) != 0)
                        {
                            byte half = (byte)(a / 2);
                            p[0] = (byte)((p[2] * 255 + half) / a);
                            p[1] = (byte)((p[1] * 255 + half) / a);
                            p[2] = (byte)((t * 255 + half) / a);
                        }
                        else
                        {
                            p[0] = p[2];
                            p[2] = t;
                        }
                        p += 4;
                    }
                }
                else
                {
                    for (i = 0; (i) < (pixel_count); ++i)
                    {
                        byte t = p[0];
                        p[0] = p[2];
                        p[2] = t;
                        p += 4;
                    }
                }
            }

        }

        public static int ParsePngFile(PngImage z, int scan, int req_comp)
        {
            byte* palette = stackalloc byte[1024];
            byte pal_img_n = 0;
            byte has_trans = 0;
            byte* tc = stackalloc byte[3];
            ushort* tc16 = stackalloc ushort[3];
            uint ioff = 0;
            uint idata_limit = 0;
            uint i;
            uint pal_len = 0;
            int first = 1;
            int k;
            int interlace = 0;
            int color = 0;
            int is_iphone = 0;
            ReadContext s = z._readCtx;
            z.expanded = null;
            z.idata = null;
            z._out_ = null;

            if (CheckPngHeader(s) == 0)
                return 0;

            if ((scan) == (STBI__SCAN_type))
                return 1;

            for (; ; )
            {
                PngChunk c = GetChunkHeader(s);
                switch (c.type)
                {
                    case ((('C') << 24) + (('g') << 16) + (('B') << 8) + ('I')):
                        is_iphone = 1;
                        Skip(s, (int)(c.length));
                        break;
                    case ((('I') << 24) + (('H') << 16) + (('D') << 8) + ('R')):
                        {
                            int comp;
                            int filter;
                            if (first == 0) return s.Error("multiple IHDR");
                            first = 0;
                            if (c.length != 13) return s.Error("bad IHDR len");
                            s.Width = Get32be(s);
                            if ((s.Width) > (1 << 24)) return s.Error("too large");
                            s.Height = Get32be(s);
                            if ((s.Height) > (1 << 24)) return s.Error("too large");
                            z.depth = GetByte(s);
                            if (((((z.depth != 1) && (z.depth != 2)) && (z.depth != 4)) && (z.depth != 8)) &&
                                (z.depth != 16))
                                return s.Error("1/2/4/8/16-bit only");
                            color = GetByte(s);
                            if (color > 6) return s.Error("bad ctype");
                            if ((color == 3) && ((z.depth) == (16))) return s.Error("bad ctype");
                            if (color == 3) pal_img_n = 3;
                            else if ((color & 1) != 0) return s.Error("bad ctype");
                            comp = GetByte(s);
                            if ((comp) != 0) return s.Error("bad comp method");
                            filter = GetByte(s);
                            if ((filter) != 0) return s.Error("bad filter method");
                            interlace = GetByte(s);
                            if ((interlace) > 1) return s.Error("bad interlace method");
                            if ((s.Width == 0) || (s.Height == 0)) return s.Error("0-pixel image");
                            if (pal_img_n == 0)
                            {
                                s.SourceChannels = ((color & 2) != 0 ? 3 : 1) + ((color & 4) != 0 ? 1 : 0);
                                if (((1 << 30) / s.Width / s.SourceChannels) < (s.Height)) return s.Error("too large");
                                if ((scan) == (STBI__SCAN_header)) return 1;
                            }
                            else
                            {
                                s.SourceChannels = 1;
                                if (((1 << 30) / s.Width / 4) < (s.Height)) return s.Error("too large");
                            }
                            break;
                        }
                    case ((('P') << 24) + (('L') << 16) + (('T') << 8) + ('E')):
                        {
                            if ((first) != 0) return s.Error("first not IHDR");
                            if ((c.length) > (256 * 3)) return s.Error("invalid PLTE");
                            pal_len = c.length / 3;
                            if (pal_len * 3 != c.length) return s.Error("invalid PLTE");
                            for (i = 0; (i) < (pal_len); ++i)
                            {
                                palette[i * 4 + 0] = GetByte(s);
                                palette[i * 4 + 1] = GetByte(s);
                                palette[i * 4 + 2] = GetByte(s);
                                palette[i * 4 + 3] = 255;
                            }
                            break;
                        }
                    case ((('t') << 24) + (('R') << 16) + (('N') << 8) + ('S')):
                        {
                            if ((first) != 0) return s.Error("first not IHDR");
                            if ((z.idata) != null) return s.Error("tRNS after IDAT");
                            if ((pal_img_n) != 0)
                            {
                                if ((scan) == (STBI__SCAN_header))
                                {
                                    s.SourceChannels = 4;
                                    return 1;
                                }
                                if ((pal_len) == 0) return s.Error("tRNS before PLTE");
                                if ((c.length) > (pal_len)) return s.Error("bad tRNS len");
                                pal_img_n = 4;
                                for (i = 0; (i) < (c.length); ++i)
                                {
                                    palette[i * 4 + 3] = GetByte(s);
                                }
                            }
                            else
                            {
                                if ((s.SourceChannels & 1) == 0) return s.Error("tRNS with alpha");
                                if (c.length != (uint)(s.SourceChannels) * 2) return s.Error("bad tRNS len");
                                has_trans = 1;
                                if ((z.depth) == (16))
                                {
                                    for (k = 0; (k) < (s.SourceChannels); ++k)
                                    {
                                        tc16[k] = ((ushort)(Get16be(s)));
                                    }
                                }
                                else
                                {
                                    for (k = 0; (k) < (s.SourceChannels); ++k)
                                    {
                                        tc[k] = (byte)((byte)(Get16be(s) & 255) * DepthScaleTable[z.depth]);
                                    }
                                }
                            }
                            break;
                        }
                    case ((('I') << 24) + (('D') << 16) + (('A') << 8) + ('T')):
                        {
                            if ((first) != 0) return s.Error("first not IHDR");
                            if (((pal_img_n) != 0) && (pal_len == 0)) return s.Error("no PLTE");
                            if ((scan) == (STBI__SCAN_header))
                            {
                                s.SourceChannels = pal_img_n;
                                return 1;
                            }
                            if (((int)(ioff + c.length)) < ((int)(ioff))) return 0;
                            if ((ioff + c.length) > (idata_limit))
                            {
                                uint idata_limit_old = idata_limit;
                                byte* p;
                                if ((idata_limit) == 0) idata_limit = (c.length) > (4096) ? c.length : 4096;
                                while ((ioff + c.length) > (idata_limit))
                                {
                                    idata_limit *= 2;
                                }
                                p = (byte*)(s.Manager.ReAlloc(z.idata, idata_limit));
                                if ((p) == null) return s.Error("outofmem");
                                z.idata = p;
                            }
                            if (GetN(s, z.idata + ioff, (int)(c.length)) == 0) return s.Error("outofdata");
                            ioff += c.length;
                            break;
                        }
                    case ((('I') << 24) + (('E') << 16) + (('N') << 8) + ('D')):
                        {
                            uint raw_len;
                            uint bpl;
                            if ((first) != 0) return s.Error("first not IHDR");
                            if (scan != STBI__SCAN_load) return 1;
                            if ((z.idata) == null) return s.Error("no IDAT");
                            bpl = (uint)((s.Width * z.depth + 7) / 8);
                            raw_len = (uint)(bpl * s.Height * s.SourceChannels + s.Height);
                            z.expanded = (byte*) (ZlibDecodeMAlloc_GuessSizeHeaderFlag(s.Manager, s.ErrorCtx,
                                (sbyte*)(z.idata), (int)(ioff), (int)(raw_len), (int*)(&raw_len), is_iphone != 0 ? 0 : 1));
                            if ((z.expanded) == null)
                                return 0;
                            s.Manager.Free(z.idata);
                            z.idata = null;
                            if (((((req_comp) == (s.SourceChannels + 1)) && (req_comp != 3)) && (pal_img_n == 0)) ||
                                ((has_trans) != 0))
                                s.OutChannels = s.SourceChannels + 1;
                            else s.OutChannels = s.SourceChannels;
                            if (
                                CreatePngImage(z, z.expanded, raw_len, s.OutChannels, z.depth,
                                    color,
                                    interlace) == 0) return 0;
                            if ((has_trans) != 0)
                            {
                                if ((z.depth) == (16))
                                {
                                    if (ComputeTransparency16(z, tc16, s.OutChannels) == 0) return 0;
                                }
                                else
                                {
                                    if (ComputeTransparency(z, tc, s.OutChannels) == 0) return 0;
                                }
                            }
                            if ((((is_iphone) != 0) && ((DeIPhoneFlag) != 0)) && ((s.OutChannels) > 2))
                                DeIPhone(z);
                            if ((pal_img_n) != 0)
                            {
                                s.SourceChannels = pal_img_n;
                                s.OutChannels = pal_img_n;
                                if ((req_comp) >= 3) s.OutChannels = req_comp;
                                if (ExpandPngPalette(z, palette, (int)(pal_len), s.OutChannels) == 0)
                                    return 0;
                            }
                            else if ((has_trans) != 0)
                            {
                                ++s.SourceChannels;
                            }
                            s.Manager.Free(z.expanded);
                            z.expanded = null;
                            return 1;
                        }
                    default:
                        if ((first) != 0) return s.Error("first not IHDR");
                        if ((c.type & (1 << 29)) == 0)
                        {
                            string invalid_chunk = "XXXX PNG chunk not known";
                            return s.Error(invalid_chunk);
                        }
                        Skip(s, (int)(c.length));
                        break;
                }
                Get32be(s);
            }
        }

        public static void* LoadPngData(PngImage p, int* x, int* y, int* n, int req_comp, ResultInfo* ri)
        {
            ReadContext s = p._readCtx;

            void* result = null;
            if (((req_comp) < 0) || ((req_comp) > 4))
                return (s.Error("bad req_comp")) != 0 ? (byte*)null : null;

            if (ParsePngFile(p, STBI__SCAN_load, req_comp) != 0)
            {
                if ((p.depth) < 8) ri->bits_per_channel = 8;
                else ri->bits_per_channel = p.depth;
                result = p._out_;
                p._out_ = null;
                if (((req_comp) != 0) && (req_comp != s.OutChannels))
                {
                    if ((ri->bits_per_channel) == 8)
                        result = ConvertToFormat8(
                            s.Manager, s.ErrorCtx, (byte*)(result), s.OutChannels, req_comp, s.Width, s.Height);
                    else
                        result = ConvertToFormat16(
                            s.Manager, s.ErrorCtx, (ushort*)(result), s.OutChannels, req_comp, s.Width, s.Height);

                    s.OutChannels = req_comp;
                    if ((result) == null) return result;
                }
                *x = (int)(s.Width);
                *y = (int)(s.Height);

                if (n != null)
                    *n = s.SourceChannels;
            }

            s.Manager.Free(p._out_);
            p._out_ = null;

            s.Manager.Free(p.expanded);
            p.expanded = null;

            s.Manager.Free(p.idata);
            p.idata = null;

            return result;
        }

        public static void* LoadPng(ReadContext s, int* x, int* y, int* comp, int req_comp, ResultInfo* ri)
        {
            PngImage p = new PngImage(s);
            return LoadPngData(p, x, y, comp, req_comp, ri);
        }

        public static int TestForPng(ReadContext s)
        {
            int r = CheckPngHeader(s);
            Rewind(s);
            return r;
        }

        public static int GetRawPngInfo(PngImage p, int* x, int* y, int* comp)
        {
            if (ParsePngFile(p, STBI__SCAN_header, 0) == 0)
            {
                Rewind(p._readCtx);
                return 0;
            }

            if ((x) != null) *x = (int)(p._readCtx.Width);
            if ((y) != null) *y = (int)(p._readCtx.Height);
            if ((comp) != null) *comp = p._readCtx.SourceChannels;
            return 1;
        }

        public static int GetPngInfo(ReadContext s, int* x, int* y, int* comp)
        {
            PngImage p = new PngImage(s);
            return GetRawPngInfo(p, x, y, comp);
        }

        public static int RawTestForBmp(ReadContext s)
        {
            if (GetByte(s) != 'B')
                return 0;
            if (GetByte(s) != 'M')
                return 0;

            Get32le(s);
            Get16le(s);
            Get16le(s);
            Get32le(s);
            int sz = (int)(Get32le(s));
            return (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124) ? 1 : 0;
        }

        public static int TestForBmp(ReadContext s)
        {
            int r = RawTestForBmp(s);
            Rewind(s);
            return r;
        }

        public static int HighBit(uint z)
        {
            int n = 0;
            if ((z) == 0) return -1;
            if ((z) >= (0x10000))
            {
                n += 16;
                z >>= 16;
            }

            if ((z) >= (0x00100))
            {
                n += 8;
                z >>= 8;
            }

            if ((z) >= (0x00010))
            {
                n += 4;
                z >>= 4;
            }

            if ((z) >= (0x00004))
            {
                n += 2;
                z >>= 2;
            }

            if ((z) >= (0x00002))
            {
                n += 1;
                z >>= 1;
            }

            return n;
        }

        public static int BitCount(uint a)
        {
            a = (a & 0x55555555) + ((a >> 1) & 0x55555555);
            a = (a & 0x33333333) + ((a >> 2) & 0x33333333);
            a = (a + (a >> 4)) & 0x0f0f0f0f;
            a = a + (a >> 8);
            a = a + (a >> 16);
            return (int)(a & 0xff);
        }

        public static int ShiftSigned(int v, int shift, int bits)
        {
            int result;
            int z = 0;
            if ((shift) < 0) v <<= -shift;
            else v >>= shift;
            result = v;
            z = bits;
            while ((z) < 8)
            {
                result += v >> z;
                z += bits;
            }
            return result;
        }

        public static void* ParseBmpHeader(ReadContext s, BmpInfo* info)
        {
            int hsz;
            if ((GetByte(s) != 'B') || (GetByte(s) != 'M'))
                return (s.Error("not BMP")) != 0 ? (byte*)null : null;
            Get32le(s);
            Get16le(s);
            Get16le(s);
            info->offset = (int)(Get32le(s));
            info->hsz = hsz = (int)(Get32le(s));
            info->mr = info->mg = info->mb = info->ma = 0;

            if (((((hsz != 12) && (hsz != 40)) && (hsz != 56)) && (hsz != 108)) && (hsz != 124))
                return (s.Error("unknown BMP")) != 0 ? (byte*)null : null;

            if ((hsz) == 12)
            {
                s.Width = (uint)(Get16le(s));
                s.Height = (uint)(Get16le(s));
            }
            else
            {
                s.Width = Get32le(s);
                s.Height = Get32le(s);
            }

            if (Get16le(s) != 1)
                return (s.Error("bad BMP")) != 0 ? (byte*)null : null;

            info->bpp = Get16le(s);
            if ((info->bpp) == 1)
                return (s.Error("monochrome")) != 0 ? (byte*)null : null;

            if (hsz != 12)
            {
                int compress = (int)(Get32le(s));
                if (((compress) == 1) || ((compress) == 2))
                    return (s.Error("BMP RLE")) != 0 ? (byte*)null : null;
                Get32le(s);
                Get32le(s);
                Get32le(s);
                Get32le(s);
                Get32le(s);
                if (((hsz) == (40)) || ((hsz) == (56)))
                {
                    if ((hsz) == (56))
                    {
                        Get32le(s);
                        Get32le(s);
                        Get32le(s);
                        Get32le(s);
                    }
                    if (((info->bpp) == (16)) || ((info->bpp) == (32)))
                    {
                        if ((compress) == 0)
                        {
                            if ((info->bpp) == (32))
                            {
                                info->mr = 0xffu << 16;
                                info->mg = 0xffu << 8;
                                info->mb = 0xffu << 0;
                                info->ma = 0xffu << 24;
                                info->all_a = 0;
                            }
                            else
                            {
                                info->mr = 31u << 10;
                                info->mg = 31u << 5;
                                info->mb = 31u << 0;
                            }
                        }
                        else if ((compress) == 3)
                        {
                            info->mr = Get32le(s);
                            info->mg = Get32le(s);
                            info->mb = Get32le(s);
                            if (((info->mr) == (info->mg)) && ((info->mg) == (info->mb)))
                            {
                                return (s.Error("bad BMP")) != 0 ? (byte*)null : null;
                            }
                        }
                        else
                            return (s.Error("bad BMP")) != 0 ? (byte*)null : null;
                    }
                }
                else
                {
                    int i;
                    if ((hsz != 108) && (hsz != 124))
                        return (s.Error("bad BMP")) != 0 ? (byte*)null : null;
                    info->mr = Get32le(s);
                    info->mg = Get32le(s);
                    info->mb = Get32le(s);
                    info->ma = Get32le(s);
                    Get32le(s);
                    for (i = 0; (i) < 12; ++i)
                    {
                        Get32le(s);
                    }
                    if ((hsz) == (124))
                    {
                        Get32le(s);
                        Get32le(s);
                        Get32le(s);
                        Get32le(s);
                    }
                }
            }

            return (void*)1;
        }
        
        public static int GetBmpInfo(ReadContext s, int* x, int* y, int* comp)
        {
            BmpInfo data = new BmpInfo();
            if (ParseBmpHeader(s, &data) == null)
                return 0;

            *x = (int)s.Width;
            *y = (int)s.Height;
            *comp = data.ma != 0 ? 4 : 3;

            Rewind(s);
            return 1;
        }

        public static void* LoadBmp(ReadContext s, int* x, int* y, int* comp, int req_comp, ResultInfo* ri)
        {
            byte* _out_;
            uint mr = 0;
            uint mg = 0;
            uint mb = 0;
            uint ma = 0;
            uint all_a;
            byte* pal = stackalloc byte[256 * 4];
            int psize = 0;
            int i;
            int j;
            int width;
            int flip_vertically;
            int pad;
            int target;
            BmpInfo info = new BmpInfo
            {
                all_a = 255
            };

            if ((ParseBmpHeader(s, &info)) == null)
                return null;

            flip_vertically = ((int)(s.Height)) > 0 ? 1 : 0;
            s.Height = (uint)(Abs((int)(s.Height)));
            mr = info.mr;
            mg = info.mg;
            mb = info.mb;
            ma = info.ma;
            all_a = info.all_a;
            if ((info.hsz) == 12)
            {
                if ((info.bpp) < (24)) psize = (info.offset - 14 - 24) / 3;
            }
            else
            {
                if ((info.bpp) < (16)) psize = (info.offset - 14 - info.hsz) >> 2;
            }

            s.SourceChannels = (ma) != 0 ? 4 : 3;
            if (((req_comp) != 0) && ((req_comp) >= 3))
                target = req_comp;
            else
                target = s.SourceChannels;
            if (ValidSizes_mad3(target, (int)(s.Width), (int)(s.Height), 0) == 0)
                return (s.Error("too large")) != 0 ? (byte*)null : null;
            _out_ = (byte*)(MAlloc_mad3(s.Manager, target, (int)(s.Width), (int)(s.Height), 0));
            if (_out_ == null) return (s.Error("outofmem")) != 0 ? (byte*)null : null;
            if ((info.bpp) < (16))
            {
                int z = 0;
                if (((psize) == 0) || ((psize) > (256)))
                {
                    s.Manager.Free(_out_);
                    return (s.Error("invalid")) != 0 ? (byte*)null : null;
                }
                for (i = 0; (i) < (psize); ++i)
                {
                    pal[i * 4 + 2] = GetByte(s);
                    pal[i * 4 + 1] = GetByte(s);
                    pal[i * 4 + 0] = GetByte(s);
                    if (info.hsz != 12) GetByte(s);
                    pal[i * 4 + 3] = 255;
                }
                Skip(s, info.offset - 14 - info.hsz - psize * ((info.hsz) == 12 ? 3 : 4));
                if ((info.bpp) == 4) width = (int)((s.Width + 1) >> 1);
                else if ((info.bpp) == 8) width = (int)(s.Width);
                else
                {
                    s.Manager.Free(_out_);
                    return (s.Error("bad bpp")) != 0 ? (byte*)null : null;
                }
                pad = (-width) & 3;
                for (j = 0; (j) < ((int)(s.Height)); ++j)
                {
                    for (i = 0; (i) < ((int)(s.Width)); i += 2)
                    {
                        int v = GetByte(s);
                        int v2 = 0;
                        if ((info.bpp) == 4)
                        {
                            v2 = v & 15;
                            v >>= 4;
                        }
                        _out_[z++] = pal[v * 4 + 0];
                        _out_[z++] = pal[v * 4 + 1];
                        _out_[z++] = pal[v * 4 + 2];
                        if ((target) == 4) _out_[z++] = 255;
                        if ((i + 1) == ((int)(s.Width))) break;
                        v = ((info.bpp) == 8) ? GetByte(s) : v2;
                        _out_[z++] = pal[v * 4 + 0];
                        _out_[z++] = pal[v * 4 + 1];
                        _out_[z++] = pal[v * 4 + 2];
                        if ((target) == 4) _out_[z++] = 255;
                    }
                    Skip(s, pad);
                }
            }
            else
            {
                int rshift = 0;
                int gshift = 0;
                int bshift = 0;
                int ashift = 0;
                int rcount = 0;
                int gcount = 0;
                int bcount = 0;
                int acount = 0;
                int z = 0;
                int easy = 0;
                Skip(s, info.offset - 14 - info.hsz);
                if ((info.bpp) == (24)) width = (int)(3 * s.Width);
                else if ((info.bpp) == (16)) width = (int)(2 * s.Width);
                else width = 0;
                pad = (-width) & 3;
                if ((info.bpp) == (24))
                {
                    easy = 1;
                }
                else if ((info.bpp) == (32))
                {
                    if (((((mb) == (0xff)) && ((mg) == (0xff00))) && ((mr) == (0x00ff0000))) && ((ma) == (0xff000000)))
                        easy = 2;
                }
                if (easy == 0)
                {
                    if (((mr == 0) || (mg == 0)) || (mb == 0))
                    {
                        s.Manager.Free(_out_);
                        return (s.Error("bad masks")) != 0 ? (byte*)null : null;
                    }
                    rshift = HighBit(mr) - 7;
                    rcount = BitCount(mr);
                    gshift = HighBit(mg) - 7;
                    gcount = BitCount(mg);
                    bshift = HighBit(mb) - 7;
                    bcount = BitCount(mb);
                    ashift = HighBit(ma) - 7;
                    acount = BitCount(ma);
                }
                for (j = 0; (j) < ((int)(s.Height)); ++j)
                {
                    if ((easy) != 0)
                    {
                        for (i = 0; (i) < ((int)(s.Width)); ++i)
                        {
                            byte a;
                            _out_[z + 2] = GetByte(s);
                            _out_[z + 1] = GetByte(s);
                            _out_[z + 0] = GetByte(s);
                            z += 3;
                            a = (byte)((easy) == 2 ? GetByte(s) : 255);
                            all_a |= a;
                            if ((target) == 4) _out_[z++] = a;
                        }
                    }
                    else
                    {
                        int bpp = info.bpp;
                        for (i = 0; (i) < ((int)(s.Width)); ++i)
                        {
                            uint v = (bpp) == (16) ? (uint)(Get16le(s)) : Get32le(s);
                            int a;
                            _out_[z++] =
                                ((byte)((ShiftSigned((int)(v & mr), rshift, rcount)) & 255));
                            _out_[z++] =
                                ((byte)((ShiftSigned((int)(v & mg), gshift, gcount)) & 255));
                            _out_[z++] =
                                ((byte)((ShiftSigned((int)(v & mb), bshift, bcount)) & 255));
                            a =

                                    (ma) != 0 ? ShiftSigned((int)(v & ma), ashift, acount) : 255;
                            all_a |= (uint)(a);
                            if ((target) == 4) _out_[z++] = ((byte)((a) & 255));
                        }
                    }
                    Skip(s, pad);
                }
            }

            if (((target) == 4) && ((all_a) == 0))
                for (i = (int)(4 * s.Width * s.Height - 1); (i) >= 0; i -= 4)
                {
                    _out_[i] = 255;
                }
            if ((flip_vertically) != 0)
            {
                byte t;
                for (j = 0; (j) < ((int)(s.Height) >> 1); ++j)
                {
                    byte* p1 = _out_ + j * s.Width * target;
                    byte* p2 = _out_ + (s.Height - 1 - j) * s.Width * target;
                    for (i = 0; (i) < ((int)(s.Width) * target); ++i)
                    {
                        t = p1[i];
                        p1[i] = p2[i];
                        p2[i] = t;
                    }
                }
            }

            if (((req_comp) != 0) && (req_comp != target))
            {
                _out_ = ConvertToFormat8(s.Manager, s.ErrorCtx, _out_, target, req_comp, s.Width, s.Height);
                if ((_out_) == null)
                    return _out_;
            }

            *x = (int)(s.Width);
            *y = (int)(s.Height);
            if (comp != null)
                *comp = s.SourceChannels;
            return _out_;
        }

        public static int GetTgaComp(int bits_per_pixel, int is_grey, int* is_rgb16)
        {
            if ((is_rgb16) != null) *is_rgb16 = 0;
            switch (bits_per_pixel)
            {
                case 8:
                    return STBI_grey;
                case 15:
                case 16:
                    if (((bits_per_pixel) == (16)) && ((is_grey) != 0)) return STBI_grey_alpha;
                    if ((is_rgb16) != null) *is_rgb16 = 1;
                    return STBI_rgb;
                case 24:
                case 32:
                    return bits_per_pixel / 8;
                default:
                    return 0;
            }

        }

        public static int GetTgaInfo(ReadContext s, int* x, int* y, int* comp)
        {
            int tga_w;
            int tga_h;
            int tga_comp;
            int tga_image_type;
            int tga_bits_per_pixel;
            int tga_colormap_bpp;
            int sz;
            int tga_colormap_type;
            GetByte(s);
            tga_colormap_type = GetByte(s);
            if ((tga_colormap_type) > 1)
            {
                Rewind(s);
                return 0;
            }

            tga_image_type = GetByte(s);
            if ((tga_colormap_type) == 1)
            {
                if ((tga_image_type != 1) && (tga_image_type != 9))
                {
                    Rewind(s);
                    return 0;
                }
                Skip(s, 4);
                sz = GetByte(s);
                if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32))
                {
                    Rewind(s);
                    return 0;
                }
                Skip(s, 4);
                tga_colormap_bpp = sz;
            }
            else
            {
                if ((((tga_image_type != 2) && (tga_image_type != 3)) && (tga_image_type != 10)) &&
                    (tga_image_type != 11))
                {
                    Rewind(s);
                    return 0;
                }
                Skip(s, 9);
                tga_colormap_bpp = 0;
            }

            tga_w = Get16le(s);
            if ((tga_w) < 1)
            {
                Rewind(s);
                return 0;
            }

            tga_h = Get16le(s);
            if ((tga_h) < 1)
            {
                Rewind(s);
                return 0;
            }

            tga_bits_per_pixel = GetByte(s);
            GetByte(s);
            if (tga_colormap_bpp != 0)
            {
                if ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16))
                {
                    Rewind(s);
                    return 0;
                }
                tga_comp = GetTgaComp(tga_colormap_bpp, 0, null);
            }
            else
            {
                tga_comp =

                        GetTgaComp(tga_bits_per_pixel,
                            (((tga_image_type) == 3)) || (((tga_image_type) == 11)) ? 1 : 0, null);
            }

            if (tga_comp == 0)
            {
                Rewind(s);
                return 0;
            }

            if ((x) != null) *x = tga_w;
            if ((y) != null) *y = tga_h;
            if ((comp) != null) *comp = tga_comp;
            return 1;
        }

        public static int TestForTga(ReadContext s)
        {
            int res = 0;
            int sz;
            int tga_color_type;
            GetByte(s);
            tga_color_type = GetByte(s);
            if ((tga_color_type) > 1) goto errorEnd;
            sz = GetByte(s);
            if ((tga_color_type) == 1)
            {
                if ((sz != 1) && (sz != 9)) goto errorEnd;
                Skip(s, 4);
                sz = GetByte(s);
                if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32)) goto errorEnd;
                Skip(s, 4);
            }
            else
            {
                if ((((sz != 2) && (sz != 3)) && (sz != 10)) && (sz != 11)) goto errorEnd;
                Skip(s, 9);
            }

            if ((Get16le(s)) < 1) goto errorEnd;
            if ((Get16le(s)) < 1) goto errorEnd;
            sz = GetByte(s);
            if ((((tga_color_type) == 1) && (sz != 8)) && (sz != 16)) goto errorEnd;
            if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32)) goto errorEnd;
            res = 1;
            errorEnd:
            ;
            Rewind(s);
            return res;
        }

        public static void ReadRgb16Tga(ReadContext s, byte* _out_)
        {
            ushort px = (ushort)(Get16le(s));
            ushort fiveBitMask = 31;
            int r = (px >> 10) & fiveBitMask;
            int g = (px >> 5) & fiveBitMask;
            int b = px & fiveBitMask;
            _out_[0] = ((byte)((r * 255) / 31));
            _out_[1] = ((byte)((g * 255) / 31));
            _out_[2] = ((byte)((b * 255) / 31));
        }

        public static void* LoadTga(ReadContext s, int* x, int* y, int* comp, int req_comp, ResultInfo* ri)
        {
            int tga_offset = GetByte(s);
            int tga_indexed = GetByte(s);
            int tga_image_type = GetByte(s);
            int tga_is_RLE = 0;
            int tga_palette_start = Get16le(s);
            int tga_palette_len = Get16le(s);
            int tga_palette_bits = GetByte(s);
            int tga_x_origin = Get16le(s);
            int tga_y_origin = Get16le(s);
            int tga_width = Get16le(s);
            int tga_height = Get16le(s);
            int tga_bits_per_pixel = GetByte(s);
            int tga_comp;
            int tga_rgb16 = 0;
            int tga_inverted = GetByte(s);
            byte* tga_data;
            byte* tga_palette = null;
            int i;
            int j;
            byte* raw_data = stackalloc byte[4];
            raw_data[0] = 0;

            int RLE_count = 0;
            int RLE_repeating = 0;
            int read_next_pixel = 1;
            if ((tga_image_type) >= 8)
            {
                tga_image_type -= 8;
                tga_is_RLE = 1;
            }

            tga_inverted = 1 - ((tga_inverted >> 5) & 1);
            if ((tga_indexed) != 0)
                tga_comp = GetTgaComp(tga_palette_bits, 0, &tga_rgb16);
            else
                tga_comp =
                    GetTgaComp(tga_bits_per_pixel, (tga_image_type) == 3 ? 1 : 0, &tga_rgb16);
            if (tga_comp == 0) return (s.Error("bad format")) != 0 ? (byte*)null : null;
            *x = tga_width;
            *y = tga_height;
            if ((comp) != null) *comp = tga_comp;
            if (ValidSizes_mad3(tga_width, tga_height, tga_comp, 0) == 0)
                return (s.Error("too large")) != 0 ? (byte*)null : null;
            tga_data = (byte*)(MAlloc_mad3(s.Manager, tga_width, tga_height, tga_comp, 0));
            if (tga_data == null) return (s.Error("outofmem")) != 0 ? (byte*)null : null;
            Skip(s, tga_offset);
            if (((tga_indexed == 0) && (tga_is_RLE == 0)) && (tga_rgb16 == 0))
            {
                for (i = 0; (i) < (tga_height); ++i)
                {
                    int row = (tga_inverted) != 0 ? tga_height - i - 1 : i;
                    byte* tga_row = tga_data + row * tga_width * tga_comp;
                    GetN(s, tga_row, tga_width * tga_comp);
                }
            }
            else
            {
                if ((tga_indexed) != 0)
                {
                    Skip(s, tga_palette_start);
                    tga_palette = (byte*)(MAlloc_mad2(s.Manager, tga_palette_len, tga_comp, 0));
                    if (tga_palette == null)
                    {
                        s.Manager.Free(tga_data);
                        return (s.Error("outofmem")) != 0 ? (byte*)null : null;
                    }
                    if ((tga_rgb16) != 0)
                    {
                        byte* pal_entry = tga_palette;
                        for (i = 0; (i) < (tga_palette_len); ++i)
                        {
                            ReadRgb16Tga(s, pal_entry);
                            pal_entry += tga_comp;
                        }
                    }
                    else if (GetN(s, tga_palette, tga_palette_len * tga_comp) == 0)
                    {
                        s.Manager.Free(tga_data);
                        s.Manager.Free(tga_palette);
                        return (s.Error("bad palette")) != 0 ? (byte*)null : null;
                    }
                }
                for (i = 0; (i) < (tga_width * tga_height); ++i)
                {
                    if ((tga_is_RLE) != 0)
                    {
                        if ((RLE_count) == 0)
                        {
                            int RLE_cmd = GetByte(s);
                            RLE_count = 1 + (RLE_cmd & 127);
                            RLE_repeating = RLE_cmd >> 7;
                            read_next_pixel = 1;
                        }
                        else if (RLE_repeating == 0)
                        {
                            read_next_pixel = 1;
                        }
                    }
                    else
                    {
                        read_next_pixel = 1;
                    }
                    if ((read_next_pixel) != 0)
                    {
                        if ((tga_indexed) != 0)
                        {
                            int pal_idx = ((tga_bits_per_pixel) == 8) ? GetByte(s) : Get16le(s);
                            if ((pal_idx) >= (tga_palette_len))
                            {
                                pal_idx = 0;
                            }
                            pal_idx *= tga_comp;
                            for (j = 0; (j) < (tga_comp); ++j)
                            {
                                raw_data[j] = tga_palette[pal_idx + j];
                            }
                        }
                        else if ((tga_rgb16) != 0)
                        {
                            ReadRgb16Tga(s, raw_data);
                        }
                        else
                        {
                            for (j = 0; (j) < (tga_comp); ++j)
                            {
                                raw_data[j] = GetByte(s);
                            }
                        }
                        read_next_pixel = 0;
                    }
                    for (j = 0; (j) < (tga_comp); ++j)
                    {
                        tga_data[i * tga_comp + j] = raw_data[j];
                    }
                    --RLE_count;
                }
                if ((tga_inverted) != 0)
                {
                    for (j = 0; (j * 2) < (tga_height); ++j)
                    {
                        int index1 = j * tga_width * tga_comp;
                        int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
                        for (i = tga_width * tga_comp; (i) > 0; --i)
                        {
                            byte temp = tga_data[index1];
                            tga_data[index1] = tga_data[index2];
                            tga_data[index2] = temp;
                            ++index1;
                            ++index2;
                        }
                    }
                }
                if (tga_palette != null)
                {
                    s.Manager.Free(tga_palette);
                }
            }

            if (((tga_comp) >= 3) && (tga_rgb16 == 0))
            {
                byte* tga_pixel = tga_data;
                for (i = 0; (i) < (tga_width * tga_height); ++i)
                {
                    byte temp = tga_pixel[0];
                    tga_pixel[0] = tga_pixel[2];
                    tga_pixel[2] = temp;
                    tga_pixel += tga_comp;
                }
            }

            if (((req_comp) != 0) && (req_comp != tga_comp))
                tga_data = ConvertToFormat8(s.Manager, s.ErrorCtx, tga_data,
                    tga_comp, req_comp, (uint)tga_width, (uint)tga_height);

            tga_palette_start = tga_palette_len = tga_palette_bits = tga_x_origin = tga_y_origin = 0;
            return tga_data;
        }

        public static int RawTestForGif(ReadContext s)
        {
            if (GetByte(s) != 'G' || GetByte(s) != 'I' || GetByte(s) != 'F' || GetByte(s) != '8')
                return 0;

            int sz = GetByte(s);
            if ((sz != '9') && (sz != '7'))
                return 0;

            if (GetByte(s) != 'a')
                return 0;

            return 1;
        }

        public static int TestForGif(ReadContext s)
        {
            int r = RawTestForGif(s);
            Rewind(s);
            return r;
        }

        public static int ParseGifHeader(ReadContext s, GifImage g, int* comp, int is_info)
        {
            if ((((GetByte(s) != 'G') || (GetByte(s) != 'I')) || (GetByte(s) != 'F')) || (GetByte(s) != '8'))
                return s.Error("not GIF");
            
            byte version = GetByte(s);
            if ((version != '7') && (version != '9'))
                return s.Error("not GIF");

            if (GetByte(s) != 'a')
                return s.Error("not GIF");

            g.w = Get16le(s);
            g.h = Get16le(s);
            g.flags = GetByte(s);
            g.bgindex = GetByte(s);
            g.ratio = GetByte(s);
            g.transparent = -1;

            if (comp != null)
                *comp = 4;

            if ((is_info) != 0)
                return 1;

            if ((g.flags & 0x80) != 0)
                GifParseColortable(s, g.pal, 2 << (g.flags & 7), -1);

            return 1;
        }

        public static int GetGifInfo(ReadContext s, int* x, int* y, int* comp)
        {
            GifImage g = new GifImage();
            if (ParseGifHeader(s, g, comp, 1) == 0)
            {
                Rewind(s);
                return 0;
            }

            if ((x) != null)
                *x = g.w;

            if ((y) != null)
                *y = g.h;

            return 1;
        }

        public static void GetGifCode(GifImage g, ushort code)
        {
            GifLzw* gCodesP = (GifLzw*)g.codes;

            if ((gCodesP[code].Prefix) >= 0)
                GetGifCode(g, (ushort)(gCodesP[code].Prefix));

            if ((g.cur_y) >= (g.max_y))
                return;

            byte* p = &g._out_[g.cur_x + g.cur_y];
            byte* c = &g.color_table[gCodesP[code].Suffix * 4];

            if ((c[3]) >= (128))
            {
                p[0] = c[2];
                p[1] = c[1];
                p[2] = c[0];
                p[3] = c[3];
            }

            g.cur_x += 4;
            if ((g.cur_x) >= (g.max_x))
            {
                g.cur_x = g.start_x;
                g.cur_y += g.step;
                while (((g.cur_y) >= (g.max_y)) && ((g.parse) > 0))
                {
                    g.step = (1 << g.parse) * g.line_size;
                    g.cur_y = g.start_y + (g.step >> 1);
                    --g.parse;
                }
            }
        }

        public static byte* ProcessGifRaster(ReadContext s, GifImage g)
        {
            byte lzw_cs = GetByte(s);
            if (lzw_cs > 12)
                return null;
            
            int clear = 1 << lzw_cs;
            uint first = 1;
            int codesize = lzw_cs + 1;
            int codemask = (1 << codesize) - 1;
            int bits = 0;
            int valid_bits = 0;
            for (int init_code = 0; init_code < clear; init_code++)
            {
                ((GifLzw*)(g.codes))[init_code].Prefix = -1;
                ((GifLzw*)(g.codes))[init_code].First = ((byte)(init_code));
                ((GifLzw*)(g.codes))[init_code].Suffix = ((byte)(init_code));
            }
            int avail = clear + 2;
            int oldcode = -1;

            int len = 0;
            for (; ; )
            {
                if ((valid_bits) < (codesize))
                {
                    if ((len) == 0)
                    {
                        len = GetByte(s);
                        if ((len) == 0) return g._out_;
                    }
                    --len;
                    bits |= GetByte(s) << valid_bits;
                    valid_bits += 8;
                }
                else
                {
                    int code = bits & codemask;
                    bits >>= codesize;
                    valid_bits -= codesize;
                    if ((code) == (clear))
                    {
                        codesize = lzw_cs + 1;
                        codemask = (1 << codesize) - 1;
                        avail = clear + 2;
                        oldcode = -1;
                        first = 0;
                    }
                    else if ((code) == (clear + 1))
                    {
                        Skip(s, len);
                        while ((len = GetByte(s)) > 0)
                        {
                            Skip(s, len);
                        }
                        return g._out_;
                    }
                    else if (code <= avail)
                    {
                        if ((first) != 0)
                            return (s.Error("no clear code")) != 0 ? (byte*)null : null;
                        if ((oldcode) >= 0)
                        {
                            GifLzw* p = (GifLzw*)g.codes + avail++;
                            if ((avail) > (4096))
                                return (s.Error("too many codes")) != 0 ? (byte*)null : null;
                            
                            GifLzw* gCodesP = (GifLzw*)g.codes;

                            p->Prefix = ((short)(oldcode));
                            p->First = gCodesP[oldcode].First;
                            p->Suffix = ((code) == (avail)) ? p->First : gCodesP[code].First;
                        }
                        else if ((code) == (avail))
                            return (s.Error("illegal code in raster")) != 0 ? (byte*)null : null;
                        GetGifCode(g, (ushort)(code));
                        if (((avail & codemask) == 0) && (avail <= 0x0FFF))
                        {
                            codesize++;
                            codemask = (1 << codesize) - 1;
                        }
                        oldcode = code;
                    }
                    else
                    {
                        return (s.Error("illegal code in raster")) != 0 ? (byte*)null : null;
                    }
                }
            }
        }

        public static void FillGifBackground(GifImage g, int x0, int y0, int x1, int y1)
        {
            int x;
            int y;
            byte* c = (byte*)g.pal + g.bgindex;
            for (y = y0; (y) < (y1); y += 4 * g.w)
            {
                for (x = x0; (x) < (x1); x += 4)
                {
                    byte* p = &g._out_[y + x];
                    p[0] = c[2];
                    p[1] = c[1];
                    p[2] = c[0];
                    p[3] = 0;
                }
            }
        }

        public static byte* LoadNextGif(ReadContext s, GifImage g, int* comp, int req_comp)
        {
            int i;
            byte* prev_out = null;
            if (((g._out_) == null) && (ParseGifHeader(s, g, comp, 0) == 0)) return null;
            if (ValidSizes_mad3(g.w, g.h, 4, 0) == 0)
                return (s.Error("too large")) != 0 ? (byte*)null : null;
            prev_out = g._out_;
            g._out_ = (byte*)(MAlloc_mad3(s.Manager, 4, g.w, g.h, 0));
            if ((g._out_) == null) return (s.Error("outofmem")) != 0 ? (byte*)null : null;
            switch ((g.eflags & 0x1C) >> 2)
            {
                case 0:
                    FillGifBackground(g, 0, 0, 4 * g.w, 4 * g.w * g.h);
                    break;
                case 1:
                    if ((prev_out) != null)
                        MemCopy(g._out_, prev_out, 4 * g.w * g.h);
                    g.old_out = prev_out;
                    break;
                case 2:
                    if ((prev_out) != null)
                        MemCopy(g._out_, prev_out, 4 * g.w * g.h);
                    FillGifBackground(g, g.start_x, g.start_y, g.max_x, g.max_y);
                    break;
                case 3:
                    if ((g.old_out) != null)
                    {
                        for (i = g.start_y; (i) < (g.max_y); i += 4 * g.w)
                        {
                            MemCopy(&g._out_[i + g.start_x], &g.old_out[i + g.start_x], g.max_x - g.start_x);
                        }
                    }
                    break;
            }

            for (; ; )
            {
                switch (GetByte(s))
                {
                    case 0x2C:
                        {
                            int prev_trans = -1;
                            int x;
                            int y;
                            int w;
                            int h;
                            byte* o;
                            x = Get16le(s);
                            y = Get16le(s);
                            w = Get16le(s);
                            h = Get16le(s);

                            if (((x + w) > (g.w)) || ((y + h) > (g.h)))
                                return (s.Error("bad Image Descriptor")) != 0 ? (byte*)null : null;

                            g.line_size = g.w * 4;
                            g.start_x = x * 4;
                            g.start_y = y * g.line_size;
                            g.max_x = g.start_x + w * 4;
                            g.max_y = g.start_y + h * g.line_size;
                            g.cur_x = g.start_x;
                            g.cur_y = g.start_y;
                            g.lflags = GetByte(s);
                            byte* gPalP = g.pal;

                            if ((g.lflags & 0x40) != 0)
                            {
                                g.step = 8 * g.line_size;
                                g.parse = 3;
                            }
                            else
                            {
                                g.step = g.line_size;
                                g.parse = 0;
                            }
                            if ((g.lflags & 0x80) != 0)
                            {
                                GifParseColortable(s, g.lpal, 2 << (g.lflags & 7),
                                    (g.eflags & 0x01) != 0 ? g.transparent : -1);
                                g.color_table = g.lpal;
                            }
                            else if ((g.flags & 0x80) != 0)
                            {
                                if (((g.transparent) >= 0) && (g.eflags & 0x01) != 0)
                                {
                                    prev_trans = gPalP[g.transparent * 4 + 3];
                                    gPalP[g.transparent * 4 + 3] = 0;
                                }
                                g.color_table = g.pal;
                            }
                            else
                                return (s.Error("missing color table")) != 0 ? (byte*)null : null;

                            o = ProcessGifRaster(s, g);
                            if (o == null)
                                return null;

                            if (prev_trans != -1)
                                gPalP[g.transparent * 4 + 3] = ((byte)(prev_trans));

                            return o;
                        }
                    case 0x21:
                        {
                            int len;
                            if ((GetByte(s)) == (0xF9))
                            {
                                len = GetByte(s);
                                if ((len) == 4)
                                {
                                    g.eflags = GetByte(s);
                                    g.delay = Get16le(s);
                                    g.transparent = GetByte(s);
                                }
                                else
                                {
                                    Skip(s, len);
                                    break;
                                }
                            }
                            while ((len = GetByte(s)) != 0)
                            {
                                Skip(s, len);
                            }
                            break;
                        }
                    case 0x3B:
                        return null;

                    default:
                        return s.Error("unknown code") != 0 ? (byte*)null : null;
                }
            }
        }

        public static void* LoadGif(ReadContext s, int* x, int* y,
            int* comp, int req_comp, ResultInfo* ri)
        {
            byte* u = null;
            GifImage g = new GifImage();

            u = LoadNextGif(s, g, comp, req_comp);
            if ((u) != null)
            {
                *x = g.w;
                *y = g.h;

                if (((req_comp) != 0) && (req_comp != 4))
                    u = ConvertToFormat8(s.Manager, s.ErrorCtx, u, 4, req_comp, (uint)(g.w), (uint)(g.h));
            }
            else if ((g._out_) != null)
                s.Manager.Free(g._out_);

            return u;
        }

        /*
        public static int GetGifInfo(ReadContext s, int* x, int* y, int* comp)
        {
            return GetRawGifInfo(s, x, y, comp);
        }

        public static int GetBmpInfo(ReadContext s, int* x, int* y, int* comp)
        {
            void* p;
            BmpData info = new BmpData
            {
                all_a = 255
            };
            p = ParseBmpHeader(s, &info);
            Rewind(s);
            if ((p) == null) return 0;
            if ((x) != null) *x = (int)(s.Width);
            if ((y) != null) *y = (int)(s.Height);
            if ((comp) != null) *comp = (info.ma) != 0 ? 4 : 3;
            return 1;
        }

        public static int InfoCore(ReadContext s, int* x, int* y, int* comp)
        {
            if ((GetJpgInfo(s, x, y, comp)) != 0) return 1;
            if ((GetPngInfo(s, x, y, comp)) != 0) return 1;
            if ((GetGifInfo(s, x, y, comp)) != 0) return 1;
            if ((GetBmpInfo(s, x, y, comp)) != 0) return 1;
            if ((GetTgaInfo(s, x, y, comp)) != 0) return 1;

            return Error("unknown image type");
        }

        public static int InfoFromMemory(MemoryManager manager, byte* buffer, int len, int* x, int* y, int* comp)
        {
            ReadContext s = GetMemoryReadContext(manager, buffer, len);
            return InfoCore(s, x, y, comp);
        }
                
        public static int InfoFromCallbacks(
            MemoryManager manager, in ReadCallbacks c, void* user, int* x, int* y, int* comp)
        {
            ReadContext s = GetReadContext(manager, c, user);
            return InfoCore(s, x, y, comp);
        }*/

        public static unsafe void MemCopy(void* a, void* b, long size)
        {
            var ap = (byte*)a;
            var bp = (byte*)b;

            for (long i = 0; i < size; ++i)
                *ap++ = *bp++;
        }
    }
}
