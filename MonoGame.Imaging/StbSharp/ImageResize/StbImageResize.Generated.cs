// Generated by Sichem at 1/28/2018 1:06:16 PM

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace StbSharp
{
    public static unsafe partial class StbImageResize
    {
        public enum WrapMode
        {
            Clamp = 1,
            Reflect = 2,
            Wrap = 3,
            Zero = 4
        }

        public enum ColorSpace
        {
            Linear = 0,
            SRgb = 1
        }

        public enum DataType
        {
            UInt8 = 0,
            UInt16 = 1,
            UInt32 = 2,
            Float = 3
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct Contributors
        {
            public int n0;
            public int n1;
        }

        private static int[] datatype_size { get; } = new[] { sizeof(byte), sizeof(ushort), sizeof(uint), sizeof(float) };

        private static float[] srgb_byte_to_linear_float { get; } = new[]
        {
            0.000000f, 0.000304f, 0.000607f, 0.000911f, 0.001214f, 0.001518f, 0.001821f, 0.002125f,
            0.002428f, 0.002732f, 0.003035f, 0.003347f, 0.003677f, 0.004025f, 0.004391f, 0.004777f,
            0.005182f, 0.005605f, 0.006049f, 0.006512f, 0.006995f, 0.007499f, 0.008023f, 0.008568f,
            0.009134f, 0.009721f, 0.010330f, 0.010960f, 0.011612f, 0.012286f, 0.012983f, 0.013702f,
            0.014444f, 0.015209f, 0.015996f, 0.016807f, 0.017642f, 0.018500f, 0.019382f, 0.020289f,
            0.021219f, 0.022174f, 0.023153f, 0.024158f, 0.025187f, 0.026241f, 0.027321f, 0.028426f,
            0.029557f, 0.030713f, 0.031896f, 0.033105f, 0.034340f, 0.035601f, 0.036889f, 0.038204f,
            0.039546f, 0.040915f, 0.042311f, 0.043735f, 0.045186f, 0.046665f, 0.048172f, 0.049707f,
            0.051269f, 0.052861f, 0.054480f, 0.056128f, 0.057805f, 0.059511f, 0.061246f, 0.063010f,
            0.064803f, 0.066626f, 0.068478f, 0.070360f, 0.072272f, 0.074214f, 0.076185f, 0.078187f,
            0.080220f, 0.082283f, 0.084376f, 0.086500f, 0.088656f, 0.090842f, 0.093059f, 0.095307f,
            0.097587f, 0.099899f, 0.102242f, 0.104616f, 0.107023f, 0.109462f, 0.111932f, 0.114435f,
            0.116971f, 0.119538f, 0.122139f, 0.124772f, 0.127438f, 0.130136f, 0.132868f, 0.135633f,
            0.138432f, 0.141263f, 0.144128f, 0.147027f, 0.149960f, 0.152926f, 0.155926f, 0.158961f,
            0.162029f, 0.165132f, 0.168269f, 0.171441f, 0.174647f, 0.177888f, 0.181164f, 0.184475f,
            0.187821f, 0.191202f, 0.194618f, 0.198069f, 0.201556f, 0.205079f, 0.208637f, 0.212231f,
            0.215861f, 0.219526f, 0.223228f, 0.226966f, 0.230740f, 0.234551f, 0.238398f, 0.242281f,
            0.246201f, 0.250158f, 0.254152f, 0.258183f, 0.262251f, 0.266356f, 0.270498f, 0.274677f,
            0.278894f, 0.283149f, 0.287441f, 0.291771f, 0.296138f, 0.300544f, 0.304987f, 0.309469f,
            0.313989f, 0.318547f, 0.323143f, 0.327778f, 0.332452f, 0.337164f, 0.341914f, 0.346704f,
            0.351533f, 0.356400f, 0.361307f, 0.366253f, 0.371238f, 0.376262f, 0.381326f, 0.386430f,
            0.391573f, 0.396755f, 0.401978f, 0.407240f, 0.412543f, 0.417885f, 0.423268f, 0.428691f,
            0.434154f, 0.439657f, 0.445201f, 0.450786f, 0.456411f, 0.462077f, 0.467784f, 0.473532f,
            0.479320f, 0.485150f, 0.491021f, 0.496933f, 0.502887f, 0.508881f, 0.514918f, 0.520996f,
            0.527115f, 0.533276f, 0.539480f, 0.545725f, 0.552011f, 0.558340f, 0.564712f, 0.571125f,
            0.577581f, 0.584078f, 0.590619f, 0.597202f, 0.603827f, 0.610496f, 0.617207f, 0.623960f,
            0.630757f, 0.637597f, 0.644480f, 0.651406f, 0.658375f, 0.665387f, 0.672443f, 0.679543f,
            0.686685f, 0.693872f, 0.701102f, 0.708376f, 0.715694f, 0.723055f, 0.730461f, 0.737911f,
            0.745404f, 0.752942f, 0.760525f, 0.768151f, 0.775822f, 0.783538f, 0.791298f, 0.799103f,
            0.806952f, 0.814847f, 0.822786f, 0.830770f, 0.838799f, 0.846873f, 0.854993f, 0.863157f,
            0.871367f, 0.879622f, 0.887923f, 0.896269f, 0.904661f, 0.913099f, 0.921582f, 0.930111f,
            0.938686f, 0.947307f, 0.955974f, 0.964686f, 0.973445f, 0.982251f, 0.991102f, 1.000000f
        };

        private static uint[] float_to_srgb8_tab4 { get; } = new uint[]
        {
            0x0073000d, 0x007a000d, 0x0080000d, 0x0087000d, 0x008d000d, 0x0094000d, 0x009a000d, 0x00a1000d,
            0x00a7001a, 0x00b4001a, 0x00c1001a, 0x00ce001a, 0x00da001a, 0x00e7001a, 0x00f4001a, 0x0101001a,
            0x010e0033, 0x01280033, 0x01410033, 0x015b0033, 0x01750033, 0x018f0033, 0x01a80033, 0x01c20033,
            0x01dc0067, 0x020f0067, 0x02430067, 0x02760067, 0x02aa0067, 0x02dd0067, 0x03110067, 0x03440067,
            0x037800ce, 0x03df00ce, 0x044600ce, 0x04ad00ce, 0x051400ce, 0x057b00c5, 0x05dd00bc, 0x063b00b5,
            0x06970158, 0x07420142, 0x07e30130, 0x087b0120, 0x090b0112, 0x09940106, 0x0a1700fc, 0x0a9500f2,
            0x0b0f01cb, 0x0bf401ae, 0x0ccb0195, 0x0d950180, 0x0e56016e, 0x0f0d015e, 0x0fbc0150, 0x10630143,
            0x11070264, 0x1238023e, 0x1357021d, 0x14660201, 0x156601e9, 0x165a01d3, 0x174401c0, 0x182401af,
            0x18fe0331, 0x1a9602fe, 0x1c1502d2, 0x1d7e02ad, 0x1ed4028d, 0x201a0270, 0x21520256, 0x227d0240,
            0x239f0443, 0x25c003fe, 0x27bf03c4, 0x29a10392, 0x2b6a0367, 0x2d1d0341, 0x2ebe031f, 0x304d0300,
            0x31d105b0, 0x34a80555, 0x37520507, 0x39d504c5, 0x3c37048b, 0x3e7c0458, 0x40a8042a, 0x42bd0401,
            0x44c20798, 0x488e071e, 0x4c1c06b6, 0x4f76065d, 0x52a50610, 0x55ac05cc, 0x5892058f, 0x5b590559,
            0x5e0c0a23, 0x631c0980, 0x67db08f6, 0x6c55087f, 0x70940818, 0x74a007bd, 0x787d076c, 0x7c330723
        };

        private const int MAX_COLORSPACES = 2;

        public static float Saturate(float x)
        {
            if ((x) < (0))
                return 0f;
            if ((x) > (1))
                return 1f;
            return (float)(x);
        }

        public static float SrgbToLinear(float f)
        {
            if (f <= 0.04045f)
                return (float)(f / 12.92f);
            else
                return (float)(Math.Pow((f + 0.055) / 1.055, 2.4));
        }

        public static float LinearToSrgb(float f)
        {
            if (f <= 0.0031308f)
                return (float)(f * 12.92f);
            else
                return (float)(1.055 * Math.Pow(f, 1 / 2.4) - 0.055);
        }

        public static float FilterTrapezoid(float x, float scale)
        {
            float halfscale = (float)(scale / 2);
            float t = (float)(0.5f + halfscale);

            x = ((float)(Math.Abs(x)));
            if ((x) >= (t))
            {
                return 0f;
            }
            else
            {
                float r = (float)(0.5f - halfscale);
                if (x <= r)
                    return 1f;
                else
                    return (float)((t - x) / scale);
            }

        }

        public static float SupportTrapezoid(float scale)
        {
            return (float)(0.5f + scale / 2);
        }

        public static float FilterTriangle(float x, float s)
        {
            x = ((float)(Math.Abs((double)(x))));
            if (x <= 1f)
                return (float)(1 - x);
            else
                return 0f;
        }

        public static float FilterCubic(float x, float s)
        {
            x = ((float)(Math.Abs((double)(x))));
            if ((x) < (1f))
                return (float)((4 + x * x * (3 * x - 6)) / 6);
            else if ((x) < (2.0f))
                return (float)((8 + x * (-12 + x * (6 - x))) / 6);
            return (float)(0f);
        }

        public static float FilterCatmullRom(float x, float s)
        {
            x = ((float)(Math.Abs((double)(x))));
            if ((x) < (1f))
                return (float)(1 - x * x * (2.5f - 1.5f * x));
            else if ((x) < (2.0f))
                return (float)(2 - x * (4 + x * (0.5f * x - 2.5f)));
            return (float)(0f);
        }

        public static float FilterMitchell(float x, float s)
        {
            x = ((float)(Math.Abs((double)(x))));
            if ((x) < (1f))
                return (float)((16 + x * x * (21 * x - 36)) / 18);
            else if ((x) < (2.0f))
                return (float)((32 + x * (-60 + x * (36 - 7 * x))) / 18);
            return (float)(0f);
        }

        public static float SupportZero(float s) => 0f;
        public static float SupportOne(float s) => 1f;
        public static float SupportTwo(float s) => 2f;

        public static bool UseUpsampling(float ratio)
        {
            return (ratio) > (1);
        }

        public static bool UseWidthUpsampling(in ResizeContext s)
        {
            return (UseUpsampling((float)(s.horizontal_scale)));
        }

        public static bool UseHeightUpsampling(in ResizeContext s)
        {
            return (UseUpsampling((float)(s.vertical_scale)));
        }

        public static int GetFilterPixelWidth(Filter filter, float scale)
        {
            if ((UseUpsampling((float)(scale))))
                return (int)(Math.Ceiling(filter.Support(1 / scale) * 2));
            else
                return (int)(Math.Ceiling(filter.Support(scale) * 2 / scale));
        }

        public static int GetFilterPixelMargin(Filter filter, float scale)
        {
            return (int)(GetFilterPixelWidth((filter), (float)(scale)) / 2);
        }

        public static int GetCoefficientWidth(Filter filter, float scale)
        {
            if ((UseUpsampling((float)(scale))))
                return (int)(Math.Ceiling(filter.Support(1 / scale) * 2));
            else
                return (int)(Math.Ceiling((double)(filter.Support((float)(scale)) * 2)));
        }

        public static int GetContributors(float scale, Filter filter, int input_size, int output_size)
        {
            if ((UseUpsampling((float)(scale))))
                return (int)(output_size);
            else
                return (int)(input_size + GetFilterPixelMargin(filter, scale) * 2);
        }

        public static int GetTotalHorizontalCoefficients(in ResizeContext info)
        {
            return (int)(info.horizontal_num_contributors *
                 GetCoefficientWidth((info.horizontal_filter), (float)(info.horizontal_scale)));
        }

        public static int GetTotalVerticalCoefficients(in ResizeContext info)
        {
            return (int)(info.vertical_num_contributors *
                 GetCoefficientWidth((info.vertical_filter), (float)(info.vertical_scale)));
        }

        public static Span<float> GetCoefficients(Span<float> coefficients, Filter filter, float scale, int y, int x)
        {
            int width = (int)(GetCoefficientWidth((filter), (float)(scale)));
            return coefficients.Slice(width * y + x);
        }

        public static int EdgeWrapSlow(WrapMode wrap, int n, int max)
        {
            switch (wrap)
            {
                case WrapMode.Clamp:
                    if ((n) < (0))
                        return 0;
                    if ((n) >= (max))
                        return (int)(max - 1);
                    return n;

                case WrapMode.Reflect:
                    if ((n) < (0))
                    {
                        if ((n) < (max))
                            return (int)(-n);
                        else
                            return (int)(max - 1);
                    }
                    if ((n) >= (max))
                    {
                        int max2 = (int)(max * 2);
                        if ((n) >= (max2))
                            return 0;
                        else
                            return (int)(max2 - n - 1);
                    }
                    return n;

                case WrapMode.Wrap:
                    if ((n) >= (0))
                    {
                        return (int)(n % max);
                    }
                    else
                    {
                        int m = (int)((-n) % max);
                        if (m != 0)
                            m = (int)(max - m);
                        return (int)(m);
                    }

                case WrapMode.Zero:
                default:
                    return 0;
            }

        }

        public static int EdgeWrap(WrapMode wrap, int n, int max)
        {
            if (((n) >= (0)) && ((n) < (max)))
                return n;
            return (int)(EdgeWrapSlow(wrap, n, (int)(max)));
        }

        public static void CalculateSampleRangeUpsample(
            int n, float out_filter_radius, float scale_ratio, float out_shift,
            out int in_first_pixel, out int in_last_pixel, out float in_center_of_out)
        {
            float out_pixel_center = (float)((float)(n) + 0.5f);
            float out_pixel_influence_lowerbound = (float)(out_pixel_center - out_filter_radius);
            float out_pixel_influence_upperbound = (float)(out_pixel_center + out_filter_radius);
            float in_pixel_influence_lowerbound = (float)((out_pixel_influence_lowerbound + out_shift) / scale_ratio);
            float in_pixel_influence_upperbound = (float)((out_pixel_influence_upperbound + out_shift) / scale_ratio);
            in_center_of_out = (float)((out_pixel_center + out_shift) / scale_ratio);
            in_first_pixel = ((int)(Math.Floor((double)(in_pixel_influence_lowerbound + 0.5))));
            in_last_pixel = ((int)(Math.Floor((double)(in_pixel_influence_upperbound - 0.5))));
        }

        public static void CalculateSampleRangeDownsample(
            int n, float in_pixels_radius, float scale_ratio, float out_shift,
            out int out_first_pixel, out int out_last_pixel, out float out_center_of_in)
        {
            float in_pixel_center = (float)((float)(n) + 0.5f);
            float in_pixel_influence_lowerbound = (float)(in_pixel_center - in_pixels_radius);
            float in_pixel_influence_upperbound = (float)(in_pixel_center + in_pixels_radius);
            float out_pixel_influence_lowerbound = (float)(in_pixel_influence_lowerbound * scale_ratio - out_shift);
            float out_pixel_influence_upperbound = (float)(in_pixel_influence_upperbound * scale_ratio - out_shift);
            out_center_of_in = (float)(in_pixel_center * scale_ratio - out_shift);
            out_first_pixel = ((int)(Math.Floor((double)(out_pixel_influence_lowerbound + 0.5))));
            out_last_pixel = ((int)(Math.Floor((double)(out_pixel_influence_upperbound - 0.5))));
        }

        public static void CalculateCoefficientsUpsample(
            Filter filter, float scale,
            int in_first_pixel, int in_last_pixel, float in_center_of_out,
            ref Contributors contributor, Span<float> coefficient_group)
        {
            int i;
            float total_filter = 0f;
            float filter_scale;
            contributor.n0 = (int)(in_first_pixel);
            contributor.n1 = (int)(in_last_pixel);
            for (i = 0; i <= in_last_pixel - in_first_pixel; i++)
            {
                float in_pixel_center = (float)((float)(i + in_first_pixel) + 0.5f);
                coefficient_group[i] = filter.Kernel(in_center_of_out - in_pixel_center, 1 / scale);

                if (((i) == 0) && (coefficient_group[i] == 0))
                {
                    contributor.n0 = (int)(++in_first_pixel);
                    i--;
                    continue;
                }
                total_filter += (float)(coefficient_group[i]);
            }

            filter_scale = (float)(1 / total_filter);
            for (i = 0; i <= in_last_pixel - in_first_pixel; i++)
                coefficient_group[i] *= (float)(filter_scale);

            for (i = (int)(in_last_pixel - in_first_pixel); (i) >= (0); i--)
            {
                if ((coefficient_group[i]) != 0)
                    break;
                contributor.n1 = (int)(contributor.n0 + i - 1);
            }
        }

        public static void CalculateCoefficientsDownsample(
            Filter filter, float scale_ratio,
            int out_first_pixel, int out_last_pixel, float out_center_of_in,
            ref Contributors contributor, Span<float> coefficient_group)
        {
            contributor.n0 = (int)(out_first_pixel);
            contributor.n1 = (int)(out_last_pixel);

            for (int i = 0; i <= out_last_pixel - out_first_pixel; i++)
            {
                float out_pixel_center = (float)((float)(i + out_first_pixel) + 0.5f);
                float x = (float)(out_pixel_center - out_center_of_in);
                coefficient_group[i] = filter.Kernel(x, scale_ratio) * scale_ratio;
            }

            for (int i = (int)(out_last_pixel - out_first_pixel); (i) >= (0); i--)
            {
                if ((coefficient_group[i]) != 0)
                    break;
                contributor.n1 = (int)(contributor.n0 + i - 1);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ref float GetCoefficient(Span<float> coefficients, int width, int y, int x)
        {
            return ref coefficients[width * y + x];
        }

        public static void NormalizeDownsampleCoefficients(
            Span<Contributors> contributors, Span<float> coefficients,
            Filter filter, float scale_ratio, float shift, int input_size, int output_size)
        {
            int coefficient_width = (GetCoefficientWidth(filter, scale_ratio));
            int num_contributors = GetContributors(scale_ratio, filter, input_size, output_size);

            for (int i = 0; (i) < (output_size); i++)
            {
                float total = 0f;
                for (int j = 0; (j) < (num_contributors); j++)
                {
                    ref Contributors contrib = ref contributors[j];
                    if (((i) >= (contrib.n0)) && (i <= contrib.n1))
                    {
                        float coefficient = GetCoefficient(coefficients, coefficient_width, j, i - contrib.n0);
                        total += (float)(coefficient);
                    }
                    else if ((i) < (contrib.n0))
                        break;
                }

                float scale = (float)(1f / total);
                for (int j = 0; (j) < (num_contributors); j++)
                {
                    ref Contributors contrib = ref contributors[j];
                    if (((i) >= (contrib.n0)) && (i <= contrib.n1))
                        GetCoefficient(coefficients, coefficient_width, j, i - contrib.n0) *= scale;
                    else if ((i) < (contrib.n0))
                        break;
                }
            }

            int skip;
            for (int j = 0; (j) < (num_contributors); j++)
            {
                skip = 0;
                while ((GetCoefficient(coefficients, coefficient_width, j, skip)) == 0)
                    skip++;

                ref Contributors contrib = ref contributors[j];
                contrib.n0 += (int)(skip);
                while ((contrib.n0) < (0))
                {
                    contrib.n0++;
                    skip++;
                }

                int range = (int)(contrib.n1 - contrib.n0 + 1);
                int max = (int)(Math.Min((int)(coefficient_width), (int)(range)));
                for (int i = 0; (i) < (max); i++)
                {
                    if ((i + skip) >= (coefficient_width))
                        break;

                    GetCoefficient(coefficients, coefficient_width, j, i) =
                        GetCoefficient(coefficients, coefficient_width, j, i + skip);
                }
            }

            for (int i = 0; (i) < (num_contributors); i++)
            {
                ref Contributors contrib = ref contributors[i];
                contrib.n1 = (int)(Math.Min(contrib.n1, output_size - 1));
            }
        }

        public static void CalculateFilters(
            Span<Contributors> contributors, Span<float> coefficients,
            Filter filter, float scale_ratio, float shift, int input_size, int output_size)
        {
            int total_contributors = GetContributors(scale_ratio, filter, input_size, output_size);
            if ((UseUpsampling((float)(scale_ratio))))
            {
                float out_pixels_radius = filter.Support(1 / scale_ratio) * scale_ratio;
                for (int y = 0; (y) < (total_contributors); y++)
                {
                    CalculateSampleRangeUpsample(
                        y, (float)(out_pixels_radius), (float)(scale_ratio), (float)(shift),
                        out int in_first_pixel, out int in_last_pixel, out float in_center_of_out);

                    CalculateCoefficientsUpsample(
                        (filter), (float)(scale_ratio),
                        (int)(in_first_pixel), (int)(in_last_pixel), (float)(in_center_of_out),
                        ref contributors[y],
                        GetCoefficients(coefficients, (filter), (float)(scale_ratio), y, 0));
                }
            }
            else
            {
                float in_pixels_radius = filter.Support(scale_ratio) / scale_ratio;
                for (int y = 0; (y) < (total_contributors); y++)
                {
                    int n_adjusted = (int)(y - GetFilterPixelMargin((filter), (float)(scale_ratio)));

                    CalculateSampleRangeDownsample(
                        (int)(n_adjusted), (float)(in_pixels_radius), (float)(scale_ratio), (float)(shift),
                        out int out_first_pixel, out int out_last_pixel, out float out_center_of_in);

                    CalculateCoefficientsDownsample(
                        (filter), (float)(scale_ratio),
                        (int)(out_first_pixel), (int)(out_last_pixel), (float)(out_center_of_in),
                        ref contributors[y],
                        GetCoefficients(coefficients, (filter), (float)(scale_ratio), y, 0));
                }

                NormalizeDownsampleCoefficients(
                    contributors, coefficients, (filter), (float)(scale_ratio), (float)(shift),
                    (int)(input_size), (int)(output_size));
            }
        }

        public static int GetDecodeBufferOffset(in ResizeContext s)
        {
            return s.horizontal_filter_pixel_margin * s.channels;
        }

        public static void DecodeScanline(in ResizeContext s, int y)
        {
            int in_buffer_row_offset = EdgeWrap(s.wrap_vertical, y, s.input_h) * s.input_stride_bytes;
            var input_data = s.input_data.Slice(in_buffer_row_offset);
            int max_x = (int)(s.input_w + s.horizontal_filter_pixel_margin);
            int decode = (int)((int)(s.datatype) * (MAX_COLORSPACES) + (int)(s.colorspace));
            int x = (int)(-s.horizontal_filter_pixel_margin);
            int c = 0;

            fixed (float* decode_buffer_ptr = &MemoryMarshal.GetReference(s.decode_buffer))
            {
                var dst = decode_buffer_ptr + GetDecodeBufferOffset(s);

                if (((s.wrap_vertical) == (WrapMode.Zero)) && (((y) < (0)) || ((y) >= (s.input_h))))
                {
                    for (; (x) < (max_x); x++)
                    {
                        for (c = 0; (c) < (s.channels); c++)
                            dst[x * s.channels + c] = 0;
                    }
                    return;
                }

                fixed (byte* src8 = &MemoryMarshal.GetReference(input_data))
                {
                    var src16 = (ushort*)src8;
                    var src32 = (uint*)src8;
                    var srcF = (float*)src8;

                    bool srgbAlpha = (s.flags & (1 << 1)) == 0;
                    switch (decode)
                    {
                        case (((int)DataType.UInt8) * (MAX_COLORSPACES) + (int)(ColorSpace.Linear)):
                            for (; (x) < (max_x); x++)
                            {
                                int dst_pixel_index = x * s.channels;
                                int src_pixel_index = EdgeWrap(s.wrap_horizontal, x, s.input_w) * s.channels;
                                for (c = 0; (c) < (s.channels); c++)
                                    dst[dst_pixel_index + c] = src8[src_pixel_index + c] / 255f;
                            }
                            break;

                        case (((int)DataType.UInt8) * (MAX_COLORSPACES) + (int)(ColorSpace.SRgb)):
                            for (; (x) < (max_x); x++)
                            {
                                int dst_pixel_index = x * s.channels;
                                int src_pixel_index = EdgeWrap(s.wrap_horizontal, x, s.input_w) * s.channels;
                                for (c = 0; (c) < (s.channels); c++)
                                    dst[dst_pixel_index + c] = srgb_byte_to_linear_float[src8[src_pixel_index + c]];

                                if (srgbAlpha)
                                    dst[dst_pixel_index + s.alpha_channel] =
                                        src8[src_pixel_index + s.alpha_channel] / 255f;
                            }
                            break;

                        case (((int)DataType.UInt16) * (MAX_COLORSPACES) + (int)(ColorSpace.Linear)):
                        {
                            for (; (x) < (max_x); x++)
                            {
                                int dst_pixel_index = x * s.channels;
                                int src_pixel_index = EdgeWrap(s.wrap_horizontal, x, s.input_w) * s.channels;
                                for (c = 0; (c) < (s.channels); c++)
                                    dst[dst_pixel_index + c] = src16[src_pixel_index + c] / 65535f;
                            }
                            break;
                        }

                        case (((int)DataType.UInt16) * (MAX_COLORSPACES) + (int)(ColorSpace.SRgb)):
                        {
                            for (; (x) < (max_x); x++)
                            {
                                int dst_pixel_index = x * s.channels;
                                int src_pixel_index = EdgeWrap(s.wrap_horizontal, x, s.input_w) * s.channels;
                                for (c = 0; (c) < (s.channels); c++)
                                    dst[dst_pixel_index + c] = SrgbToLinear(src16[src_pixel_index + c] / 65535f);

                                if (srgbAlpha)
                                    dst[dst_pixel_index + s.alpha_channel] =
                                        src16[src_pixel_index + s.alpha_channel] / 65535f;
                            }
                            break;
                        }

                        case (((int)DataType.UInt32) * (MAX_COLORSPACES) + (int)(ColorSpace.Linear)):
                        {
                            for (; (x) < (max_x); x++)
                            {
                                int dst_pixel_index = x * s.channels;
                                int src_pixel_index = EdgeWrap(s.wrap_horizontal, x, s.input_w) * s.channels;
                                for (c = 0; (c) < (s.channels); c++)
                                    dst[dst_pixel_index + c] = (float)(src32[src_pixel_index + c] / 4294967295d);
                            }
                            break;
                        }

                        case (((int)DataType.UInt32) * (MAX_COLORSPACES) + (int)(ColorSpace.SRgb)):
                        {
                            for (; (x) < (max_x); x++)
                            {
                                int dst_pixel_index = x * s.channels;
                                int src_pixel_index = EdgeWrap(s.wrap_horizontal, x, s.input_w) * s.channels;
                                for (c = 0; (c) < (s.channels); c++)
                                    dst[dst_pixel_index + c] = SrgbToLinear(
                                        (float)(src32[src_pixel_index + c] / 4294967295d));

                                if (srgbAlpha)
                                    dst[dst_pixel_index + s.alpha_channel] =
                                        (float)(src32[src_pixel_index + s.alpha_channel] / 4294967295d);
                            }
                            break;
                        }

                        case (((int)DataType.Float) * (MAX_COLORSPACES) + (int)(ColorSpace.Linear)):
                        {
                            for (; (x) < (max_x); x++)
                            {
                                int dst_pixel_index = x * s.channels;
                                int src_pixel_index = EdgeWrap(s.wrap_horizontal, x, s.input_w) * s.channels;
                                for (c = 0; (c) < (s.channels); c++)
                                    dst[dst_pixel_index + c] = srcF[src_pixel_index + c];
                            }
                            break;
                        }

                        case (((int)DataType.Float) * (MAX_COLORSPACES) + (int)(ColorSpace.SRgb)):
                        {
                            for (; (x) < (max_x); x++)
                            {
                                int dst_pixel_index = x * s.channels;
                                int src_pixel_index = EdgeWrap(s.wrap_horizontal, x, s.input_w) * s.channels;
                                for (c = 0; (c) < (s.channels); c++)
                                    dst[dst_pixel_index + c] = SrgbToLinear(srcF[src_pixel_index + c]);

                                if (srgbAlpha)
                                    dst[dst_pixel_index + s.alpha_channel] = srcF[src_pixel_index + s.alpha_channel];
                            }
                            break;
                        }
                    }
                }

                if ((s.flags & (1 << 0)) == 0)
                {
                    for (x = (int)(-s.horizontal_filter_pixel_margin); (x) < (max_x); x++)
                    {
                        int dst_pixel_index = (x * s.channels);
                        float alpha = dst[dst_pixel_index + s.alpha_channel];
                        if (s.datatype != DataType.Float)
                        {
                            alpha += 1f / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20);
                            dst[dst_pixel_index + s.alpha_channel] = alpha;
                        }

                        for (c = 0; (c) < (s.channels); c++)
                        {
                            if ((c) == (s.alpha_channel))
                                continue;
                            dst[dst_pixel_index + c] *= alpha;
                        }
                    }
                }

                if ((s.wrap_horizontal) == (WrapMode.Zero))
                {
                    for (x = (int)(-s.horizontal_filter_pixel_margin); (x) < (0); x++)
                        for (c = 0; (c) < (s.channels); c++)
                            dst[x * s.channels + c] = 0;

                    for (x = (int)(s.input_w); (x) < (max_x); x++)
                        for (c = 0; (c) < (s.channels); c++)
                            dst[x * s.channels + c] = 0;
                }
            }
        }

        public static Span<float> GetRingBufferEntry(Span<float> ring_buffer, int index, int length)
        {
            return ring_buffer.Slice(index * length, length);
        }

        public static Span<float> AddEmptyRingBufferEntry(ref ResizeContext s, int n)
        {
            int ring_buffer_index;
            s.ring_buffer_last_scanline = n;
            if ((s.ring_buffer_begin_index) < (0))
            {
                ring_buffer_index = s.ring_buffer_begin_index = 0;
                s.ring_buffer_first_scanline = n;
            }
            else
            {
                ring_buffer_index =
                    (s.ring_buffer_begin_index +
                    s.ring_buffer_last_scanline -
                    s.ring_buffer_first_scanline) %
                    s.ring_buffer_num_entries;
            }

            Span<float> ring_buffer = GetRingBufferEntry(s.ring_buffer, ring_buffer_index, s.ring_buffer_length);
            ring_buffer.Fill(0);

            return ring_buffer;
        }

        public static void ResampleHorizontalUpsample(in ResizeContext s, Span<float> output_buffer)
        {
            int output_w = (int)(s.output_w);
            int kernel_pixel_width = (int)(s.horizontal_filter_pixel_width);
            int channels = (int)(s.channels);
            int coefficient_width = (int)(s.horizontal_coefficient_width);

            fixed (float* dst = &MemoryMarshal.GetReference(output_buffer))
            fixed (float* horizontal_coefficients_ptr = &MemoryMarshal.GetReference(s.horizontal_coefficients))
            fixed (float* decode_buffer_ptr = &MemoryMarshal.GetReference(s.decode_buffer))
            {
                float* src = decode_buffer_ptr + GetDecodeBufferOffset(s);

                int k;
                for (int x = 0; (x) < (output_w); x++)
                {
                    ref var contrib = ref s.horizontal_contributors[x];
                    int n0 = (int)(contrib.n0);
                    int n1 = (int)(contrib.n1);

                    int dst_pixel_index = (int)(x * channels);
                    int coefficient_group = (int)(coefficient_width * x);
                    float* horizontal_coefficients = horizontal_coefficients_ptr + coefficient_group;

                    switch (channels)
                    {
                        case 1:
                            for (k = (int)(n0); k <= n1; k++)
                            {
                                int src_pixel_index = (k * 1);
                                float coefficient = *horizontal_coefficients++;
                                dst[dst_pixel_index + 0] += src[src_pixel_index + 0] * coefficient;
                            }
                            break;

                        case 2:
                            for (k = (int)(n0); k <= n1; k++)
                            {
                                int src_pixel_index = (int)(k * 2);
                                float coefficient = *horizontal_coefficients++;
                                dst[dst_pixel_index + 0] += src[src_pixel_index + 0] * coefficient;
                                dst[dst_pixel_index + 1] += src[src_pixel_index + 1] * coefficient;
                            }
                            break;

                        case 3:
                            for (k = (int)(n0); k <= n1; k++)
                            {
                                int src_pixel_index = (int)(k * 3);
                                float coefficient = *horizontal_coefficients++;
                                dst[dst_pixel_index + 0] += src[src_pixel_index + 0] * coefficient;
                                dst[dst_pixel_index + 1] += src[src_pixel_index + 1] * coefficient;
                                dst[dst_pixel_index + 2] += src[src_pixel_index + 2] * coefficient;
                            }
                            break;

                        case 4:
                            for (k = (int)(n0); k <= n1; k++)
                            {
                                int src_pixel_index = (int)(k * 4);
                                float coefficient = *horizontal_coefficients++;
                                dst[dst_pixel_index + 0] += src[src_pixel_index + 0] * coefficient;
                                dst[dst_pixel_index + 1] += src[src_pixel_index + 1] * coefficient;
                                dst[dst_pixel_index + 2] += src[src_pixel_index + 2] * coefficient;
                                dst[dst_pixel_index + 3] += src[src_pixel_index + 3] * coefficient;
                            }
                            break;

                        default:
                            int c;
                            for (k = (int)(n0); k <= n1; k++)
                            {
                                int src_pixel_index = (int)(k * channels);
                                float coefficient = *horizontal_coefficients++;
                                for (c = 0; (c) < (channels); c++)
                                    dst[dst_pixel_index + c] += src[src_pixel_index + c] * coefficient;
                            }
                            break;
                    }
                }
            }
        }

        public static void ResampleHorizontalDownsample(in ResizeContext s, Span<float> output_buffer)
        {
            int x;
            int k;
            int c;
            int input_w = (int)(s.input_w);
            int output_w = (int)(s.output_w);
            int kernel_pixel_width = (int)(s.horizontal_filter_pixel_width);
            int channels = (int)(s.channels);
            var horizontal_contributors = s.horizontal_contributors;
            int coefficient_width = (int)(s.horizontal_coefficient_width);
            int filter_pixel_margin = (int)(s.horizontal_filter_pixel_margin);
            int max_x = (int)(input_w + filter_pixel_margin * 2);

            fixed (float* horizontal_coefficients_ptr = &MemoryMarshal.GetReference(s.horizontal_coefficients))
            fixed (float* decode_buffer_ptr = &MemoryMarshal.GetReference(s.decode_buffer))
            fixed (float* dst = &MemoryMarshal.GetReference(output_buffer))
            {
                float* src = decode_buffer_ptr + GetDecodeBufferOffset(s);

                switch (channels)
                {
                    case 1:
                        for (x = 0; (x) < (max_x); x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = (int)(contrib.n0);
                            int max_n = (int)(contrib.n1);

                            int in_x = (int)(x - filter_pixel_margin);
                            int in_pixel_index = (int)(in_x * 1);

                            int coefficient_group = (int)(coefficient_width * x);
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = (int)(n0); k <= max_n; k++)
                            {
                                int out_pixel_index = (int)(k * 1);
                                float coefficient = (float)(coefficients[k - n0]);
                                dst[out_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                            }
                        }
                        break;

                    case 2:
                        for (x = 0; (x) < (max_x); x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = (int)(contrib.n0);
                            int max_n = (int)(contrib.n1);

                            int in_x = (int)(x - filter_pixel_margin);
                            int in_pixel_index = (int)(in_x * 2);

                            int coefficient_group = (int)(coefficient_width * x);
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = (int)(n0); k <= max_n; k++)
                            {
                                int out_pixel_index = (int)(k * 2);
                                float coefficient = (float)(coefficients[k - n0]);
                                dst[out_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                dst[out_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                            }
                        }
                        break;

                    case 3:
                        for (x = 0; (x) < (max_x); x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = (int)(contrib.n0);
                            int max_n = (int)(contrib.n1);

                            int in_x = (int)(x - filter_pixel_margin);
                            int in_pixel_index = (int)(in_x * 3);

                            int coefficient_group = (int)(coefficient_width * x);
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = (int)(n0); k <= max_n; k++)
                            {
                                int out_pixel_index = (int)(k * 3);
                                float coefficient = coefficients[k - n0];
                                dst[out_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                dst[out_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                                dst[out_pixel_index + 2] += src[in_pixel_index + 2] * coefficient;
                            }
                        }
                        break;

                    case 4:
                        for (x = 0; (x) < (max_x); x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = (int)(contrib.n0);
                            int max_n = (int)(contrib.n1);

                            int in_x = (int)(x - filter_pixel_margin);
                            int in_pixel_index = (int)(in_x * 4);

                            int coefficient_group = (int)(coefficient_width * x);
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = (int)(n0); k <= max_n; k++)
                            {
                                int out_pixel_index = (int)(k * 4);
                                float coefficient = (float)(coefficients[k - n0]);
                                dst[out_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                dst[out_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                                dst[out_pixel_index + 2] += src[in_pixel_index + 2] * coefficient;
                                dst[out_pixel_index + 3] += src[in_pixel_index + 3] * coefficient;
                            }
                        }
                        break;

                    default:
                        for (x = 0; (x) < (max_x); x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = (int)(contrib.n0);
                            int max_n = (int)(contrib.n1);

                            int in_x = (int)(x - filter_pixel_margin);
                            int in_pixel_index = (int)(in_x * channels);

                            int coefficient_group = (int)(coefficient_width * x);
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = (int)(n0); k <= max_n; k++)
                            {
                                int out_pixel_index = (int)(k * channels);
                                float coefficient = (float)(coefficients[k - n0]);
                                for (c = 0; (c) < (channels); c++)
                                    dst[out_pixel_index + c] += src[in_pixel_index + c] * coefficient;
                            }
                        }
                        break;
                }
            }
        }

        public static void DecodeAndResampleUpsample(ref ResizeContext s, int n)
        {
            DecodeScanline(s, n);
            if ((UseWidthUpsampling(s)))
                ResampleHorizontalUpsample(s, AddEmptyRingBufferEntry(ref s, n));
            else
                ResampleHorizontalDownsample(s, AddEmptyRingBufferEntry(ref s, n));
        }

        public static void DecodeAndResampleDownsample(in ResizeContext s, int y)
        {
            DecodeScanline(s, y);
            s.horizontal_buffer.Fill(0);

            if ((UseWidthUpsampling(s)))
                ResampleHorizontalUpsample(s, s.horizontal_buffer);
            else
                ResampleHorizontalDownsample(s, s.horizontal_buffer);
        }

        public static Span<float> GetRingBufferScanline(
            int get_scanline, Span<float> ring_buffer, int begin_index,
            int first_scanline, int ring_buffer_num_entries, int ring_buffer_length)
        {
            int ring_buffer_index = (int)((begin_index + (get_scanline - first_scanline)) % ring_buffer_num_entries);
            return GetRingBufferEntry(ring_buffer, (int)(ring_buffer_index), ring_buffer_length);
        }

        public static void EncodeScanline(
            in ResizeContext s, int num_pixels,
            Span<byte> output_buffer, Span<float> encode_buffer,
            int channels, int alpha_channel, int decode)
        {
            int x;
            int n;

            fixed (float* src = &MemoryMarshal.GetReference(encode_buffer))
            {
                if ((s.flags & (1 << 0)) == 0)
                {
                    for (x = 0; (x) < (num_pixels); ++x)
                    {
                        int pixel_index = (int)(x * channels);
                        float alpha = src[pixel_index + alpha_channel];
                        float reciprocal_alpha = (float)((alpha) != 0 ? 1f / alpha : 0);

                        for (n = 0; (n) < (channels); n++)
                            if (n != alpha_channel)
                                src[pixel_index + n] *= (float)(reciprocal_alpha);
                    }
                }

                int num_nonalpha;
                ushort* nonalpha = stackalloc ushort[64];
                for (x = 0, num_nonalpha = 0; (x) < (channels); ++x)
                {
                    if ((x != alpha_channel) || ((s.flags & (1 << 1)) != 0))
                        nonalpha[num_nonalpha++] = (ushort)(x);
                }

                fixed (byte* dst8 = &MemoryMarshal.GetReference(output_buffer))
                {
                    var dst16 = (ushort*)dst8;
                    var dst32 = (uint*)dst8;
                    var dstF = (float*)dst8;

                    bool srgbAlpha = (s.flags & (1 << 1)) == 0;
                    switch (decode)
                    {
                        case (((int)DataType.UInt8) * (MAX_COLORSPACES) + (int)(ColorSpace.Linear)):
                            for (x = 0; (x) < (num_pixels); ++x)
                            {
                                int pixel_index = (int)(x * channels);
                                for (n = 0; (n) < (channels); n++)
                                {
                                    int index = (int)(pixel_index + n);
                                    (dst8)[index] = ((byte)((int)((Saturate(src[index]) * 255) + 0.5)));
                                }
                            }
                            break;

                        case (((int)DataType.UInt8) * (MAX_COLORSPACES) + (int)(ColorSpace.SRgb)):
                            for (x = 0; (x) < (num_pixels); ++x)
                            {
                                int pixel_index = (int)(x * channels);
                                for (n = 0; (n) < (num_nonalpha); n++)
                                {
                                    int index = (int)(pixel_index + nonalpha[n]);
                                    (dst8)[index] = (byte)(LinearToSrgbByte(src[index]));
                                }

                                if (srgbAlpha)
                                    (dst8)[pixel_index + alpha_channel] = (byte)((int)(
                                        Saturate(src[pixel_index + alpha_channel]) * 255 + 0.5));
                            }
                            break;

                        case (((int)DataType.UInt16) * (MAX_COLORSPACES) + (int)(ColorSpace.Linear)):
                        {
                            for (x = 0; (x) < (num_pixels); ++x)
                            {
                                int pixel_index = (int)(x * channels);
                                for (n = 0; (n) < (channels); n++)
                                {
                                    int index = (int)(pixel_index + n);
                                    dst16[index] = (ushort)((int)(
                                        Saturate(src[index]) * 65535 + 0.5));
                                }
                            }
                            break;
                        }

                        case (((int)DataType.UInt16) * (MAX_COLORSPACES) + (int)(ColorSpace.SRgb)):
                        {
                            for (x = 0; (x) < (num_pixels); ++x)
                            {
                                int pixel_index = (int)(x * channels);
                                for (n = 0; (n) < (num_nonalpha); n++)
                                {
                                    int index = (int)(pixel_index + nonalpha[n]);
                                    dst16[index] = (ushort)((int)(
                                        LinearToSrgb(Saturate(src[index])) * 65535 + 0.5));
                                }

                                if (srgbAlpha)
                                    dst16[pixel_index + alpha_channel] = (ushort)((int)(
                                        Saturate(src[pixel_index + alpha_channel]) * 65535 + 0.5));
                            }
                            break;
                        }

                        case (((int)DataType.UInt32) * (MAX_COLORSPACES) + (int)(ColorSpace.Linear)):
                        {
                            for (x = 0; (x) < (num_pixels); ++x)
                            {
                                int pixel_index = (int)(x * channels);
                                for (n = 0; (n) < (channels); n++)
                                {
                                    int index = (int)(pixel_index + n);
                                    dst32[index] = ((uint)((((double)(Saturate(src[index]))) * 4294967295) + 0.5));
                                }
                            }
                            break;
                        }

                        case (((int)DataType.UInt32) * (MAX_COLORSPACES) + (int)(ColorSpace.SRgb)):
                        {
                            for (x = 0; (x) < (num_pixels); ++x)
                            {
                                int pixel_index = (int)(x * channels);
                                for (n = 0; (n) < (num_nonalpha); n++)
                                {
                                    int index = (int)(pixel_index + nonalpha[n]);
                                    dst32[index] = (uint)((((double)(LinearToSrgb(
                                        (float)(Saturate(src[index]))))) * 4294967295) + 0.5);
                                }

                                if (srgbAlpha)
                                    dst32[pixel_index + alpha_channel] = ((uint)((int)((((double)(Saturate(
                                        src[pixel_index + alpha_channel]))) * 4294967295) + 0.5)));
                            }
                            break;
                        }

                        case (((int)DataType.Float) * (MAX_COLORSPACES) + (int)(ColorSpace.Linear)):
                        {
                            for (x = 0; (x) < (num_pixels); ++x)
                            {
                                int pixel_index = (int)(x * channels);
                                for (n = 0; (n) < (channels); n++)
                                {
                                    int index = (int)(pixel_index + n);
                                    dstF[index] = src[index];
                                }
                            }
                            break;
                        }

                        case (((int)DataType.Float) * (MAX_COLORSPACES) + (int)(ColorSpace.SRgb)):
                        {
                            for (x = 0; (x) < (num_pixels); ++x)
                            {
                                int pixel_index = (int)(x * channels);
                                for (n = 0; (n) < (num_nonalpha); n++)
                                {
                                    int index = (int)(pixel_index + nonalpha[n]);
                                    dstF[index] = (float)(LinearToSrgb(src[index]));
                                }

                                if (srgbAlpha)
                                    dstF[pixel_index + alpha_channel] = src[pixel_index + alpha_channel];
                            }
                            break;
                        }
                    }
                }
            }
        }

        public static void ResampleVerticalUpsample(
            in ResizeContext s, int n, int in_first_scanline, int in_last_scanline, float in_center_of_out)
        {
            int x;
            int k;
            int c;
            int output_w = (int)(s.output_w);
            int channels = (int)(s.channels);
            int alpha_channel = (int)(s.alpha_channel);
            int ring_buffer_entries = (int)(s.ring_buffer_num_entries);
            int decode = (int)((int)(s.datatype) * (MAX_COLORSPACES) + (int)(s.colorspace));
            int ring_buffer_begin_index = (int)(s.ring_buffer_begin_index);
            int ring_buffer_first_scanline = (int)(s.ring_buffer_first_scanline);
            int ring_buffer_last_scanline = (int)(s.ring_buffer_last_scanline);
            int ring_buffer_length = s.ring_buffer_length;
            int output_row_start = (int)(n * s.output_stride_bytes);

            int coefficient_width = (int)(s.vertical_coefficient_width);
            int contributor = n;
            int n0 = (int)(s.vertical_contributors[contributor].n0);
            int n1 = (int)(s.vertical_contributors[contributor].n1);

            s.encode_buffer.Fill(0);

            fixed (float* vertical_coefficients_ptr = &MemoryMarshal.GetReference(s.vertical_coefficients))
            fixed (float* dst = &MemoryMarshal.GetReference(s.encode_buffer))
            {
                int coefficient_group = (int)(coefficient_width * contributor);
                float* coefficients = vertical_coefficients_ptr + coefficient_group;

                switch (channels)
                {
                    case 1:
                        for (k = (int)(n0); k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                (int)(k), s.ring_buffer,
                                (int)(ring_buffer_begin_index),
                                (int)(ring_buffer_first_scanline),
                                (int)(ring_buffer_entries),
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; (x) < (output_w); ++x)
                            {
                                int in_pixel_index = (int)(x * 1);
                                dst[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                            }
                        }
                        break;

                    case 2:
                        for (k = (int)(n0); k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                (int)(k), s.ring_buffer,
                                (int)(ring_buffer_begin_index),
                                (int)(ring_buffer_first_scanline),
                                (int)(ring_buffer_entries),
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; (x) < (output_w); ++x)
                            {
                                int in_pixel_index = (int)(x * 2);
                                dst[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                                dst[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
                            }
                        }
                        break;

                    case 3:
                        for (k = (int)(n0); k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                (int)(k), s.ring_buffer,
                                (int)(ring_buffer_begin_index),
                                (int)(ring_buffer_first_scanline),
                                (int)(ring_buffer_entries),
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; (x) < (output_w); ++x)
                            {
                                int in_pixel_index = (int)(x * 3);
                                dst[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                                dst[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
                                dst[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;
                            }
                        }
                        break;

                    case 4:
                        for (k = (int)(n0); k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                (int)(k), s.ring_buffer,
                                (int)(ring_buffer_begin_index),
                                (int)(ring_buffer_first_scanline),
                                (int)(ring_buffer_entries),
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; (x) < (output_w); ++x)
                            {
                                int in_pixel_index = (int)(x * 4);
                                dst[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                                dst[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
                                dst[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;
                                dst[in_pixel_index + 3] += ring_buffer_entry[in_pixel_index + 3] * coefficient;
                            }
                        }
                        break;

                    default:
                        for (k = (int)(n0); k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                (int)(k), s.ring_buffer,
                                (int)(ring_buffer_begin_index),
                                (int)(ring_buffer_first_scanline),
                                (int)(ring_buffer_entries),
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; (x) < (output_w); ++x)
                            {
                                int in_pixel_index = (int)(x * channels);
                                for (c = 0; (c) < (channels); c++)
                                    dst[in_pixel_index + c] += ring_buffer_entry[in_pixel_index + c] * coefficient;
                            }
                        }
                        break;
                }
            }

            EncodeScanline(
                s, (int)(output_w), s.output_data.Slice(output_row_start),
                s.encode_buffer, (int)(channels), (int)(alpha_channel), (int)(decode));
        }

        public static void ResampleVerticalDownsample(
            in ResizeContext s, int n, int in_first_scanline, int in_last_scanline, float in_center_of_out)
        {
            int contributor = (int)(n + s.vertical_filter_pixel_margin);
            int n0 = (int)(s.vertical_contributors[contributor].n0);
            int n1 = (int)(s.vertical_contributors[contributor].n1);

            int coefficient_group = (int)(s.vertical_coefficient_width * contributor);

            fixed (float* src = &MemoryMarshal.GetReference(s.horizontal_buffer))
            {
                int x;
                int c;

                for (int k = (int)(n0); k <= n1; k++)
                {
                    var ring_buffer_entry = GetRingBufferScanline(
                        (int)(k), s.ring_buffer,
                        (int)(s.ring_buffer_begin_index),
                        (int)(s.ring_buffer_first_scanline),
                        (int)(s.ring_buffer_num_entries),
                         s.ring_buffer_length);

                    int coefficient_index = (int)(k - n0);
                    float coefficient = (float)(s.vertical_coefficients[coefficient_group + coefficient_index]);

                    switch (s.channels)
                    {
                        case 1:
                            for (x = 0; (x) < (s.output_w); x++)
                            {
                                int in_pixel_index = (int)(x * 1);
                                ring_buffer_entry[in_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                            }
                            break;

                        case 2:
                            for (x = 0; (x) < (s.output_w); x++)
                            {
                                int in_pixel_index = (int)(x * 2);
                                ring_buffer_entry[in_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                ring_buffer_entry[in_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                            }
                            break;

                        case 3:
                            for (x = 0; (x) < (s.output_w); x++)
                            {
                                int in_pixel_index = (int)(x * 3);
                                ring_buffer_entry[in_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                ring_buffer_entry[in_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                                ring_buffer_entry[in_pixel_index + 2] += src[in_pixel_index + 2] * coefficient;
                            }
                            break;

                        case 4:
                            for (x = 0; (x) < (s.output_w); x++)
                            {
                                int in_pixel_index = (int)(x * 4);
                                ring_buffer_entry[in_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                ring_buffer_entry[in_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                                ring_buffer_entry[in_pixel_index + 2] += src[in_pixel_index + 2] * coefficient;
                                ring_buffer_entry[in_pixel_index + 3] += src[in_pixel_index + 3] * coefficient;
                            }
                            break;

                        default:
                            for (x = 0; (x) < (s.output_w); x++)
                            {
                                int in_pixel_index = (int)(x * s.channels);
                                for (c = 0; (c) < (s.channels); c++)
                                    ring_buffer_entry[in_pixel_index + c] += src[in_pixel_index + c] * coefficient;
                            }
                            break;
                    }
                }
            }
        }

        public static void BufferLoopUpsample(ref ResizeContext s)
        {
            float scale_ratio = (float)(s.vertical_scale);
            float out_scanlines_radius = s.vertical_filter.Support(1 / scale_ratio) * scale_ratio;

            for (int y = 0; (y) < (s.output_h); y++)
            {
                CalculateSampleRangeUpsample(
                    (int)(y), (float)(out_scanlines_radius), (float)(scale_ratio), (float)(s.vertical_shift),
                    out int in_first_scanline, out int in_last_scanline, out float in_center_of_out);

                if ((s.ring_buffer_begin_index) >= (0))
                {
                    while ((in_first_scanline) > (s.ring_buffer_first_scanline))
                    {
                        if ((s.ring_buffer_first_scanline) == (s.ring_buffer_last_scanline))
                        {
                            s.ring_buffer_begin_index = (int)(-1);
                            s.ring_buffer_first_scanline = 0;
                            s.ring_buffer_last_scanline = 0;
                            break;
                        }
                        else
                        {
                            s.ring_buffer_first_scanline++;
                            s.ring_buffer_begin_index =
                                (int)((s.ring_buffer_begin_index + 1) % s.ring_buffer_num_entries);
                        }
                    }
                }

                if ((s.ring_buffer_begin_index) < (0))
                    DecodeAndResampleUpsample(ref s, (int)(in_first_scanline));

                while ((in_last_scanline) > (s.ring_buffer_last_scanline))
                    DecodeAndResampleUpsample(ref s, (int)(s.ring_buffer_last_scanline + 1));

                ResampleVerticalUpsample(
                    s, y, in_first_scanline, in_last_scanline, in_center_of_out);
            }
        }

        public static void EmptyRingBuffer(ref ResizeContext s, int first_necessary_scanline)
        {
            if ((s.ring_buffer_begin_index) < (0))
                return;

            int decode = (int)((int)(s.datatype) * (MAX_COLORSPACES) + (int)(s.colorspace));
            int ring_buffer_length = s.ring_buffer_length;

            while ((first_necessary_scanline) > (s.ring_buffer_first_scanline))
            {
                if (((s.ring_buffer_first_scanline) >= (0)) &&
                    ((s.ring_buffer_first_scanline) < (s.output_h)))
                {
                    var ring_buffer_entry = GetRingBufferEntry(
                         s.ring_buffer,
                        (int)(s.ring_buffer_begin_index),
                        ring_buffer_length);

                    int output_row_start = (int)(s.ring_buffer_first_scanline * s.output_stride_bytes);
                    var output = s.output_data.Slice(output_row_start, s.output_stride_bytes);
                    EncodeScanline(s, s.output_w, output, ring_buffer_entry, s.channels, s.alpha_channel, decode);
                }

                if ((s.ring_buffer_first_scanline) == (s.ring_buffer_last_scanline))
                {
                    s.ring_buffer_begin_index = (int)(-1);
                    s.ring_buffer_first_scanline = 0;
                    s.ring_buffer_last_scanline = 0;
                    break;
                }
                else
                {
                    s.ring_buffer_first_scanline++;
                    s.ring_buffer_begin_index =
                        (int)((s.ring_buffer_begin_index + 1) % s.ring_buffer_num_entries);
                }
            }

            //Console.WriteLine("NEW: " + Hash(s));
        }

        public static void BufferLoopDownsample(ref ResizeContext s)
        {
            float scale_ratio = (float)(s.vertical_scale);
            float in_pixels_radius = (float)(s.vertical_filter.Support(scale_ratio) / scale_ratio);
            int pixel_margin = (int)(s.vertical_filter_pixel_margin);
            int max_y = (int)(s.input_h + pixel_margin);

            for (int y = (int)(-pixel_margin); (y) < (max_y); y++)
            {
                CalculateSampleRangeDownsample(
                    (int)(y), (float)(in_pixels_radius), (float)(scale_ratio), (float)(s.vertical_shift),
                    out int out_first_scanline, out int out_last_scanline, out float out_center_of_in);

                if (((out_last_scanline) < (0)) || ((out_first_scanline) >= (s.output_h)))
                    continue;

                EmptyRingBuffer(ref s, (int)(out_first_scanline));
                DecodeAndResampleDownsample(s, (int)(y));

                if ((s.ring_buffer_begin_index) < (0))
                    AddEmptyRingBufferEntry(ref s, (int)(out_first_scanline));

                while ((out_last_scanline) > (s.ring_buffer_last_scanline))
                    AddEmptyRingBufferEntry(ref s, (int)(s.ring_buffer_last_scanline + 1));

                ResampleVerticalDownsample(
                    s,
                    (int)(y),
                    (int)(out_first_scanline),
                    (int)(out_last_scanline),
                    (float)(out_center_of_in));
            }

            EmptyRingBuffer(ref s, (int)(s.output_h));
        }

        public static void Setup(
            ref ResizeContext s, int input_w, int input_h, int output_w, int output_h, int channels)
        {
            s.input_w = (int)(input_w);
            s.input_h = (int)(input_h);
            s.output_w = (int)(output_w);
            s.output_h = (int)(output_h);
            s.channels = (int)(channels);
        }

        public static void CalculateTransform(
            ref ResizeContext s, float s0, float t0, float s1, float t1, float* transform)
        {
            s.s0 = (float)(s0);
            s.t0 = (float)(t0);
            s.s1 = (float)(s1);
            s.t1 = (float)(t1);

            if ((transform) != null)
            {
                s.horizontal_scale = (float)(transform[0]);
                s.vertical_scale = (float)(transform[1]);
                s.horizontal_shift = (float)(transform[2]);
                s.vertical_shift = (float)(transform[3]);
            }
            else
            {
                s.horizontal_scale = (float)(((float)(s.output_w) / s.input_w) / (s1 - s0));
                s.vertical_scale = (float)(((float)(s.output_h) / s.input_h) / (t1 - t0));
                s.horizontal_shift = (float)(s0 * s.output_w / (s1 - s0));
                s.vertical_shift = (float)(t0 * s.output_h / (t1 - t0));
            }

        }

        public static void ChooseFilters(
            ref ResizeContext s, Filter h_filter, Filter v_filter)
        {
            if (h_filter == null)
                h_filter = ((UseUpsampling((float)(s.horizontal_scale)))
                    ? Filter.CatmullRom
                    : Filter.Mitchell);

            if (v_filter == null)
                v_filter = ((UseUpsampling((float)(s.vertical_scale)))
                    ? Filter.CatmullRom
                    : Filter.Mitchell);

            s.horizontal_filter = (h_filter);
            s.vertical_filter = (v_filter);
        }

        public static int CalculateMemory(ref ResizeContext s)
        {
            int pixel_margin = GetFilterPixelMargin(s.horizontal_filter, s.horizontal_scale);
            int filter_height = GetFilterPixelWidth(s.vertical_filter, s.vertical_scale);

            s.horizontal_num_contributors = GetContributors(
                s.horizontal_scale, s.horizontal_filter, s.input_w, s.output_w);
            s.vertical_num_contributors = GetContributors(
                s.vertical_scale, s.vertical_filter, s.input_h, s.output_h);

            s.ring_buffer_num_entries = (int)(filter_height + 1);
            s.horizontal_contributors_size = (int)(s.horizontal_num_contributors * sizeof(Contributors));
            s.horizontal_coefficients_size = (int)(GetTotalHorizontalCoefficients(s) * sizeof(float));
            s.vertical_contributors_size = (int)(s.vertical_num_contributors * sizeof(Contributors));
            s.vertical_coefficients_size = (int)(GetTotalVerticalCoefficients(s) * sizeof(float));
            s.decode_buffer_size = (int)((s.input_w + pixel_margin * 2) * s.channels * sizeof(float));
            s.horizontal_buffer_size = (int)(s.output_w * s.channels * sizeof(float));
            s.ring_buffer_length_bytes = s.output_w * s.channels * sizeof(float);
            s.ring_buffer_size = s.ring_buffer_length_bytes * s.ring_buffer_num_entries;
            s.encode_buffer_size = (int)(s.output_w * s.channels * sizeof(float));

            if ((UseHeightUpsampling(s)))
                s.horizontal_buffer_size = 0;
            else
                s.encode_buffer_size = 0;

            return
                s.horizontal_contributors_size +
                s.horizontal_coefficients_size +
                s.vertical_contributors_size +
                s.vertical_coefficients_size +
                s.decode_buffer_size +
                s.horizontal_buffer_size +
                s.ring_buffer_size +
                s.encode_buffer_size;
        }

        public static int ResizeAllocated(
            ref ResizeContext s,
            int alpha_channel, uint flags, DataType datatype,
            WrapMode wrap_horizontal, WrapMode wrap_vertical,
            ColorSpace colorspace,
            Span<byte> tmp_memory)
        {
            if (tmp_memory.IsEmpty)
                return 0;
            if ((s.horizontal_filter == null))
                return 0;
            if ((s.vertical_filter == null))
                return 0;
            if (((s.channels) < (0)) || ((s.channels) > (64)))
                return 0;
            if ((alpha_channel) >= (s.channels))
                return 0;

            if ((alpha_channel) < (0))
                flags |= (uint)((1 << 1) | (1 << 0));

            int memory_required = CalculateMemory(ref s);
            if ((tmp_memory.Length) < (memory_required))
                return 0;

            tmp_memory.Fill(0);

            s.alpha_channel = (int)(alpha_channel);
            s.flags = (uint)(flags);
            s.datatype = datatype;
            s.wrap_horizontal = (wrap_horizontal);
            s.wrap_vertical = (wrap_vertical);
            s.colorspace = colorspace;
            s.horizontal_coefficient_width =
                (int)(GetCoefficientWidth((s.horizontal_filter), (float)(s.horizontal_scale)));
            s.vertical_coefficient_width =
                (int)(GetCoefficientWidth((s.vertical_filter), (float)(s.vertical_scale)));
            s.horizontal_filter_pixel_width =
                (int)(GetFilterPixelWidth((s.horizontal_filter), (float)(s.horizontal_scale)));
            s.vertical_filter_pixel_width =
                (int)(GetFilterPixelWidth((s.vertical_filter), (float)(s.vertical_scale)));
            s.horizontal_filter_pixel_margin =
                (int)(GetFilterPixelMargin((s.horizontal_filter), (float)(s.horizontal_scale)));
            s.vertical_filter_pixel_margin =
                (int)(GetFilterPixelMargin((s.vertical_filter), (float)(s.vertical_scale)));

            s.decode_buffer_pixels = (int)(s.input_w + s.horizontal_filter_pixel_margin * 2);
            s.ring_buffer_begin_index = (int)(-1);

            s.horizontal_contributors = MemoryMarshal.Cast<byte, Contributors>(tmp_memory.Slice(0, s.horizontal_contributors_size));
            tmp_memory = tmp_memory.Slice(s.horizontal_contributors_size);

            s.horizontal_coefficients = MemoryMarshal.Cast<byte, float>(tmp_memory.Slice(0, s.horizontal_coefficients_size));
            tmp_memory = tmp_memory.Slice(s.horizontal_coefficients_size);

            s.vertical_contributors = MemoryMarshal.Cast<byte, Contributors>(tmp_memory.Slice(0, s.vertical_contributors_size));
            tmp_memory = tmp_memory.Slice(s.vertical_contributors_size);

            s.vertical_coefficients = MemoryMarshal.Cast<byte, float>(tmp_memory.Slice(0, s.vertical_coefficients_size));
            tmp_memory = tmp_memory.Slice(s.vertical_coefficients_size);

            s.decode_buffer = MemoryMarshal.Cast<byte, float>(tmp_memory.Slice(0, s.decode_buffer_size));
            tmp_memory = tmp_memory.Slice(s.decode_buffer_size);

            if ((UseHeightUpsampling(s)))
            {
                s.horizontal_buffer = default;

                s.ring_buffer = MemoryMarshal.Cast<byte, float>(tmp_memory.Slice(0, s.ring_buffer_size));
                tmp_memory = tmp_memory.Slice(s.ring_buffer_size);

                s.encode_buffer = MemoryMarshal.Cast<byte, float>(tmp_memory.Slice(0, s.encode_buffer_size));
                tmp_memory = tmp_memory.Slice(s.encode_buffer_size);
            }
            else
            {
                s.horizontal_buffer = MemoryMarshal.Cast<byte, float>(tmp_memory.Slice(0, s.horizontal_buffer_size));
                tmp_memory = tmp_memory.Slice(s.horizontal_buffer_size);

                s.ring_buffer = MemoryMarshal.Cast<byte, float>(tmp_memory.Slice(0, s.ring_buffer_size));
                tmp_memory = tmp_memory.Slice(s.ring_buffer_size);

                s.encode_buffer = default;
            }

            CalculateFilters(
                s.horizontal_contributors, s.horizontal_coefficients,
                (s.horizontal_filter), (float)(s.horizontal_scale), (float)(s.horizontal_shift),
                (int)(s.input_w), (int)(s.output_w));

            CalculateFilters(
                s.vertical_contributors, s.vertical_coefficients,
                (s.vertical_filter), (float)(s.vertical_scale), (float)(s.vertical_shift),
                (int)(s.input_h), (int)(s.output_h));

            if ((UseHeightUpsampling(s)))
                BufferLoopUpsample(ref s);
            else
                BufferLoopDownsample(ref s);
            return 1;
        }

        public static int ResizeArbitrary(
            ReadOnlySpan<byte> input_data, int input_w, int input_h, int input_stride_in_bytes,
            Span<byte> output_data, int output_w, int output_h, int output_stride_in_bytes,
            float s0, float t0, float s1, float t1, float* transform,
            int channels, int alpha_channel, uint flags, DataType datatype,
            Filter h_filter, Filter v_filter,
            WrapMode wrap_horizontal, WrapMode wrap_vertical,
            ColorSpace colorspace)
        {
            var s = new ResizeContext();
            Setup(ref s, (int)(input_w), (int)(input_h), (int)(output_w), (int)(output_h), (int)(channels));
            CalculateTransform(ref s, (float)(s0), (float)(t0), (float)(s1), (float)(t1), transform);
            ChooseFilters(ref s, (h_filter), (v_filter));

            int tmp_memory_required = CalculateMemory(ref s);
            void* tmp_memory = CRuntime.MAlloc(tmp_memory_required);
            if (tmp_memory == null)
                return 0;

            try
            {
                s.input_data = input_data;
                s.input_stride_bytes = (int)((input_stride_in_bytes) != 0
                        ? input_stride_in_bytes
                        : s.channels * s.input_w * datatype_size[(int)datatype]);

                s.output_data = output_data;
                s.output_stride_bytes = (int)((output_stride_in_bytes) != 0
                        ? output_stride_in_bytes
                        : s.channels * s.output_w * datatype_size[(int)datatype]);

                return (int)(ResizeAllocated(
                    ref s,
                    (int)(alpha_channel), (uint)(flags), datatype,
                    (wrap_horizontal), (wrap_vertical),
                    colorspace,
                    new Span<byte>(tmp_memory, tmp_memory_required)));
            }
            finally
            {
                CRuntime.Free(tmp_memory);
            }
        }

        public static unsafe long Hash(StbImageResize.ResizeContext x)
        {
            long hash = 17;
            hash = hash * 31 + x.input_w;
            hash = hash * 31 + x.input_h;
            hash = hash * 31 + x.input_stride_bytes;
            hash = hash * 31 + x.output_w;
            hash = hash * 31 + x.output_h;
            hash = hash * 31 + x.output_stride_bytes;
            hash = hash * 31 + x.s0.GetHashCode();
            hash = hash * 31 + x.t0.GetHashCode();
            hash = hash * 31 + x.s1.GetHashCode();
            hash = hash * 31 + x.t1.GetHashCode();
            hash = hash * 31 + x.horizontal_shift.GetHashCode();
            hash = hash * 31 + x.vertical_shift.GetHashCode();
            hash = hash * 31 + x.horizontal_scale.GetHashCode();
            hash = hash * 31 + x.vertical_scale.GetHashCode();
            hash = hash * 31 + x.channels;
            hash = hash * 31 + x.alpha_channel;
            hash = hash * 31 + x.flags;
            hash = hash * 31 + (int)x.datatype;
            //hash = hash * 31 + (int)x.horizontal_filter;
            //hash = hash * 31 + (int)x.vertical_filter;
            hash = hash * 31 + (int)x.wrap_horizontal;
            hash = hash * 31 + (int)x.wrap_vertical;
            hash = hash * 31 + (int)x.colorspace;
            hash = hash * 31 + x.horizontal_coefficient_width;
            hash = hash * 31 + x.vertical_coefficient_width;
            hash = hash * 31 + x.horizontal_filter_pixel_width;
            hash = hash * 31 + x.vertical_filter_pixel_width;
            hash = hash * 31 + x.horizontal_filter_pixel_margin;
            hash = hash * 31 + x.vertical_filter_pixel_margin;
            hash = hash * 31 + x.horizontal_num_contributors;
            hash = hash * 31 + x.vertical_num_contributors;
            hash = hash * 31 + x.ring_buffer_num_entries;
            hash = hash * 31 + x.ring_buffer_first_scanline;
            hash = hash * 31 + x.ring_buffer_last_scanline;
            hash = hash * 31 + x.ring_buffer_begin_index;
            hash = hash * 31 + x.horizontal_contributors_size;
            hash = hash * 31 + x.horizontal_coefficients_size;
            hash = hash * 31 + x.vertical_contributors_size;
            hash = hash * 31 + x.vertical_coefficients_size;
            hash = hash * 31 + x.decode_buffer_size;
            hash = hash * 31 + x.horizontal_buffer_size;
            hash = hash * 31 + x.ring_buffer_size;
            hash = hash * 31 + x.encode_buffer_size;
            hash = hash * 31 + x.decode_buffer_pixels;

            for (int i = 0; i < x.input_stride_bytes * x.input_h; i++)
            {
                if (x.input_data.IsEmpty)
                    continue;
                hash = hash * 31 + (x.input_data)[i];
            }
            for (int i = 0; i < x.output_stride_bytes * x.output_h; i++)
            {
                if (x.output_data.IsEmpty)
                    continue;
                hash = hash * 31 + (x.output_data)[i];
            }
            for (int i = 0; i < x.horizontal_contributors_size / sizeof(Contributors); i++)
            {
                if (x.horizontal_contributors == null)
                    continue;
                hash = hash * 31 + x.horizontal_contributors[i].n0;
                hash = hash * 31 + x.horizontal_contributors[i].n1;
            }
            for (int i = 0; i < x.horizontal_coefficients_size / sizeof(float); i++)
            {
                if (x.horizontal_coefficients == null)
                    continue;
                hash = hash * 31 + x.horizontal_coefficients[i].GetHashCode();
            }
            for (int i = 0; i < x.vertical_contributors_size / sizeof(Contributors); i++)
            {
                if (x.vertical_contributors == null)
                    continue;
                hash = hash * 31 + x.vertical_contributors[i].n0;
                hash = hash * 31 + x.vertical_contributors[i].n1;
            }
            for (int i = 0; i < x.vertical_coefficients_size / sizeof(float); i++)
            {
                if (x.vertical_coefficients == null)
                    continue;
                hash = hash * 31 + x.vertical_coefficients[i].GetHashCode();
            }
            for (int i = 0; i < x.decode_buffer_size / sizeof(float); i++)
            {
                if (x.decode_buffer == null)
                    continue;
                hash = hash * 31 + x.decode_buffer[i].GetHashCode();
            }
            for (int i = 0; i < x.horizontal_buffer_size / sizeof(float); i++)
            {
                if (x.horizontal_buffer == null)
                    continue;
                hash = hash * 31 + x.horizontal_buffer[i].GetHashCode();
            }
            for (int i = 0; i < x.ring_buffer_size / sizeof(float); i++)
            {
                if (x.ring_buffer == null)
                    continue;
                hash = hash * 31 + x.ring_buffer[i].GetHashCode();
            }
            for (int i = 0; i < x.encode_buffer_size / sizeof(float); i++)
            {
                if (x.encode_buffer == null)
                    continue;
                hash = hash * 31 + x.encode_buffer[i].GetHashCode();
            }
            return hash;
        }

        public static int Resize(
            ReadOnlySpan<byte> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<byte> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            int num_channels)
        {
            return (int)(ResizeArbitrary(
                input_pixels, (int)(input_w), (int)(input_h), (int)(input_stride_in_bytes),
                output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes),
                0f, 0f, 1f, 1f, null,
                (int)(num_channels), (int)(-1), (uint)(0), (int)(DataType.UInt8),
                null, null,
                (WrapMode.Clamp), (WrapMode.Clamp),
                ColorSpace.Linear));
        }

        public static int Resize(
            ReadOnlySpan<float> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<byte> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            int num_channels)
        {
            return (int)(ResizeArbitrary(
                MemoryMarshal.AsBytes(input_pixels), (int)(input_w), (int)(input_h), (int)(input_stride_in_bytes),
                output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes),
                0f, 0f, 1f, 1f, null,
                (int)(num_channels), (int)(-1), (uint)(0), DataType.Float,
                null, null,
                (WrapMode.Clamp), (WrapMode.Clamp),
                ColorSpace.Linear));
        }

        public static int ResizeSrgb(
            ReadOnlySpan<byte> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<byte> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            int num_channels, int alpha_channel, int flags)
        {
            return (int)(ResizeArbitrary(
                input_pixels, (int)(input_w), (int)(input_h), (int)(input_stride_in_bytes),
                output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes),
                0f, 0f, 1f, 1f, null,
                (int)(num_channels), (int)(alpha_channel), (uint)(flags), DataType.UInt8,
                null, null,
                (WrapMode.Clamp), (WrapMode.Clamp),
                ColorSpace.SRgb));
        }

        public static int ResizeSrgbEdgemode(
            ReadOnlySpan<byte> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<byte> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            int num_channels, int alpha_channel, int flags,
            WrapMode wrapmode)
        {
            return (int)(ResizeArbitrary(
                input_pixels, (int)(input_w), (int)(input_h), (int)(input_stride_in_bytes),
                output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes),
                0f, 0f, 1f, 1f, null,
                (int)(num_channels), (int)(alpha_channel), (uint)(flags), DataType.UInt8,
                null, null,
                (wrapmode), (wrapmode),
                ColorSpace.SRgb));
        }

        public static int ResizeGeneric(
            ReadOnlySpan<byte> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<byte> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            int num_channels, int alpha_channel, int flags,
            WrapMode wrapmode, Filter filter,
            ColorSpace colorspace)
        {
            return (int)(ResizeArbitrary(
                input_pixels, (int)(input_w), (int)(input_h),
                (int)(input_stride_in_bytes), output_pixels, (int)(output_w), (int)(output_h),
                (int)(output_stride_in_bytes),
                0f, 0f, 1f, 1f, null, (int)(num_channels),
                (int)(alpha_channel), (uint)(flags), DataType.UInt8,
                (filter), (filter),
                (wrapmode), (wrapmode),
                colorspace));
        }

        public static int ResizeGeneric(
            ReadOnlySpan<ushort> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<ushort> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            int num_channels, int alpha_channel, int flags,
            WrapMode wrapmode, Filter filter,
            ColorSpace colorspace)
        {
            return (int)(ResizeArbitrary(
                MemoryMarshal.AsBytes(input_pixels), (int)(input_w), (int)(input_h),
                (int)(input_stride_in_bytes), MemoryMarshal.AsBytes(output_pixels), (int)(output_w), (int)(output_h),
                (int)(output_stride_in_bytes),
                0f, 0f, 1f, 1f, null, (int)(num_channels),
                (int)(alpha_channel), (uint)(flags), DataType.UInt16,
                (filter), (filter),
                (wrapmode), (wrapmode),
                colorspace));
        }

        public static int ResizeGeneric(
            ReadOnlySpan<float> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<float> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            int num_channels, int alpha_channel, int flags,
            WrapMode wrapmode, Filter filter,
            ColorSpace colorspace)
        {
            return (int)(ResizeArbitrary(
                MemoryMarshal.AsBytes(input_pixels), (int)(input_w), (int)(input_h), (int)(input_stride_in_bytes),
                MemoryMarshal.AsBytes(output_pixels), (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes),
                0f, 0f, 1f, 1f, null,
                (int)(num_channels), (int)(alpha_channel), (uint)(flags), DataType.Float,
                (filter), (filter),
                (wrapmode), (wrapmode),
                colorspace));
        }

        public static int Resize(
            ReadOnlySpan<byte> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<byte> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            DataType datatype, int num_channels, int alpha_channel, int flags,
            WrapMode wrap_horizontal, WrapMode wrap_vertical,
            Filter filter_horizontal, Filter filter_vertical,
            ColorSpace colorspace)
        {
            return (int)(ResizeArbitrary(
                input_pixels, (int)(input_w), (int)(input_h), (int)(input_stride_in_bytes),
                output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes),
                0f, 0f, 1f, 1f, null,
                (int)(num_channels), (int)(alpha_channel), (uint)(flags), datatype,
                (filter_horizontal), (filter_vertical),
                (wrap_horizontal), (wrap_vertical),
                colorspace));
        }

        public static int ResizeSubpixel(
            ReadOnlySpan<byte> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<byte> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            DataType datatype, int num_channels, int alpha_channel, int flags,
            WrapMode wrap_horizontal, WrapMode wrap_vertical,
            Filter filter_horizontal, Filter filter_vertical,
            ColorSpace colorspace, void* alloc_context,
            float x_scale, float y_scale, float x_offset, float y_offset)
        {
            float* transform = stackalloc float[4];
            transform[0] = (float)(x_scale);
            transform[1] = (float)(y_scale);
            transform[2] = (float)(x_offset);
            transform[3] = (float)(y_offset);

            return (int)(ResizeArbitrary(
                input_pixels, (int)(input_w), (int)(input_h), (int)(input_stride_in_bytes),
                output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes),
                0f, 0f, 1f, 1f, transform,
                (int)(num_channels), (int)(alpha_channel), (uint)(flags), datatype,
                (filter_horizontal), (filter_vertical),
                (wrap_horizontal), (wrap_vertical),
                colorspace));
        }

        public static int ResizeRegion(
            ReadOnlySpan<byte> input_pixels, int input_w, int input_h, int input_stride_in_bytes,
            Span<byte> output_pixels, int output_w, int output_h, int output_stride_in_bytes,
            DataType datatype, int num_channels, int alpha_channel, int flags,
            WrapMode wrap_horizontal, WrapMode wrap_vertical,
            Filter filter_horizontal, Filter filter_vertical,
            ColorSpace colorspace,
            float s0, float t0, float s1, float t1)
        {
            return (int)(ResizeArbitrary(
                input_pixels, (int)(input_w), (int)(input_h), (int)(input_stride_in_bytes),
                output_pixels, (int)(output_w), (int)(output_h), (int)(output_stride_in_bytes),
                (float)(s0), (float)(t0), (float)(s1), (float)(t1), null,
                (int)(num_channels), (int)(alpha_channel), (uint)(flags), datatype,
                (filter_horizontal), (filter_vertical),
                (wrap_horizontal), (wrap_vertical),
                colorspace));
        }
    }
}