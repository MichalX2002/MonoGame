// Generated by Sichem at 1/28/2018 1:06:16 PM

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace StbSharp.ImageResize
{
    public static unsafe partial class ImageResize
    {
        private const int MAX_COLORSPACES = 2;

        private static ReadOnlySpan<byte> DataTypeSize => new byte[] {
            sizeof(byte),
            sizeof(ushort),
            sizeof(uint),
            sizeof(float)
        };

        private static float[] SrgbByteToLinearFloat { get; } = new[]
        {
            0.000000f, 0.000304f, 0.000607f, 0.000911f, 0.001214f, 0.001518f, 0.001821f, 0.002125f,
            0.002428f, 0.002732f, 0.003035f, 0.003347f, 0.003677f, 0.004025f, 0.004391f, 0.004777f,
            0.005182f, 0.005605f, 0.006049f, 0.006512f, 0.006995f, 0.007499f, 0.008023f, 0.008568f,
            0.009134f, 0.009721f, 0.010330f, 0.010960f, 0.011612f, 0.012286f, 0.012983f, 0.013702f,
            0.014444f, 0.015209f, 0.015996f, 0.016807f, 0.017642f, 0.018500f, 0.019382f, 0.020289f,
            0.021219f, 0.022174f, 0.023153f, 0.024158f, 0.025187f, 0.026241f, 0.027321f, 0.028426f,
            0.029557f, 0.030713f, 0.031896f, 0.033105f, 0.034340f, 0.035601f, 0.036889f, 0.038204f,
            0.039546f, 0.040915f, 0.042311f, 0.043735f, 0.045186f, 0.046665f, 0.048172f, 0.049707f,
            0.051269f, 0.052861f, 0.054480f, 0.056128f, 0.057805f, 0.059511f, 0.061246f, 0.063010f,
            0.064803f, 0.066626f, 0.068478f, 0.070360f, 0.072272f, 0.074214f, 0.076185f, 0.078187f,
            0.080220f, 0.082283f, 0.084376f, 0.086500f, 0.088656f, 0.090842f, 0.093059f, 0.095307f,
            0.097587f, 0.099899f, 0.102242f, 0.104616f, 0.107023f, 0.109462f, 0.111932f, 0.114435f,
            0.116971f, 0.119538f, 0.122139f, 0.124772f, 0.127438f, 0.130136f, 0.132868f, 0.135633f,
            0.138432f, 0.141263f, 0.144128f, 0.147027f, 0.149960f, 0.152926f, 0.155926f, 0.158961f,
            0.162029f, 0.165132f, 0.168269f, 0.171441f, 0.174647f, 0.177888f, 0.181164f, 0.184475f,
            0.187821f, 0.191202f, 0.194618f, 0.198069f, 0.201556f, 0.205079f, 0.208637f, 0.212231f,
            0.215861f, 0.219526f, 0.223228f, 0.226966f, 0.230740f, 0.234551f, 0.238398f, 0.242281f,
            0.246201f, 0.250158f, 0.254152f, 0.258183f, 0.262251f, 0.266356f, 0.270498f, 0.274677f,
            0.278894f, 0.283149f, 0.287441f, 0.291771f, 0.296138f, 0.300544f, 0.304987f, 0.309469f,
            0.313989f, 0.318547f, 0.323143f, 0.327778f, 0.332452f, 0.337164f, 0.341914f, 0.346704f,
            0.351533f, 0.356400f, 0.361307f, 0.366253f, 0.371238f, 0.376262f, 0.381326f, 0.386430f,
            0.391573f, 0.396755f, 0.401978f, 0.407240f, 0.412543f, 0.417885f, 0.423268f, 0.428691f,
            0.434154f, 0.439657f, 0.445201f, 0.450786f, 0.456411f, 0.462077f, 0.467784f, 0.473532f,
            0.479320f, 0.485150f, 0.491021f, 0.496933f, 0.502887f, 0.508881f, 0.514918f, 0.520996f,
            0.527115f, 0.533276f, 0.539480f, 0.545725f, 0.552011f, 0.558340f, 0.564712f, 0.571125f,
            0.577581f, 0.584078f, 0.590619f, 0.597202f, 0.603827f, 0.610496f, 0.617207f, 0.623960f,
            0.630757f, 0.637597f, 0.644480f, 0.651406f, 0.658375f, 0.665387f, 0.672443f, 0.679543f,
            0.686685f, 0.693872f, 0.701102f, 0.708376f, 0.715694f, 0.723055f, 0.730461f, 0.737911f,
            0.745404f, 0.752942f, 0.760525f, 0.768151f, 0.775822f, 0.783538f, 0.791298f, 0.799103f,
            0.806952f, 0.814847f, 0.822786f, 0.830770f, 0.838799f, 0.846873f, 0.854993f, 0.863157f,
            0.871367f, 0.879622f, 0.887923f, 0.896269f, 0.904661f, 0.913099f, 0.921582f, 0.930111f,
            0.938686f, 0.947307f, 0.955974f, 0.964686f, 0.973445f, 0.982251f, 0.991102f, 1.000000f
        };

        private static uint[] float_to_srgb8_tab4 { get; } = new uint[]
        {
            0x0073000d, 0x007a000d, 0x0080000d, 0x0087000d, 0x008d000d, 0x0094000d, 0x009a000d, 0x00a1000d,
            0x00a7001a, 0x00b4001a, 0x00c1001a, 0x00ce001a, 0x00da001a, 0x00e7001a, 0x00f4001a, 0x0101001a,
            0x010e0033, 0x01280033, 0x01410033, 0x015b0033, 0x01750033, 0x018f0033, 0x01a80033, 0x01c20033,
            0x01dc0067, 0x020f0067, 0x02430067, 0x02760067, 0x02aa0067, 0x02dd0067, 0x03110067, 0x03440067,
            0x037800ce, 0x03df00ce, 0x044600ce, 0x04ad00ce, 0x051400ce, 0x057b00c5, 0x05dd00bc, 0x063b00b5,
            0x06970158, 0x07420142, 0x07e30130, 0x087b0120, 0x090b0112, 0x09940106, 0x0a1700fc, 0x0a9500f2,
            0x0b0f01cb, 0x0bf401ae, 0x0ccb0195, 0x0d950180, 0x0e56016e, 0x0f0d015e, 0x0fbc0150, 0x10630143,
            0x11070264, 0x1238023e, 0x1357021d, 0x14660201, 0x156601e9, 0x165a01d3, 0x174401c0, 0x182401af,
            0x18fe0331, 0x1a9602fe, 0x1c1502d2, 0x1d7e02ad, 0x1ed4028d, 0x201a0270, 0x21520256, 0x227d0240,
            0x239f0443, 0x25c003fe, 0x27bf03c4, 0x29a10392, 0x2b6a0367, 0x2d1d0341, 0x2ebe031f, 0x304d0300,
            0x31d105b0, 0x34a80555, 0x37520507, 0x39d504c5, 0x3c37048b, 0x3e7c0458, 0x40a8042a, 0x42bd0401,
            0x44c20798, 0x488e071e, 0x4c1c06b6, 0x4f76065d, 0x52a50610, 0x55ac05cc, 0x5892058f, 0x5b590559,
            0x5e0c0a23, 0x631c0980, 0x67db08f6, 0x6c55087f, 0x70940818, 0x74a007bd, 0x787d076c, 0x7c330723
        };

        public static float Saturate(float x)
        {
            if (x < 0)
                return 0f;
            if (x > 1)
                return 1f;
            return (float)x;
        }

        public static float SrgbToLinear(float f)
        {
            if (f <= 0.04045f)
                return (float)(f / 12.92f);
            else
                return MathF.Pow((f + 0.055f) / 1.055f, 2.4f);
        }

        public static float LinearToSrgb(float f)
        {
            if (f <= 0.0031308f)
                return (float)(f * 12.92f);
            else
                return 1.055f * MathF.Pow(f, 1 / 2.4f) - 0.055f;
        }

        public static float FilterTrapezoid(float x, float scale)
        {
            float halfscale = (float)(scale / 2);
            float t = (float)(0.5f + halfscale);

            x = MathF.Abs(x);
            if (x >= t)
            {
                return 0f;
            }
            else
            {
                float r = (float)(0.5f - halfscale);
                if (x <= r)
                    return 1f;
                else
                    return (float)((t - x) / scale);
            }
        }

        public static float SupportTrapezoid(float scale)
        {
            return (float)(0.5f + scale / 2);
        }

        public static float FilterTriangle(float x, float s)
        {
            x = (float)MathF.Abs(x);
            if (x <= 1f)
                return (float)(1 - x);
            else
                return 0f;
        }

        public static float FilterCubic(float x, float s)
        {
            x = (float)MathF.Abs(x);
            if (x < 1f)
                return (float)((4 + x * x * (3 * x - 6)) / 6);
            else if (x < 2.0f)
                return (float)((8 + x * (-12 + x * (6 - x))) / 6);
            return (float)0f;
        }

        public static float FilterCatmullRom(float x, float s)
        {
            x = (float)MathF.Abs(x);
            if (x < 1f)
                return (float)(1 - x * x * (2.5f - 1.5f * x));
            else if (x < 2.0f)
                return (float)(2 - x * (4 + x * (0.5f * x - 2.5f)));
            return (float)0f;
        }

        public static float FilterMitchell(float x, float s)
        {
            x = (float)MathF.Abs(x);
            if (x < 1f)
                return (float)((16 + x * x * (21 * x - 36)) / 18);
            else if (x < 2.0f)
                return (float)((32 + x * (-60 + x * (36 - 7 * x))) / 18);
            return (float)0f;
        }

        public static float SupportZero(float s) => 0f;
        public static float SupportOne(float s) => 1f;
        public static float SupportTwo(float s) => 2f;

        public static bool UseUpsampling(float ratio)
        {
            return ratio > 1;
        }

        public static bool UseWidthUpsampling(in ResizeContext context)
        {
            return UseUpsampling(context.horizontal_scale);
        }

        public static bool UseHeightUpsampling(in ResizeContext context)
        {
            return UseUpsampling(context.vertical_scale);
        }

        public static int GetFilterPixelWidth(Filter filter, float scale)
        {
            Debug.Assert(filter != null);

            if (UseUpsampling((float)scale))
                return (int)MathF.Ceiling(filter.Support(1 / scale) * 2);
            else
                return (int)MathF.Ceiling(filter.Support(scale) * 2 / scale);
        }

        public static int GetFilterPixelMargin(Filter filter, float scale)
        {
            return GetFilterPixelWidth(filter, (float)scale) / 2;
        }

        public static int GetCoefficientWidth(Filter filter, float scale)
        {
            Debug.Assert(filter != null);

            if (UseUpsampling((float)scale))
                return (int)MathF.Ceiling(filter.Support(1 / scale) * 2);
            else
                return (int)MathF.Ceiling(filter.Support(scale) * 2);
        }

        public static int GetContributors(float scale, Filter filter, int inputSize, int outputSize)
        {
            if (UseUpsampling((float)scale))
                return outputSize;
            else
                return inputSize + GetFilterPixelMargin(filter, scale) * 2;
        }

        public static int GetTotalHorizontalCoefficients(in ResizeContext info)
        {
            return info.horizontal_num_contributors *
                 GetCoefficientWidth(info.horizontal_filter, info.horizontal_scale);
        }

        public static int GetTotalVerticalCoefficients(in ResizeContext info)
        {
            return info.vertical_num_contributors *
                 GetCoefficientWidth(info.vertical_filter, info.vertical_scale);
        }

        public static Span<float> GetCoefficients(
            Span<float> coefficients, Filter filter, float scale, int y, int x)
        {
            int width = GetCoefficientWidth(filter, (float)scale);
            return coefficients.Slice(width * y + x);
        }

        public static int EdgeWrapSlow(WrapMode wrap, int n, int max)
        {
            switch (wrap)
            {
                case WrapMode.Clamp:
                    if (n < 0)
                        return 0;
                    if (n >= max)
                        return max - 1;
                    return n;

                case WrapMode.Reflect:
                    if (n < 0)
                    {
                        if (n < max)
                            return -n;
                        else
                            return max - 1;
                    }
                    if (n >= max)
                    {
                        int max2 = max * 2;
                        if (n >= max2)
                            return 0;
                        else
                            return max2 - n - 1;
                    }
                    return n;

                case WrapMode.Wrap:
                    if (n >= 0)
                    {
                        return n % max;
                    }
                    else
                    {
                        int m = (-n) % max;
                        if (m != 0)
                            m = max - m;
                        return m;
                    }

                case WrapMode.Zero:
                default:
                    return 0;
            }

        }

        public static int EdgeWrap(WrapMode wrap, int n, int max)
        {
            if ((n >= 0) && (n < max))
                return n;
            return EdgeWrapSlow(wrap, n, max);
        }

        public static void CalculateSampleRangeUpsample(
            int n, float outFilterRadius, float scaleRatio, float outShift,
            out int inFirstPixel, out int inLastPixel, out float inCenterOfOut)
        {
            float out_pixel_center = (float)(n + 0.5f);
            float out_pixel_influence_lowerbound = (float)(out_pixel_center - outFilterRadius);
            float out_pixel_influence_upperbound = (float)(out_pixel_center + outFilterRadius);
            float in_pixel_influence_lowerbound = (float)((out_pixel_influence_lowerbound + outShift) / scaleRatio);
            float in_pixel_influence_upperbound = (float)((out_pixel_influence_upperbound + outShift) / scaleRatio);
            inCenterOfOut = (float)((out_pixel_center + outShift) / scaleRatio);
            inFirstPixel = (int)Math.Floor((double)(in_pixel_influence_lowerbound + 0.5));
            inLastPixel = (int)Math.Floor((double)(in_pixel_influence_upperbound - 0.5));
        }

        public static void CalculateSampleRangeDownsample(
            int n, float inPixelsRadius, float scaleRatio, float outShift,
            out int outFirstPixel, out int outLastPixel, out float outCenterOfIn)
        {
            float in_pixel_center = (float)(n + 0.5f);
            float in_pixel_influence_lowerbound = (float)(in_pixel_center - inPixelsRadius);
            float in_pixel_influence_upperbound = (float)(in_pixel_center + inPixelsRadius);
            float out_pixel_influence_lowerbound = (float)(in_pixel_influence_lowerbound * scaleRatio - outShift);
            float out_pixel_influence_upperbound = (float)(in_pixel_influence_upperbound * scaleRatio - outShift);
            outCenterOfIn = (float)(in_pixel_center * scaleRatio - outShift);
            outFirstPixel = (int)Math.Floor((double)(out_pixel_influence_lowerbound + 0.5));
            outLastPixel = (int)Math.Floor((double)(out_pixel_influence_upperbound - 0.5));
        }

        public static void CalculateCoefficientsUpsample(
            Filter filter, float scale,
            int inFirstPixel, int inLastPixel, float inCenterOfOut,
            ref Contributors contributor, Span<float> coefficientGroup)
        {
            Debug.Assert(filter != null);

            float total_filter = 0f;
            float filter_scale;
            contributor.n0 = inFirstPixel;
            contributor.n1 = inLastPixel;

            for (int i = 0; i <= inLastPixel - inFirstPixel; i++)
            {
                float in_pixel_center = (float)(i + inFirstPixel + 0.5f);
                coefficientGroup[i] = filter.Kernel(inCenterOfOut - in_pixel_center, 1 / scale);

                if ((i == 0) && (coefficientGroup[i] == 0))
                {
                    contributor.n0 = ++inFirstPixel;
                    i--;
                    continue;
                }
                total_filter += (float)coefficientGroup[i];
            }

            filter_scale = (float)(1 / total_filter);
            for (int i = 0; i <= inLastPixel - inFirstPixel; i++)
                coefficientGroup[i] *= (float)filter_scale;

            for (int i = inLastPixel - inFirstPixel; i >= 0; i--)
            {
                if (coefficientGroup[i] != 0)
                    break;
                contributor.n1 = contributor.n0 + i - 1;
            }
        }

        public static void CalculateCoefficientsDownsample(
            Filter filter, float scaleRatio,
            int outFirstPixel, int outLastPixel, float outCenterOfIn,
            ref Contributors contributor, Span<float> coefficientGroup)
        {
            Debug.Assert(filter != null);

            contributor.n0 = outFirstPixel;
            contributor.n1 = outLastPixel;

            for (int i = 0; i <= outLastPixel - outFirstPixel; i++)
            {
                float out_pixel_center = (float)(i + outFirstPixel + 0.5f);
                float x = (float)(out_pixel_center - outCenterOfIn);
                coefficientGroup[i] = filter.Kernel(x, scaleRatio) * scaleRatio;
            }

            for (int i = outLastPixel - outFirstPixel; i >= 0; i--)
            {
                if (coefficientGroup[i] != 0)
                    break;

                contributor.n1 = contributor.n0 + i - 1;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ref float GetCoefficient(Span<float> coefficients, int width, int y, int x)
        {
            return ref coefficients[width * y + x];
        }

        public static void NormalizeDownsampleCoefficients(
            Span<Contributors> contributors, Span<float> coefficients,
            Filter filter, float scaleRatio, float shift, int inputSize, int outputSize)
        {
            int coefficient_width = GetCoefficientWidth(filter, scaleRatio);
            int num_contributors = GetContributors(scaleRatio, filter, inputSize, outputSize);

            for (int i = 0; i < outputSize; i++)
            {
                float total = 0f;
                for (int j = 0; j < num_contributors; j++)
                {
                    ref Contributors contrib = ref contributors[j];
                    if ((i >= contrib.n0) && (i <= contrib.n1))
                    {
                        float coefficient = GetCoefficient(coefficients, coefficient_width, j, i - contrib.n0);
                        total += coefficient;
                    }
                    else if (i < contrib.n0)
                        break;
                }

                float scale = (float)(1f / total);
                for (int j = 0; j < num_contributors; j++)
                {
                    ref Contributors contrib = ref contributors[j];
                    if ((i >= contrib.n0) && (i <= contrib.n1))
                    {
                        GetCoefficient(coefficients, coefficient_width, j, i - contrib.n0) *= scale;
                    }
                    else if (i < contrib.n0)
                        break;
                }
            }

            int skip;
            for (int j = 0; j < num_contributors; j++)
            {
                skip = 0;
                while (GetCoefficient(coefficients, coefficient_width, j, skip) == 0)
                    skip++;

                ref Contributors contrib = ref contributors[j];
                contrib.n0 += skip;
                while (contrib.n0 < 0)
                {
                    contrib.n0++;
                    skip++;
                }

                int range = contrib.n1 - contrib.n0 + 1;
                int max = Math.Min(coefficient_width, range);
                for (int i = 0; i < max; i++)
                {
                    if ((i + skip) >= coefficient_width)
                        break;

                    GetCoefficient(coefficients, coefficient_width, j, i) =
                        GetCoefficient(coefficients, coefficient_width, j, i + skip);
                }
            }

            for (int i = 0; i < num_contributors; i++)
            {
                ref Contributors contrib = ref contributors[i];
                contrib.n1 = Math.Min(contrib.n1, outputSize - 1);
            }
        }

        public static void CalculateFilters(
            Span<Contributors> contributors, Span<float> coefficients,
            Filter filter, float scaleRatio, float shift, int inputSize, int outputSize)
        {
            Debug.Assert(filter != null);

            int total_contributors = GetContributors(scaleRatio, filter, inputSize, outputSize);
            if (UseUpsampling((float)scaleRatio))
            {
                float out_pixels_radius = filter.Support(1 / scaleRatio) * scaleRatio;
                for (int y = 0; y < total_contributors; y++)
                {
                    CalculateSampleRangeUpsample(
                        y, (float)out_pixels_radius, (float)scaleRatio, (float)shift,
                        out int in_first_pixel, out int in_last_pixel, out float in_center_of_out);

                    CalculateCoefficientsUpsample(
                        filter, (float)scaleRatio,
                        in_first_pixel, in_last_pixel, (float)in_center_of_out,
                        ref contributors[y],
                        GetCoefficients(coefficients, filter, (float)scaleRatio, y, 0));
                }
            }
            else
            {
                float in_pixels_radius = filter.Support(scaleRatio) / scaleRatio;
                for (int y = 0; y < total_contributors; y++)
                {
                    int n_adjusted = y - GetFilterPixelMargin(filter, (float)scaleRatio);

                    CalculateSampleRangeDownsample(
                        n_adjusted, (float)in_pixels_radius, (float)scaleRatio, (float)shift,
                        out int out_first_pixel, out int out_last_pixel, out float out_center_of_in);

                    CalculateCoefficientsDownsample(
                        filter, (float)scaleRatio,
                        out_first_pixel, out_last_pixel, (float)out_center_of_in,
                        ref contributors[y],
                        GetCoefficients(coefficients, filter, (float)scaleRatio, y, 0));
                }

                NormalizeDownsampleCoefficients(
                    contributors, coefficients, filter, (float)scaleRatio, (float)shift,
                    inputSize, outputSize);
            }
        }

        public static int GetDecodeBufferOffset(in ResizeContext context)
        {
            return context.horizontal_filter_pixel_margin * context.channels;
        }

        public static void DecodeScanline(in ResizeContext context, int y)
        {
            int in_buffer_row_offset = EdgeWrap(context.wrap_vertical, y, context.input_h) * context.input_stride_bytes;
            var input_data = context.input_data.Slice(in_buffer_row_offset);
            int max_x = context.input_w + context.horizontal_filter_pixel_margin;
            int decode = (int)context.datatype * MAX_COLORSPACES + (int)context.colorspace;
            int x = -context.horizontal_filter_pixel_margin;
            int c = 0;

            fixed (float* decode_buffer_ptr = context.decode_buffer)
            {
                var dst = decode_buffer_ptr + GetDecodeBufferOffset(context);

                if ((context.wrap_vertical == WrapMode.Zero) &&
                    ((y < 0) || (y >= context.input_h)))
                {
                    for (; x < max_x; x++)
                    {
                        for (c = 0; c < context.channels; c++)
                            dst[x * context.channels + c] = 0;
                    }
                    return;
                }

                fixed (byte* src8 = input_data)
                {
                    var src16 = (ushort*)src8;
                    var src32 = (uint*)src8;
                    var srcF = (float*)src8;

                    bool srgbAlpha = (context.flags & (1 << 1)) == 0;
                    switch (decode)
                    {
                        case ((int)DataType.UInt8) * MAX_COLORSPACES + (int)ColorSpace.Linear:
                            for (; x < max_x; x++)
                            {
                                int dst_pixel_index = x * context.channels;
                                int src_pixel_index = EdgeWrap(context.wrap_horizontal, x, context.input_w) * context.channels;
                                for (c = 0; c < context.channels; c++)
                                    dst[dst_pixel_index + c] = src8[src_pixel_index + c] / 255f;
                            }
                            break;

                        case ((int)DataType.UInt8) * MAX_COLORSPACES + (int)ColorSpace.SRgb:
                            fixed (float* srgbToFloat = SrgbByteToLinearFloat)
                            {
                                for (; x < max_x; x++)
                                {
                                    int dst_pixel_index = x * context.channels;
                                    int src_pixel_index = EdgeWrap(context.wrap_horizontal, x, context.input_w) * context.channels;
                                    for (c = 0; c < context.channels; c++)
                                        dst[dst_pixel_index + c] = srgbToFloat[src8[src_pixel_index + c]];

                                    if (srgbAlpha)
                                        dst[dst_pixel_index + context.alpha_channel] =
                                            src8[src_pixel_index + context.alpha_channel] / 255f;
                                }
                            }
                            break;

                        case ((int)DataType.UInt16) * MAX_COLORSPACES + (int)ColorSpace.Linear:
                        {
                            for (; x < max_x; x++)
                            {
                                int dst_pixel_index = x * context.channels;
                                int src_pixel_index = EdgeWrap(context.wrap_horizontal, x, context.input_w) * context.channels;
                                for (c = 0; c < context.channels; c++)
                                    dst[dst_pixel_index + c] = src16[src_pixel_index + c] / 65535f;
                            }
                            break;
                        }

                        case ((int)DataType.UInt16) * MAX_COLORSPACES + (int)ColorSpace.SRgb:
                        {
                            for (; x < max_x; x++)
                            {
                                int dst_pixel_index = x * context.channels;
                                int src_pixel_index = EdgeWrap(context.wrap_horizontal, x, context.input_w) * context.channels;
                                for (c = 0; c < context.channels; c++)
                                    dst[dst_pixel_index + c] = SrgbToLinear(src16[src_pixel_index + c] / 65535f);

                                if (srgbAlpha)
                                    dst[dst_pixel_index + context.alpha_channel] =
                                        src16[src_pixel_index + context.alpha_channel] / 65535f;
                            }
                            break;
                        }

                        case ((int)DataType.UInt32) * MAX_COLORSPACES + (int)ColorSpace.Linear:
                        {
                            for (; x < max_x; x++)
                            {
                                int dst_pixel_index = x * context.channels;
                                int src_pixel_index = EdgeWrap(context.wrap_horizontal, x, context.input_w) * context.channels;
                                for (c = 0; c < context.channels; c++)
                                    dst[dst_pixel_index + c] = (float)(src32[src_pixel_index + c] / 4294967295d);
                            }
                            break;
                        }

                        case ((int)DataType.UInt32) * MAX_COLORSPACES + (int)ColorSpace.SRgb:
                        {
                            for (; x < max_x; x++)
                            {
                                int dst_pixel_index = x * context.channels;
                                int src_pixel_index = EdgeWrap(context.wrap_horizontal, x, context.input_w) * context.channels;
                                for (c = 0; c < context.channels; c++)
                                    dst[dst_pixel_index + c] = SrgbToLinear(
                                        (float)(src32[src_pixel_index + c] / 4294967295d));

                                if (srgbAlpha)
                                    dst[dst_pixel_index + context.alpha_channel] =
                                        (float)(src32[src_pixel_index + context.alpha_channel] / 4294967295d);
                            }
                            break;
                        }

                        case ((int)DataType.Float32) * MAX_COLORSPACES + (int)ColorSpace.Linear:
                        {
                            for (; x < max_x; x++)
                            {
                                int dst_pixel_index = x * context.channels;
                                int src_pixel_index = EdgeWrap(context.wrap_horizontal, x, context.input_w) * context.channels;
                                for (c = 0; c < context.channels; c++)
                                    dst[dst_pixel_index + c] = srcF[src_pixel_index + c];
                            }
                            break;
                        }

                        case ((int)DataType.Float32) * MAX_COLORSPACES + (int)ColorSpace.SRgb:
                        {
                            for (; x < max_x; x++)
                            {
                                int dst_pixel_index = x * context.channels;
                                int src_pixel_index = EdgeWrap(context.wrap_horizontal, x, context.input_w) * context.channels;
                                for (c = 0; c < context.channels; c++)
                                    dst[dst_pixel_index + c] = SrgbToLinear(srcF[src_pixel_index + c]);

                                if (srgbAlpha)
                                    dst[dst_pixel_index + context.alpha_channel] = srcF[src_pixel_index + context.alpha_channel];
                            }
                            break;
                        }
                    }
                }

                if ((context.flags & (1 << 0)) == 0)
                {
                    for (x = -context.horizontal_filter_pixel_margin; x < max_x; x++)
                    {
                        int dst_pixel_index = x * context.channels;
                        float alpha = dst[dst_pixel_index + context.alpha_channel];
                        if (context.datatype != DataType.Float32)
                        {
                            alpha += 1f / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20);
                            dst[dst_pixel_index + context.alpha_channel] = alpha;
                        }

                        for (c = 0; c < context.channels; c++)
                        {
                            if (c == context.alpha_channel)
                                continue;
                            dst[dst_pixel_index + c] *= alpha;
                        }
                    }
                }

                if (context.wrap_horizontal == WrapMode.Zero)
                {
                    for (x = -context.horizontal_filter_pixel_margin; x < 0; x++)
                        for (c = 0; c < context.channels; c++)
                            dst[x * context.channels + c] = 0;

                    for (x = context.input_w; x < max_x; x++)
                        for (c = 0; c < context.channels; c++)
                            dst[x * context.channels + c] = 0;
                }
            }
        }

        public static Span<float> GetRingBufferEntry(Span<float> ringBuffer, int index, int length)
        {
            return ringBuffer.Slice(index * length, length);
        }

        public static Span<float> AddEmptyRingBufferEntry(ref ResizeContext context, int n)
        {
            int ring_buffer_index;
            context.ring_buffer_last_scanline = n;
            if (context.ring_buffer_begin_index < 0)
            {
                ring_buffer_index = context.ring_buffer_begin_index = 0;
                context.ring_buffer_first_scanline = n;
            }
            else
            {
                ring_buffer_index =
                    (context.ring_buffer_begin_index +
                    context.ring_buffer_last_scanline -
                    context.ring_buffer_first_scanline) %
                    context.ring_buffer_num_entries;
            }

            Span<float> ring_buffer = GetRingBufferEntry(
                context.ring_buffer, ring_buffer_index, context.RingBufferLength);

            ring_buffer.Clear();

            return ring_buffer;
        }

        public static void ResampleHorizontalUpsample(in ResizeContext context, Span<float> destination)
        {
            int output_w = context.output_w;
            int kernel_pixel_width = context.horizontal_filter_pixel_width;
            int channels = context.channels;
            int coefficient_width = context.horizontal_coefficient_width;

            fixed (float* dst = destination)
            fixed (float* horizontal_coefficients_ptr = context.horizontal_coefficients)
            fixed (float* decode_buffer_ptr = context.decode_buffer)
            {
                float* src = decode_buffer_ptr + GetDecodeBufferOffset(context);

                int k;
                for (int x = 0; x < output_w; x++)
                {
                    ref var contrib = ref context.horizontal_contributors[x];
                    int n0 = contrib.n0;
                    int n1 = contrib.n1;

                    int dst_pixel_index = x * channels;
                    int coefficient_group = coefficient_width * x;
                    float* horizontal_coefficients = horizontal_coefficients_ptr + coefficient_group;

                    switch (channels)
                    {
                        case 1:
                            for (k = n0; k <= n1; k++)
                            {
                                int src_pixel_index = k * 1;
                                float coefficient = *horizontal_coefficients++;
                                dst[dst_pixel_index + 0] += src[src_pixel_index + 0] * coefficient;
                            }
                            break;

                        case 2:
                            for (k = n0; k <= n1; k++)
                            {
                                int src_pixel_index = k * 2;
                                float coefficient = *horizontal_coefficients++;
                                dst[dst_pixel_index + 0] += src[src_pixel_index + 0] * coefficient;
                                dst[dst_pixel_index + 1] += src[src_pixel_index + 1] * coefficient;
                            }
                            break;

                        case 3:
                            for (k = n0; k <= n1; k++)
                            {
                                int src_pixel_index = k * 3;
                                float coefficient = *horizontal_coefficients++;
                                dst[dst_pixel_index + 0] += src[src_pixel_index + 0] * coefficient;
                                dst[dst_pixel_index + 1] += src[src_pixel_index + 1] * coefficient;
                                dst[dst_pixel_index + 2] += src[src_pixel_index + 2] * coefficient;
                            }
                            break;

                        case 4:
                            for (k = n0; k <= n1; k++)
                            {
                                int src_pixel_index = k * 4;
                                float coefficient = *horizontal_coefficients++;
                                dst[dst_pixel_index + 0] += src[src_pixel_index + 0] * coefficient;
                                dst[dst_pixel_index + 1] += src[src_pixel_index + 1] * coefficient;
                                dst[dst_pixel_index + 2] += src[src_pixel_index + 2] * coefficient;
                                dst[dst_pixel_index + 3] += src[src_pixel_index + 3] * coefficient;
                            }
                            break;

                        default:
                            int c;
                            for (k = n0; k <= n1; k++)
                            {
                                int src_pixel_index = k * channels;
                                float coefficient = *horizontal_coefficients++;
                                for (c = 0; c < channels; c++)
                                    dst[dst_pixel_index + c] += src[src_pixel_index + c] * coefficient;
                            }
                            break;
                    }
                }
            }
        }

        public static void ResampleHorizontalDownsample(in ResizeContext context, Span<float> destination)
        {
            int x;
            int k;
            int c;
            int input_w = context.input_w;
            int output_w = context.output_w;
            int kernel_pixel_width = context.horizontal_filter_pixel_width;
            int channels = context.channels;
            var horizontal_contributors = context.horizontal_contributors;
            int coefficient_width = context.horizontal_coefficient_width;
            int filter_pixel_margin = context.horizontal_filter_pixel_margin;
            int max_x = input_w + filter_pixel_margin * 2;

            fixed (float* horizontal_coefficients_ptr = context.horizontal_coefficients)
            fixed (float* decode_buffer_ptr = context.decode_buffer)
            fixed (float* dst = destination)
            {
                float* src = decode_buffer_ptr + GetDecodeBufferOffset(context);

                switch (channels)
                {
                    case 1:
                        for (x = 0; x < max_x; x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = contrib.n0;
                            int max_n = contrib.n1;

                            int in_x = x - filter_pixel_margin;
                            int in_pixel_index = in_x * 1;

                            int coefficient_group = coefficient_width * x;
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = n0; k <= max_n; k++)
                            {
                                int out_pixel_index = k * 1;
                                float coefficient = (float)coefficients[k - n0];
                                dst[out_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                            }
                        }
                        break;

                    case 2:
                        for (x = 0; x < max_x; x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = contrib.n0;
                            int max_n = contrib.n1;

                            int in_x = x - filter_pixel_margin;
                            int in_pixel_index = in_x * 2;

                            int coefficient_group = coefficient_width * x;
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = n0; k <= max_n; k++)
                            {
                                int out_pixel_index = k * 2;
                                float coefficient = (float)coefficients[k - n0];
                                dst[out_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                dst[out_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                            }
                        }
                        break;

                    case 3:
                        for (x = 0; x < max_x; x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = contrib.n0;
                            int max_n = contrib.n1;

                            int in_x = x - filter_pixel_margin;
                            int in_pixel_index = in_x * 3;

                            int coefficient_group = coefficient_width * x;
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = n0; k <= max_n; k++)
                            {
                                int out_pixel_index = k * 3;
                                float coefficient = coefficients[k - n0];
                                dst[out_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                dst[out_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                                dst[out_pixel_index + 2] += src[in_pixel_index + 2] * coefficient;
                            }
                        }
                        break;

                    case 4:
                        for (x = 0; x < max_x; x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = contrib.n0;
                            int max_n = contrib.n1;

                            int in_x = x - filter_pixel_margin;
                            int in_pixel_index = in_x * 4;

                            int coefficient_group = coefficient_width * x;
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = n0; k <= max_n; k++)
                            {
                                int out_pixel_index = k * 4;
                                float coefficient = (float)coefficients[k - n0];
                                dst[out_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                dst[out_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                                dst[out_pixel_index + 2] += src[in_pixel_index + 2] * coefficient;
                                dst[out_pixel_index + 3] += src[in_pixel_index + 3] * coefficient;
                            }
                        }
                        break;

                    default:
                        for (x = 0; x < max_x; x++)
                        {
                            ref var contrib = ref horizontal_contributors[x];
                            int n0 = contrib.n0;
                            int max_n = contrib.n1;

                            int in_x = x - filter_pixel_margin;
                            int in_pixel_index = in_x * channels;

                            int coefficient_group = coefficient_width * x;
                            float* coefficients = horizontal_coefficients_ptr + coefficient_group;

                            for (k = n0; k <= max_n; k++)
                            {
                                int out_pixel_index = k * channels;
                                float coefficient = (float)coefficients[k - n0];
                                for (c = 0; c < channels; c++)
                                    dst[out_pixel_index + c] += src[in_pixel_index + c] * coefficient;
                            }
                        }
                        break;
                }
            }
        }

        public static void DecodeAndResampleUpsample(ref ResizeContext context, int n)
        {
            DecodeScanline(context, n);

            if (UseWidthUpsampling(context))
                ResampleHorizontalUpsample(context, AddEmptyRingBufferEntry(ref context, n));
            else
                ResampleHorizontalDownsample(context, AddEmptyRingBufferEntry(ref context, n));
        }

        public static void DecodeAndResampleDownsample(in ResizeContext context, int y)
        {
            DecodeScanline(context, y);
            context.horizontal_buffer.Clear();

            if (UseWidthUpsampling(context))
                ResampleHorizontalUpsample(context, context.horizontal_buffer);
            else
                ResampleHorizontalDownsample(context, context.horizontal_buffer);
        }

        public static Span<float> GetRingBufferScanline(
            int getScanline, Span<float> ringBuffer, int beginIndex,
            int firstScanline, int ringBufferNumEntries, int ringBufferLength)
        {
            int ring_buffer_index = (beginIndex + (getScanline - firstScanline)) % ringBufferNumEntries;
            return GetRingBufferEntry(ringBuffer, ring_buffer_index, ringBufferLength);
        }

        public static void EncodeScanline(
            in ResizeContext context, int numPixels,
            Span<byte> outputBuffer, Span<float> encodeBuffer,
            int channels, int alphaChannel, int decode)
        {
            int x;
            int n;

            fixed (float* src = encodeBuffer)
            {
                if ((context.flags & (1 << 0)) == 0)
                {
                    for (x = 0; x < numPixels; ++x)
                    {
                        int pixel_index = x * channels;
                        float alpha = src[pixel_index + alphaChannel];
                        float reciprocal_alpha = (float)(alpha != 0 ? 1f / alpha : 0);

                        for (n = 0; n < channels; n++)
                            if (n != alphaChannel)
                                src[pixel_index + n] *= (float)reciprocal_alpha;
                    }
                }

                int num_nonalpha;
                ushort* nonalpha = stackalloc ushort[64];
                for (x = 0, num_nonalpha = 0; x < channels; ++x)
                {
                    if ((x != alphaChannel) || ((context.flags & (1 << 1)) != 0))
                        nonalpha[num_nonalpha++] = (ushort)x;
                }

                fixed (byte* dst8 = outputBuffer)
                {
                    var dst16 = (ushort*)dst8;
                    var dst32 = (uint*)dst8;
                    var dstF = (float*)dst8;

                    bool srgbAlpha = (context.flags & (1 << 1)) == 0;
                    switch (decode)
                    {
                        case ((int)DataType.UInt8) * MAX_COLORSPACES + (int)ColorSpace.Linear:
                            for (x = 0; x < numPixels; ++x)
                            {
                                int pixel_index = x * channels;
                                for (n = 0; n < channels; n++)
                                {
                                    int index = pixel_index + n;
                                    dst8[index] = (byte)(int)((Saturate(src[index]) * 255) + 0.5);
                                }
                            }
                            break;

                        case ((int)DataType.UInt8) * MAX_COLORSPACES + (int)ColorSpace.SRgb:
                            for (x = 0; x < numPixels; ++x)
                            {
                                int pixel_index = x * channels;
                                for (n = 0; n < num_nonalpha; n++)
                                {
                                    int index = pixel_index + nonalpha[n];
                                    dst8[index] = LinearToSrgbByte(src[index]);
                                }

                                if (srgbAlpha)
                                    dst8[pixel_index + alphaChannel] = (byte)(int)(
                                        Saturate(src[pixel_index + alphaChannel]) * 255 + 0.5);
                            }
                            break;

                        case ((int)DataType.UInt16) * MAX_COLORSPACES + (int)ColorSpace.Linear:
                        {
                            for (x = 0; x < numPixels; ++x)
                            {
                                int pixel_index = x * channels;
                                for (n = 0; n < channels; n++)
                                {
                                    int index = pixel_index + n;
                                    dst16[index] = (ushort)(int)(
                                        Saturate(src[index]) * 65535 + 0.5);
                                }
                            }
                            break;
                        }

                        case ((int)DataType.UInt16) * MAX_COLORSPACES + (int)ColorSpace.SRgb:
                        {
                            for (x = 0; x < numPixels; ++x)
                            {
                                int pixel_index = x * channels;
                                for (n = 0; n < num_nonalpha; n++)
                                {
                                    int index = pixel_index + nonalpha[n];
                                    dst16[index] = (ushort)(int)(
                                        LinearToSrgb(Saturate(src[index])) * 65535 + 0.5);
                                }

                                if (srgbAlpha)
                                    dst16[pixel_index + alphaChannel] = (ushort)(int)(
                                        Saturate(src[pixel_index + alphaChannel]) * 65535 + 0.5);
                            }
                            break;
                        }

                        case ((int)DataType.UInt32) * MAX_COLORSPACES + (int)ColorSpace.Linear:
                        {
                            for (x = 0; x < numPixels; ++x)
                            {
                                int pixel_index = x * channels;
                                for (n = 0; n < channels; n++)
                                {
                                    int index = pixel_index + n;
                                    dst32[index] = (uint)((((double)Saturate(src[index])) * 4294967295) + 0.5);
                                }
                            }
                            break;
                        }

                        case ((int)DataType.UInt32) * MAX_COLORSPACES + (int)ColorSpace.SRgb:
                        {
                            for (x = 0; x < numPixels; ++x)
                            {
                                int pixel_index = x * channels;
                                for (n = 0; n < num_nonalpha; n++)
                                {
                                    int index = pixel_index + nonalpha[n];
                                    dst32[index] = (uint)((((double)LinearToSrgb(
                                        (float)Saturate(src[index]))) * 4294967295) + 0.5);
                                }

                                if (srgbAlpha)
                                    dst32[pixel_index + alphaChannel] = (uint)(int)((((double)Saturate(
                                        src[pixel_index + alphaChannel])) * 4294967295) + 0.5);
                            }
                            break;
                        }

                        case ((int)DataType.Float32) * MAX_COLORSPACES + (int)ColorSpace.Linear:
                        {
                            for (x = 0; x < numPixels; ++x)
                            {
                                int pixel_index = x * channels;
                                for (n = 0; n < channels; n++)
                                {
                                    int index = pixel_index + n;
                                    dstF[index] = src[index];
                                }
                            }
                            break;
                        }

                        case ((int)DataType.Float32) * MAX_COLORSPACES + (int)ColorSpace.SRgb:
                        {
                            for (x = 0; x < numPixels; ++x)
                            {
                                int pixel_index = x * channels;
                                for (n = 0; n < num_nonalpha; n++)
                                {
                                    int index = pixel_index + nonalpha[n];
                                    dstF[index] = (float)LinearToSrgb(src[index]);
                                }

                                if (srgbAlpha)
                                    dstF[pixel_index + alphaChannel] = src[pixel_index + alphaChannel];
                            }
                            break;
                        }
                    }
                }
            }

            //Thread.Sleep(200);

            //context.ReportProgress(0, null);
        }

        public static void ResampleVerticalUpsample(
            in ResizeContext context, int n, int inFirstScanline, int inLastScanline, float inCenterOfOut)
        {
            int x;
            int k;
            int c;
            int output_w = context.output_w;
            int channels = context.channels;
            int alpha_channel = context.alpha_channel;
            int ring_buffer_entries = context.ring_buffer_num_entries;
            int decode = (int)context.datatype * MAX_COLORSPACES + (int)context.colorspace;
            int ring_buffer_begin_index = context.ring_buffer_begin_index;
            int ring_buffer_first_scanline = context.ring_buffer_first_scanline;
            int ring_buffer_last_scanline = context.ring_buffer_last_scanline;
            int ring_buffer_length = context.RingBufferLength;
            int output_row_start = n * context.output_stride_bytes;

            int coefficient_width = context.vertical_coefficient_width;
            int contributor = n;
            int n0 = context.vertical_contributors[contributor].n0;
            int n1 = context.vertical_contributors[contributor].n1;

            context.encode_buffer.Clear();

            fixed (float* vertical_coefficients_ptr = context.vertical_coefficients)
            fixed (float* dst = context.encode_buffer)
            {
                int coefficient_group = coefficient_width * contributor;
                float* coefficients = vertical_coefficients_ptr + coefficient_group;

                switch (channels)
                {
                    case 1:
                        for (k = n0; k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                k, context.ring_buffer,
                                ring_buffer_begin_index,
                                ring_buffer_first_scanline,
                                ring_buffer_entries,
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; x < output_w; ++x)
                            {
                                int in_pixel_index = x * 1;
                                dst[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                            }
                        }
                        break;

                    case 2:
                        for (k = n0; k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                k, context.ring_buffer,
                                ring_buffer_begin_index,
                                ring_buffer_first_scanline,
                                ring_buffer_entries,
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; x < output_w; ++x)
                            {
                                int in_pixel_index = x * 2;
                                dst[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                                dst[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
                            }
                        }
                        break;

                    case 3:
                        for (k = n0; k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                k, context.ring_buffer,
                                ring_buffer_begin_index,
                                ring_buffer_first_scanline,
                                ring_buffer_entries,
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; x < output_w; ++x)
                            {
                                int in_pixel_index = x * 3;
                                dst[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                                dst[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
                                dst[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;
                            }
                        }
                        break;

                    case 4:
                        for (k = n0; k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                k, context.ring_buffer,
                                ring_buffer_begin_index,
                                ring_buffer_first_scanline,
                                ring_buffer_entries,
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; x < output_w; ++x)
                            {
                                int in_pixel_index = x * 4;
                                dst[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;
                                dst[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;
                                dst[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;
                                dst[in_pixel_index + 3] += ring_buffer_entry[in_pixel_index + 3] * coefficient;
                            }
                        }
                        break;

                    default:
                        for (k = n0; k <= n1; k++)
                        {
                            var ring_buffer_entry = GetRingBufferScanline(
                                k, context.ring_buffer,
                                ring_buffer_begin_index,
                                ring_buffer_first_scanline,
                                ring_buffer_entries,
                                ring_buffer_length);

                            float coefficient = *coefficients++;
                            for (x = 0; x < output_w; ++x)
                            {
                                int in_pixel_index = x * channels;
                                for (c = 0; c < channels; c++)
                                    dst[in_pixel_index + c] += ring_buffer_entry[in_pixel_index + c] * coefficient;
                            }
                        }
                        break;
                }
            }

            EncodeScanline(
                context, output_w, context.output_data.Slice(output_row_start),
                context.encode_buffer, channels, alpha_channel, decode);
        }

        public static void ResampleVerticalDownsample(
            in ResizeContext context, int n, int inFirstScanline, int inLastScanline, float inCenterOfOut)
        {
            int contributor = n + context.vertical_filter_pixel_margin;
            int n0 = context.vertical_contributors[contributor].n0;
            int n1 = context.vertical_contributors[contributor].n1;

            int coefficient_group = context.vertical_coefficient_width * contributor;

            fixed (float* src = context.horizontal_buffer)
            {
                int x;
                int c;

                for (int k = n0; k <= n1; k++)
                {
                    var ring_buffer_entry = GetRingBufferScanline(
                        k, context.ring_buffer,
                        context.ring_buffer_begin_index,
                        context.ring_buffer_first_scanline,
                        context.ring_buffer_num_entries,
                         context.RingBufferLength);

                    int coefficient_index = k - n0;
                    float coefficient = (float)context.vertical_coefficients[coefficient_group + coefficient_index];

                    switch (context.channels)
                    {
                        case 1:
                            for (x = 0; x < context.output_w; x++)
                            {
                                int in_pixel_index = x * 1;
                                ring_buffer_entry[in_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                            }
                            break;

                        case 2:
                            for (x = 0; x < context.output_w; x++)
                            {
                                int in_pixel_index = x * 2;
                                ring_buffer_entry[in_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                ring_buffer_entry[in_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                            }
                            break;

                        case 3:
                            for (x = 0; x < context.output_w; x++)
                            {
                                int in_pixel_index = x * 3;
                                ring_buffer_entry[in_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                ring_buffer_entry[in_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                                ring_buffer_entry[in_pixel_index + 2] += src[in_pixel_index + 2] * coefficient;
                            }
                            break;

                        case 4:
                            for (x = 0; x < context.output_w; x++)
                            {
                                int in_pixel_index = x * 4;
                                ring_buffer_entry[in_pixel_index + 0] += src[in_pixel_index + 0] * coefficient;
                                ring_buffer_entry[in_pixel_index + 1] += src[in_pixel_index + 1] * coefficient;
                                ring_buffer_entry[in_pixel_index + 2] += src[in_pixel_index + 2] * coefficient;
                                ring_buffer_entry[in_pixel_index + 3] += src[in_pixel_index + 3] * coefficient;
                            }
                            break;

                        default:
                            for (x = 0; x < context.output_w; x++)
                            {
                                int in_pixel_index = x * context.channels;
                                for (c = 0; c < context.channels; c++)
                                    ring_buffer_entry[in_pixel_index + c] += src[in_pixel_index + c] * coefficient;
                            }
                            break;
                    }
                }
            }
        }

        public static void BufferLoopUpsample(ref ResizeContext context)
        {
            float scale_ratio = context.vertical_scale;
            float out_scanlines_radius = context.vertical_filter.Support(1 / scale_ratio) * scale_ratio;

            for (int y = 0; y < context.output_h; y++)
            {
                CalculateSampleRangeUpsample(
                    y, (float)out_scanlines_radius, (float)scale_ratio, context.vertical_shift,
                    out int in_first_scanline, out int in_last_scanline, out float in_center_of_out);

                if (context.ring_buffer_begin_index >= 0)
                {
                    while (in_first_scanline > context.ring_buffer_first_scanline)
                    {
                        if (context.ring_buffer_first_scanline == context.ring_buffer_last_scanline)
                        {
                            context.ring_buffer_begin_index = -1;
                            context.ring_buffer_first_scanline = 0;
                            context.ring_buffer_last_scanline = 0;
                            break;
                        }
                        else
                        {
                            context.ring_buffer_first_scanline++;
                            context.ring_buffer_begin_index =
                                (context.ring_buffer_begin_index + 1) % context.ring_buffer_num_entries;
                        }
                    }
                }

                if (context.ring_buffer_begin_index < 0)
                    DecodeAndResampleUpsample(ref context, in_first_scanline);

                while (in_last_scanline > context.ring_buffer_last_scanline)
                    DecodeAndResampleUpsample(ref context, context.ring_buffer_last_scanline + 1);

                ResampleVerticalUpsample(
                    context, y, in_first_scanline, in_last_scanline, in_center_of_out);
            }
        }

        public static void EmptyRingBuffer(ref ResizeContext context, int firstNecessaryScanline)
        {
            if (context.ring_buffer_begin_index < 0)
                return;

            int decode = (int)context.datatype * MAX_COLORSPACES + (int)context.colorspace;
            int ring_buffer_length = context.RingBufferLength;

            while (firstNecessaryScanline > context.ring_buffer_first_scanline)
            {
                if ((context.ring_buffer_first_scanline >= 0) &&
                    (context.ring_buffer_first_scanline < context.output_h))
                {
                    var ring_buffer_entry = GetRingBufferEntry(
                         context.ring_buffer,
                        context.ring_buffer_begin_index,
                        ring_buffer_length);

                    int output_row_start = context.ring_buffer_first_scanline * context.output_stride_bytes;
                    var output = context.output_data.Slice(output_row_start, context.output_stride_bytes);

                    EncodeScanline(
                        context, context.output_w, output, ring_buffer_entry,
                        context.channels, context.alpha_channel, decode);
                }

                if (context.ring_buffer_first_scanline == context.ring_buffer_last_scanline)
                {
                    context.ring_buffer_begin_index = -1;
                    context.ring_buffer_first_scanline = 0;
                    context.ring_buffer_last_scanline = 0;
                    break;
                }
                else
                {
                    context.ring_buffer_first_scanline++;
                    context.ring_buffer_begin_index =
                        (context.ring_buffer_begin_index + 1) % context.ring_buffer_num_entries;
                }
            }
        }

        public static void BufferLoopDownsample(ref ResizeContext context)
        {
            float scale_ratio = context.vertical_scale;
            float in_pixels_radius = (float)(context.vertical_filter.Support(scale_ratio) / scale_ratio);
            int pixel_margin = context.vertical_filter_pixel_margin;
            int max_y = context.input_h + pixel_margin;

            for (int y = -pixel_margin; y < max_y; y++)
            {
                CalculateSampleRangeDownsample(
                    y, (float)in_pixels_radius, (float)scale_ratio, context.vertical_shift,
                    out int out_first_scanline, out int out_last_scanline, out float out_center_of_in);

                if ((out_last_scanline < 0) || (out_first_scanline >= context.output_h))
                    continue;

                EmptyRingBuffer(ref context, out_first_scanline);
                DecodeAndResampleDownsample(context, y);

                if (context.ring_buffer_begin_index < 0)
                    AddEmptyRingBufferEntry(ref context, out_first_scanline);

                while (out_last_scanline > context.ring_buffer_last_scanline)
                    AddEmptyRingBufferEntry(ref context, context.ring_buffer_last_scanline + 1);

                ResampleVerticalDownsample(
                    context,
                    y,
                    out_first_scanline,
                    out_last_scanline,
                    (float)out_center_of_in);
            }

            EmptyRingBuffer(ref context, context.output_h);
        }

        public static void Setup(
            ref ResizeContext context,
            int inputW, int inputH, int outputW, int outputH, int channels,
            ResizeProgressCallback? onProgress)
        {
            context.input_w = inputW;
            context.input_h = inputH;
            context.output_w = outputW;
            context.output_h = outputH;
            context.channels = channels;
            context.ProgressCallback = onProgress;
        }

        public static void CalculateTransform(
            ref ResizeContext context,
            float s0, float t0, float s1, float t1, Transform? transform)
        {
            context.s0 = s0;
            context.t0 = t0;
            context.s1 = s1;
            context.t1 = t1;

            if (transform.HasValue)
            {
                var tf = transform.Value;
                context.horizontal_scale = tf.ScaleX;
                context.vertical_scale = tf.ScaleY;
                context.horizontal_shift = tf.ShiftX;
                context.vertical_shift = tf.ShiftY;
            }
            else
            {
                context.horizontal_scale = (float)context.output_w / context.input_w / (s1 - s0);
                context.vertical_scale = (float)context.output_h / context.input_h / (t1 - t0);
                context.horizontal_shift = s0 * context.output_w / (s1 - s0);
                context.vertical_shift = t0 * context.output_h / (t1 - t0);
            }

        }

        public static void ChooseFilters(
            ref ResizeContext context,
            Filter? horizontalFilter, Filter? verticalFilter)
        {
            if (horizontalFilter == null)
                horizontalFilter = UseUpsampling(context.horizontal_scale)
                    ? Filter.CatmullRom
                    : Filter.Mitchell;

            if (verticalFilter == null)
                verticalFilter = UseUpsampling(context.vertical_scale)
                    ? Filter.CatmullRom
                    : Filter.Mitchell;

            context.horizontal_filter = horizontalFilter;
            context.vertical_filter = verticalFilter;
        }

        public static int CalculateMemory(ref ResizeContext context)
        {
            int pixel_margin = GetFilterPixelMargin(context.horizontal_filter, context.horizontal_scale);
            int filter_height = GetFilterPixelWidth(context.vertical_filter, context.vertical_scale);

            context.horizontal_num_contributors = GetContributors(
                context.horizontal_scale, context.horizontal_filter, context.input_w, context.output_w);
            context.vertical_num_contributors = GetContributors(
                context.vertical_scale, context.vertical_filter, context.input_h, context.output_h);

            context.ring_buffer_num_entries = filter_height + 1;
            context.horizontal_contributors_size = context.horizontal_num_contributors * sizeof(Contributors);
            context.horizontal_coefficients_size = GetTotalHorizontalCoefficients(context) * sizeof(float);
            context.vertical_contributors_size = context.vertical_num_contributors * sizeof(Contributors);
            context.vertical_coefficients_size = GetTotalVerticalCoefficients(context) * sizeof(float);
            context.decode_buffer_size = (context.input_w + pixel_margin * 2) * context.channels * sizeof(float);
            context.horizontal_buffer_size = context.output_w * context.channels * sizeof(float);
            context.ring_buffer_length_bytes = context.output_w * context.channels * sizeof(float);
            context.ring_buffer_size = context.ring_buffer_length_bytes * context.ring_buffer_num_entries;
            context.encode_buffer_size = context.output_w * context.channels * sizeof(float);

            if (UseHeightUpsampling(context))
                context.horizontal_buffer_size = 0;
            else
                context.encode_buffer_size = 0;

            return
                context.horizontal_contributors_size +
                context.horizontal_coefficients_size +
                context.vertical_contributors_size +
                context.vertical_coefficients_size +
                context.decode_buffer_size +
                context.horizontal_buffer_size +
                context.ring_buffer_size +
                context.encode_buffer_size;
        }

        public static int ResizeAllocated(
            ref ResizeContext context,
            int alphaChannel, int flags, DataType datatype,
            WrapMode horizontalWrap, WrapMode verticalWrap,
            ColorSpace colorspace,
            Span<byte> tmpMemory)
        {
            if (tmpMemory.IsEmpty)
                return 0;
            if (context.horizontal_filter == null)
                return 0;
            if (context.vertical_filter == null)
                return 0;
            if ((context.channels < 0) || (context.channels > 64))
                return 0;
            if (alphaChannel >= context.channels)
                return 0;

            if (alphaChannel < 0)
                flags |= (1 << 1) | (1 << 0);

            int memory_required = CalculateMemory(ref context);
            if (tmpMemory.Length < memory_required)
                return 0;

            tmpMemory = tmpMemory.Slice(0, memory_required);
            tmpMemory.Clear();

            context.alpha_channel = alphaChannel;
            context.flags = flags;
            context.datatype = datatype;
            context.wrap_horizontal = horizontalWrap;
            context.wrap_vertical = verticalWrap;
            context.colorspace = colorspace;
            context.horizontal_coefficient_width =
                GetCoefficientWidth(context.horizontal_filter, context.horizontal_scale);
            context.vertical_coefficient_width =
                GetCoefficientWidth(context.vertical_filter, context.vertical_scale);
            context.horizontal_filter_pixel_width =
                GetFilterPixelWidth(context.horizontal_filter, context.horizontal_scale);
            context.vertical_filter_pixel_width =
                GetFilterPixelWidth(context.vertical_filter, context.vertical_scale);
            context.horizontal_filter_pixel_margin =
                GetFilterPixelMargin(context.horizontal_filter, context.horizontal_scale);
            context.vertical_filter_pixel_margin =
                GetFilterPixelMargin(context.vertical_filter, context.vertical_scale);

            context.decode_buffer_pixels = context.input_w + context.horizontal_filter_pixel_margin * 2;
            context.ring_buffer_begin_index = -1;

            context.horizontal_contributors =
                MemoryMarshal.Cast<byte, Contributors>(tmpMemory.Slice(0, context.horizontal_contributors_size));
            tmpMemory = tmpMemory.Slice(context.horizontal_contributors_size);

            context.horizontal_coefficients =
                MemoryMarshal.Cast<byte, float>(tmpMemory.Slice(0, context.horizontal_coefficients_size));
            tmpMemory = tmpMemory.Slice(context.horizontal_coefficients_size);

            context.vertical_contributors =
                MemoryMarshal.Cast<byte, Contributors>(tmpMemory.Slice(0, context.vertical_contributors_size));
            tmpMemory = tmpMemory.Slice(context.vertical_contributors_size);

            context.vertical_coefficients =
                MemoryMarshal.Cast<byte, float>(tmpMemory.Slice(0, context.vertical_coefficients_size));
            tmpMemory = tmpMemory.Slice(context.vertical_coefficients_size);

            context.decode_buffer =
                MemoryMarshal.Cast<byte, float>(tmpMemory.Slice(0, context.decode_buffer_size));
            tmpMemory = tmpMemory.Slice(context.decode_buffer_size);

            if (UseHeightUpsampling(context))
            {
                context.horizontal_buffer = default;

                context.ring_buffer =
                    MemoryMarshal.Cast<byte, float>(tmpMemory.Slice(0, context.ring_buffer_size));
                tmpMemory = tmpMemory.Slice(context.ring_buffer_size);

                context.encode_buffer =
                    MemoryMarshal.Cast<byte, float>(tmpMemory.Slice(0, context.encode_buffer_size));
                //tmpMemory = tmpMemory.Slice(s.encode_buffer_size);
            }
            else
            {
                context.horizontal_buffer =
                    MemoryMarshal.Cast<byte, float>(tmpMemory.Slice(0, context.horizontal_buffer_size));
                tmpMemory = tmpMemory.Slice(context.horizontal_buffer_size);

                context.ring_buffer =
                    MemoryMarshal.Cast<byte, float>(tmpMemory.Slice(0, context.ring_buffer_size));
                //tmpMemory = tmpMemory.Slice(s.ring_buffer_size);

                context.encode_buffer = default;
            }

            CalculateFilters(
                context.horizontal_contributors, context.horizontal_coefficients,
                context.horizontal_filter, context.horizontal_scale, context.horizontal_shift,
                context.input_w, context.output_w);

            CalculateFilters(
                context.vertical_contributors, context.vertical_coefficients,
                context.vertical_filter, context.vertical_scale, context.vertical_shift,
                context.input_h, context.output_h);

            if (UseHeightUpsampling(context))
                BufferLoopUpsample(ref context);
            else
                BufferLoopDownsample(ref context);

            return 1;
        }

        public static int ResizeArbitrary(
            ReadOnlySpan<byte> inputData, int inputW, int inputH, int inputStrideInBytes,
            Span<byte> outputData, int outputW, int outputH, int outputStrideInBytes,
            float s0, float t0, float s1, float t1, Transform? transform,
            int channels, int alphaChannel, int flags, DataType datatype,
            Filter? horizontalFilter, Filter? verticalFilter,
            WrapMode horizontalWrap, WrapMode verticalWrap,
            ColorSpace colorspace,
            ResizeProgressCallback? onProgress = null)
        {
            var context = new ResizeContext();
            Setup(ref context, inputW, inputH, outputW, outputH, channels, onProgress);
            CalculateTransform(ref context, (float)s0, (float)t0, (float)s1, (float)t1, transform);
            ChooseFilters(ref context, horizontalFilter, verticalFilter);

            int tmp_memory_required = CalculateMemory(ref context);

            // TODO: pool
            Memory<byte> tmp_memory = new byte[tmp_memory_required];

            context.input_data = inputData;
            context.input_stride_bytes = inputStrideInBytes != 0
                    ? inputStrideInBytes
                    : context.channels * context.input_w * DataTypeSize[(int)datatype];

            context.output_data = outputData;
            context.output_stride_bytes = outputStrideInBytes != 0
                    ? outputStrideInBytes
                    : context.channels * context.output_w * DataTypeSize[(int)datatype];

            return ResizeAllocated(
                ref context,
                alphaChannel, flags, datatype,
                horizontalWrap, verticalWrap,
                colorspace,
                tmp_memory.Span);
        }

        public static int Resize(
            ReadOnlySpan<byte> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<byte> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            int numChannels,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                inputPixels, inputW, inputH, inputStrideInBytes,
                outputPixels, outputW, outputH, outputStrideInBytes,
                0f, 0f, 1f, 1f, null,
                numChannels, -1, 0, (int)DataType.UInt8,
                null, null,
                WrapMode.Clamp, WrapMode.Clamp,
                ColorSpace.Linear,
                onProgress);
        }

        public static int Resize(
            ReadOnlySpan<float> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<byte> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            int numChannels,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                MemoryMarshal.AsBytes(inputPixels), inputW, inputH, inputStrideInBytes,
                outputPixels, outputW, outputH, outputStrideInBytes,
                0f, 0f, 1f, 1f, null,
                numChannels, -1, 0, DataType.Float32,
                null, null,
                WrapMode.Clamp, WrapMode.Clamp,
                ColorSpace.Linear,
                onProgress);
        }

        public static int ResizeSrgb(
            ReadOnlySpan<byte> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<byte> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            int numChannels, int alphaChannel, int flags,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                inputPixels, inputW, inputH, inputStrideInBytes,
                outputPixels, outputW, outputH, outputStrideInBytes,
                0f, 0f, 1f, 1f, null,
                numChannels, alphaChannel, flags, DataType.UInt8,
                null, null,
                WrapMode.Clamp, WrapMode.Clamp,
                ColorSpace.SRgb,
                onProgress);
        }

        public static int ResizeSrgbEdgemode(
            ReadOnlySpan<byte> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<byte> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            int numChannels, int alphaChannel, int flags,
            WrapMode wrapmode,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                inputPixels, inputW, inputH, inputStrideInBytes,
                outputPixels, outputW, outputH, outputStrideInBytes,
                0f, 0f, 1f, 1f, null,
                numChannels, alphaChannel, flags, DataType.UInt8,
                null, null,
                wrapmode, wrapmode,
                ColorSpace.SRgb,
                onProgress);
        }

        public static int ResizeGeneric(
            ReadOnlySpan<byte> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<byte> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            int numChannels, int alphaChannel, int flags,
            WrapMode wrapmode, Filter filter,
            ColorSpace colorspace,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                inputPixels, inputW, inputH,
                inputStrideInBytes, outputPixels, outputW, outputH,
                outputStrideInBytes,
                0f, 0f, 1f, 1f, null,
                numChannels, alphaChannel, flags, DataType.UInt8,
                filter, filter,
                wrapmode, wrapmode,
                colorspace,
                onProgress);
        }

        [CLSCompliant(false)]
        public static int ResizeGeneric(
            ReadOnlySpan<ushort> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<ushort> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            int numChannels, int alphaChannel, int flags,
            WrapMode wrapmode, Filter filter,
            ColorSpace colorspace,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                MemoryMarshal.AsBytes(inputPixels), inputW, inputH,
                inputStrideInBytes, MemoryMarshal.AsBytes(outputPixels), outputW, outputH,
                outputStrideInBytes,
                0f, 0f, 1f, 1f, null,
                numChannels, alphaChannel, flags, DataType.UInt16,
                filter, filter,
                wrapmode, wrapmode,
                colorspace,
                onProgress);
        }

        public static int ResizeGeneric(
            ReadOnlySpan<float> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<float> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            int numChannels, int alphaChannel, int flags,
            WrapMode wrapmode, Filter filter,
            ColorSpace colorspace,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                MemoryMarshal.AsBytes(inputPixels), inputW, inputH, inputStrideInBytes,
                MemoryMarshal.AsBytes(outputPixels), outputW, outputH, outputStrideInBytes,
                0f, 0f, 1f, 1f, null,
                numChannels, alphaChannel, flags, DataType.Float32,
                filter, filter,
                wrapmode, wrapmode,
                colorspace,
                onProgress);
        }

        public static int Resize(
            ReadOnlySpan<byte> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<byte> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            DataType datatype, int numChannels, int alphaChannel, int flags,
            WrapMode horizontalWrap, WrapMode verticalWrap,
            Filter horizontalFilter, Filter verticalFilter,
            ColorSpace colorspace,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                inputPixels, inputW, inputH, inputStrideInBytes,
                outputPixels, outputW, outputH, outputStrideInBytes,
                0f, 0f, 1f, 1f, null,
                numChannels, alphaChannel, flags, datatype,
                horizontalFilter, verticalFilter,
                horizontalWrap, verticalWrap,
                colorspace,
                onProgress);
        }

        public static int ResizeSubpixel(
            ReadOnlySpan<byte> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<byte> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            DataType datatype, int numChannels, int alphaChannel, int flags,
            WrapMode horizontalWrap, WrapMode verticalWrap,
            Filter horizontalFilter, Filter verticalFilter,
            ColorSpace colorspace, Transform? transform,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                inputPixels, inputW, inputH, inputStrideInBytes,
                outputPixels, outputW, outputH, outputStrideInBytes,
                0f, 0f, 1f, 1f, transform,
                numChannels, alphaChannel, flags, datatype,
                horizontalFilter, verticalFilter,
                horizontalWrap, verticalWrap,
                colorspace,
                onProgress);
        }

        public static int ResizeRegion(
            ReadOnlySpan<byte> inputPixels, int inputW, int inputH, int inputStrideInBytes,
            Span<byte> outputPixels, int outputW, int outputH, int outputStrideInBytes,
            DataType datatype, int numChannels, int alphaChannel, int flags,
            WrapMode horizontalWrap, WrapMode verticalWrap,
            Filter horizontalFilter, Filter verticalFilter,
            ColorSpace colorspace,
            float s0, float t0, float s1, float t1,
            ResizeProgressCallback? onProgress = null)
        {
            return ResizeArbitrary(
                inputPixels, inputW, inputH, inputStrideInBytes,
                outputPixels, outputW, outputH, outputStrideInBytes,
                (float)s0, (float)t0, (float)s1, (float)t1, null,
                numChannels, alphaChannel, flags, datatype,
                horizontalFilter, verticalFilter,
                horizontalWrap, verticalWrap,
                colorspace,
                onProgress);
        }
    }
}